<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Media App</title>
    <script>
      // Shim for Electron API to prevent crashes
      window.mediaAPI = window.mediaAPI || {
        app: { 
          setFullscreen: async () => {}, 
          setPlayerFocusable: async () => {}, 
          showMainWindow: async () => {} 
        },
        player: { 
          play: async () => {}, 
          stop: async () => {}, 
          command: async () => {}, 
          initSubtitles: async () => {}, 
          loadSubtitle: async () => {}, 
          getSubtitles: async () => [], 
          onSubtitlesReady: () => {} 
        },
        openExternal: async (url) => { window.open(url, '_blank'); }
      };
    </script>
    <style>
        :root {
            --bg: #0f0f10;
            --text: #fff;
            --muted: #b9b9c0;
            --radius: 14px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: Arial,sans-serif;
            overflow-y: auto;
            height: 100vh;
        }

        /* Boot splash (blocks interaction during init) */
        .bootSplash {
            position: fixed;
            inset: 0;
            z-index: 2500;
            background: var(--bg);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 14px;
            pointer-events: all;
        }

        .bootSpinner {
            width: 44px;
            height: 44px;
            border-radius: 999px;
            border: 4px solid rgba(255,255,255,0.18);
            border-top-color: rgba(255,255,255,0.92);
            animation: bootSpin 0.9s linear infinite;
        }

        .bootText {
            font-weight: 900;
            font-size: 16px;
            letter-spacing: 0.2px;
            color: rgba(255,255,255,0.92);
        }

        .bootSub {
            font-size: 12px;
            color: rgba(255,255,255,0.55);
        }

        @keyframes bootSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        body.tv-active {
            overflow: hidden;
        }

        /* Subtle fade pulse on view changes (keeps navigation feeling smooth) */
        @keyframes uiFadePulse {
            from { opacity: 0.92; }
            to { opacity: 1; }
        }

        .uiFadePulse {
            animation: uiFadePulse 140ms ease-out;
        }
        
        /* Custom scrollbar styling for TV interface */
        #tvMainCategoriesList::-webkit-scrollbar,
        #tvSubfoldersList::-webkit-scrollbar,
        #tvChannelsContainer::-webkit-scrollbar {
            width: 8px;
        }
        
        #tvMainCategoriesList::-webkit-scrollbar-track,
        #tvSubfoldersList::-webkit-scrollbar-track,
        #tvChannelsContainer::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #tvMainCategoriesList::-webkit-scrollbar-thumb,
        #tvSubfoldersList::-webkit-scrollbar-thumb,
        #tvChannelsContainer::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        
        #tvMainCategoriesList::-webkit-scrollbar-thumb:hover,
        #tvSubfoldersList::-webkit-scrollbar-thumb:hover,
        #tvChannelsContainer::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
            background-clip: padding-box;
        }

        .topbar {
            position: sticky;
            top: 0;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            background: #000;
            backdrop-filter: none;
            border-bottom: none;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 900;
            letter-spacing: .4px;
            margin-right: 4px
        }

        .brandMenu {
            position: relative;
            display: flex;
            align-items: center;
            flex: 0 0 auto;
        }

        .brandMenuBtn {
            border: 0;
            background: transparent;
            padding: 0;
            width: 44px;
            height: 44px;
            border-radius: 999px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .brandMenuBtn:focus-visible {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }

        .brandIcon {
            width: 34px;
            height: 34px;
            border-radius: 999px;
            flex: 0 0 auto;
            object-fit: contain;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
        }

        .brandText {
            white-space: nowrap;
        }

        .tabs {
            display: flex;
            gap: 14px;
            align-items: center;
            position: relative;
            flex: 1 1 auto;
            justify-content: center;
        }

        .brandMenuDropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            min-width: 160px;
            padding: 8px;
            border-radius: 10px;
            background: rgba(20,20,22,0.98);
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            display: none;
            flex-direction: column;
            gap: 8px;
            z-index: 1300;
        }

        .brandMenuDropdown.open {
            display: flex;
        }

        .brandMenuItem {
            width: 100%;
            text-align: left;
        }

        .iconBtn {
            width: 40px;
            height: 40px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .iconBtn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
            opacity: 0.95;
        }

        .tabIndicator {
            position: absolute;
            top: 50%;
            left: 0;
            height: 34px;
            width: 0;
            border-radius: 999px;
            background: rgba(255,255,255,0.20);
            transform: translateY(-50%);
            transition: left 180ms ease, width 180ms ease, height 180ms ease;
            pointer-events: none;
            z-index: 0;
        }

        .topbarSpacer {
            flex: 1 1 auto;
        }

        .topbarActions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tabBtn {
            border: 0;
            background: transparent;
            color: rgba(255,255,255,0.92);
            padding: 8px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 900;
            font-size: 14px;
            opacity: 1;
            white-space: nowrap;
            position: relative;
            z-index: 1;
            transition: color 140ms ease;
        }

        .tabBtn:hover {
            background: rgba(255,255,255,0.08);
        }

        .tabBtn:focus-visible {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }

            .tabBtn.active {
                color: rgba(255,255,255,0.98);
            }

        .search {
            flex: 1;
            max-width: 560px;
            display: flex;
            align-items: center;
            margin-left: 10px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 999px;
            padding: 10px 14px;
            position: relative;
        }

        /* Collapsible search UI (opened via icon click) */
        .search.collapsed {
            display: none;
        }

        /* Highlighted search results row */
        .searchResultsRow {
            border-top: 1px solid rgba(255,255,255,0.06);
            padding: 12px 0 20px 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
        }
            /* Dropdown container attached to the search bar */
            #searchResultsContainer {
                position: absolute;
                left: 0;
                right: 0;
                top: 100%; /* attach directly to bottom of topbar */
                z-index: 1200;
                margin: 0;
                padding: 8px 10px;
                background: rgba(20,20,22,0.98);
                border-radius: 8px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.6);
                transform-origin: top center;
                opacity: 0;
                pointer-events: none;
                max-height: 0;
                overflow: hidden;
                transition: max-height 240ms ease, opacity 180ms ease, transform 200ms ease;
            }
            #searchResultsContainer.open {
                opacity: 1;
                pointer-events: auto;
                max-height: 320px;
                transform: translateY(0);
            }
            #searchResultsContainer .sectionTitle { font-weight:700; }

            /* Make the search row horizontal scrollable */
            .searchResultsRow {
                display: flex;
                gap: 12px;
                overflow-x: auto;
                padding: 10px 6px;
                align-items: flex-start;
            }
            .searchResultsRow .tile { min-width: 120px; max-width: 140px; }

            .search input {
                width: 100%;
                background: transparent;
                border: none;
                outline: none;
                color: var(--text);
                font-size: 14px
            }

                .search input::placeholder {
                    color: rgba(255,255,255,0.45)
                }

        .btn {
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.06);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 900;
            font-size: 13px
        }

        .btnPrimary {
            background: rgba(255,255,255,0.92);
            color: #0f0f10;
            border-color: rgba(255,255,255,0.92)
        }

        .btnDanger {
            border-color: rgba(255,120,120,0.35);
            background: rgba(255,120,120,0.10)
        }

        #status {
            display: none;
            padding: 10px 18px 0 18px;
            color: rgba(255,255,255,0.55);
            font-size: 12px;
            white-space: pre-wrap
        }

        .error {
            color: #ff7a7a
        }

        /* Fullscreen player overlay */
        .playerOverlay {
            position: fixed;
            inset: 0;
            z-index: 2000;
            background: #000;
            display: none;
        }

        .playerOverlay.isActive {
            display: block;
        }

        .playerVideoHost {
            position: absolute;
            /* Reserve space so the MPV native surface doesn't cover the HTML controls.
               Because MPV is a separate native window, HTML cannot reliably overlay it. */
            top: 64px;
            left: 0;
            right: 0;
            bottom: 118px;
            background: #000;
        }

        .playerTopBar {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 14px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.78), rgba(0,0,0,0.0));
            pointer-events: none;
        }

        .playerTopBar .btn {
            pointer-events: auto;
        }

        .playerTitle {
            pointer-events: none;
            color: rgba(255,255,255,0.9);
            font-weight: 900;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .playerBottomBar {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            padding: 14px 14px 16px 14px;
            background: linear-gradient(to top, rgba(0,0,0,0.82), rgba(0,0,0,0.0));
            pointer-events: none;
        }

        .playerBottomBar * {
            pointer-events: auto;
        }

        .playerProgressRow {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .playerTime {
            font-variant-numeric: tabular-nums;
            font-size: 12px;
            color: rgba(255,255,255,0.75);
            min-width: 56px;
            text-align: center;
        }

        .playerProgress {
            width: 100%;
        }

        .playerControlsRow {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .playerControlsRow .btn {
            padding: 9px 12px;
            font-size: 12px;
        }

        .playerControlsRow .spacer {
            flex: 1;
        }

        .playerVolume {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .playerVolume input[type="range"] {
            width: 140px;
        }

        /* Home */
        .hero {
            padding: 16px 18px 6px 18px
        }

        .heroCard {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 16px;
            padding: 16px;
            border: 1px solid rgba(255,255,255,0.08);
            background: radial-gradient(1200px 500px at 20% 10%, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            border-radius: var(--radius);
            box-shadow: 0 20px 60px var(--shadow);
            min-height: 210px
        }

        .heroPoster {
            width: 100%;
            border-radius: 12px;
            background: #202028;
            aspect-ratio: 2/3;
            object-fit: cover
        }

        .heroTitle {
            font-size: 26px;
            font-weight: 900;
            margin-top: 6px
        }

        .heroMeta {
            margin-top: 8px;
            color: var(--muted);
            font-size: 13px
        }

        .heroActions {
            margin-top: 14px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap
        }

        .section {
            padding: 0 0 18px 0;
            position: relative;
        }

        .sectionHeader {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            margin: 10px 24px 8px 24px
        }

        .sectionTitle {
            font-size: 22px;
            font-weight: 900;
            letter-spacing: .3px
        }

        .sectionHint {
            color: rgba(255,255,255,0.45);
            font-size: 12px
        }

        .rowWrapper {
            position: relative;
            margin: 0 -24px;
            padding: 0 24px;
        }

        .row {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 6px 3px 12px 3px;
            scroll-behavior: smooth;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

            .row::-webkit-scrollbar {
                display: none;
            }

        .rowNav {
            position: absolute;
            top: 0;
            bottom: 12px;
            width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 5;
            opacity: 0;
            pointer-events: none;
            transition: opacity 200ms ease;
            cursor: pointer;
        }

        .rowWrapper:hover .rowNav {
            opacity: 1;
            pointer-events: auto;
        }

        .rowNav.left {
            left: 0;
            background: linear-gradient(to right, rgba(15,15,16,0.95), transparent);
        }

        .rowNav.right {
            right: 0;
            background: linear-gradient(to left, rgba(15,15,16,0.95), transparent);
        }

        .rowNav svg {
            width: 40px;
            height: 40px;
            fill: rgba(255,255,255,0.7);
            transition: fill 150ms ease, transform 150ms ease;
        }

        .rowNav:hover svg {
            fill: rgba(255,255,255,1);
            transform: scale(1.15);
        }

        .rowNav:active svg {
            transform: scale(0.95);
            fill: rgba(255,255,255,0.9);
        }

        .rowNav.scrolling svg {
            animation: arrowPulse 0.4s ease;
        }

        @keyframes arrowPulse {
            0%, 100% { transform: scale(1.15); }
            50% { transform: scale(1.3); opacity: 0.8; }
        }

        .tile {
            flex: 0 0 auto;
            width: 140px;
            cursor: pointer;
            outline: none;
            border-radius: 12px;
            transform-origin: center center;
            transition: transform 120ms ease, box-shadow 120ms ease, outline 120ms ease;
            will-change: transform;
        }

            .tile:hover {
                transform: scale(1.06);
            }

            .tile:focus {
                transform: scale(1.08);
                box-shadow: 0 18px 50px rgba(0,0,0,0.65);
                outline: 3px solid rgba(255,255,255,0.85);
                outline-offset: 2px
            }

            .tile img {
                width: 100%;
                border-radius: 12px;
                background: #1e1e26;
                aspect-ratio: 2/3;
                object-fit: cover;
                object-position: center;
                display: block
            }

        .tileTitle {
            margin-top: 10px;
            font-size: 13px;
            color: rgba(255,255,255,0.92);
            text-align: center;
            max-width: 140px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        /* Android TV / large-screen compact layout */
        html.tv-compact .topbar {
            padding: 10px 12px;
            gap: 10px;
        }
        html.tv-compact .brandIcon {
            width: 28px;
            height: 28px;
            border-radius: 8px;
        }
        html.tv-compact .tabBtn,
        html.tv-compact .btn {
            padding: 8px 12px;
            font-size: 12px;
        }
        html.tv-compact .sectionHeader {
            margin: 8px 16px 6px 16px;
        }
        html.tv-compact .sectionTitle {
            font-size: 18px;
        }
        html.tv-compact .rowWrapper {
            margin: 0 -16px;
            padding: 0 16px;
        }
        html.tv-compact .row {
            gap: 10px;
            padding: 4px 2px 10px 2px;
        }
        html.tv-compact .tile {
            width: 80px;
        }
        html.tv-compact .tileTitle {
            max-width: 80px;
            font-size: 9px;
            margin-top: 5px;
        }
        html.tv-compact .tile:hover {
            transform: scale(1.03);
        }
        html.tv-compact .tile:focus {
            transform: scale(1.04);
        }

        html.tv-compact .searchResultsRow .tile { min-width: 80px; max-width: 100px; }

        html.tv-compact .modalBackdrop {
            /* TV overscan-safe insets so title/footer aren't clipped */
            padding: 26px 0;
            align-items: stretch;
            justify-content: flex-end;
        }
        html.tv-compact .modal {
            width: min(860px, 76vw);
            /* Fit inside the overscan-safe backdrop padding */
            height: calc(100vh - 52px);
            box-sizing: border-box;
            border-radius: 0;
            border-left: 1px solid rgba(255,255,255,0.10);
        }
        /* On TV: avoid squeezing the main content. Use a single column modal.
           Episodes/seasons are rendered inside the modal body (not the side pane). */
        html.tv-compact .modalGrid {
            grid-template-columns: 1fr;
        }
        html.tv-compact .modalPoster {
            display: none;
        }
        html.tv-compact .modalSide {
            display: none !important;
        }
        html.tv-compact .modalBody {
            padding: 14px 16px;
            gap: 8px;
            flex: 1;
            overflow: hidden;
        }

        /* TV movie details: header uses full top area (title left, meta right) */
        html.tv-compact .modal.movieTvMode .modalHeader {
            display: grid;
            grid-template-columns: minmax(0, 1fr) auto;
            column-gap: 14px;
            row-gap: 4px;
            align-items: start;
        }

        html.tv-compact .modal.movieTvMode .modalTitle {
            grid-column: 1;
            margin: 0;
        }

        html.tv-compact .modal.movieTvMode .modalMeta {
            grid-column: 2;
            justify-self: end;
            align-self: start;
            justify-content: flex-end;
            text-align: right;
        }

        /* TV movie details: add comfortable top/bottom breathing room */
        html.tv-compact .modal.movieTvMode .modalBody {
            /* Use the full top area for the title again */
            padding-top: 18px;
            padding-bottom: 28px;
            gap: 6px;
        }

        /* Keep actions/art away from the footer edge */
        html.tv-compact .modal.movieTvMode .movieHero {
            margin-top: 10px;
            padding-bottom: 18px;
        }

        /* Play button uses a flex spacer to sit at the bottom; add real bottom padding */
        html.tv-compact .modal.movieTvMode .movieActions {
            padding-bottom: 22px;
        }

        /* Keep the poster from feeling glued to the footer edge */
        html.tv-compact .modal.movieTvMode .movieArt {
            margin-bottom: 22px;
        }
        html.tv-compact .modalSide {
            padding: 14px 12px;
        }
        html.tv-compact .modalTitle {
            font-size: 26px;
        }

        /* TV movie: keep the title area fixed so long titles don't make the modal scroll */
        html.tv-compact .modal.movieTvMode .modalTitle {
            height: 64px;
            overflow: hidden;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            word-break: break-word;
        }
        html.tv-compact .modalMeta {
            font-size: 12px;
            gap: 10px;
        }
        html.tv-compact .modalEpisodesWrap {
            margin-top: 6px;
            padding: 10px;
            border-radius: 12px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            min-height: 0;
            overflow: auto;
            max-height: 24vh;
        }

        /* TV series/anime details: use the full modal height (no tiny 24vh box) */
        html.tv-compact .modal.seriesTvMode .modalEpisodesWrap {
            flex: 1;
            max-height: none;
            overflow: hidden;
            padding: 0;
            margin-top: 10px;
            background: transparent;
            border: none;
        }

        html.tv-compact .modal.seriesTvMode .detailsDescription {
            display: none !important;
        }

        /* TV series/anime: never show stream picker (episodes already represent playable sources) */
        html.tv-compact .modal.seriesTvMode #streamHeader,
        html.tv-compact .modal.seriesTvMode #streamList {
            display: none !important;
        }

        /* TV series layout shell: stacked panels (stable on overscan) */
        .tvSeriesShell {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            height: 100%;
        }
        .tvSeriesInfoPanel {
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
        }
        html.tv-compact .tvSeriesInfoPanel {
            /* Keep the header visible and avoid stealing too much vertical space */
            max-height: 18vh;
        }
        .tvSeriesInfoTitle {
            font-weight: 900;
            font-size: 13px;
            color: rgba(255,255,255,0.75);
        }
        .tvSeriesInfoText {
            color: rgba(255,255,255,0.78);
            font-size: 13px;
            line-height: 1.5;
            overflow: auto;
            padding-right: 6px;
            min-height: 0;
        }
        .tvSeriesMainPanel {
            min-height: 0;
            padding: 10px 10px;
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
            flex: 1;
            display: block;
        }
        /* inside the main panel, the existing seriesBrowser already lays out seasons + list */
        html.tv-compact .modal.seriesTvMode .seriesBrowser {
            width: 100%;
            height: 100%;
            grid-template-columns: 260px minmax(0, 1fr);
            gap: 12px;
        }
        html.tv-compact .modal.seriesTvMode .seriesSeasonsTitle,
        html.tv-compact .modal.seriesTvMode .seriesMainTitle {
            font-size: 14px;
        }
        html.tv-compact .modal.seriesTvMode .seasonBtn {
            padding: 14px 12px;
            font-size: 14px;
        }
        html.tv-compact .streamList {
            flex: 1;
            min-height: 0;
            max-height: none;
        }
        html.tv-compact .streamItem {
            padding: 10px 10px;
            border-radius: 12px;
        }
        html.tv-compact .streamName {
            font-size: 12px;
        }
        html.tv-compact .streamUrl {
            font-size: 10px;
        }
        html.tv-compact .modalFooter {
            padding: 10px 12px;
        }

        /* Smaller tiles for compact sections (e.g., Continue Watching) */
        .section--compact .row {
            gap: 12px;
            padding: 4px 3px 8px 3px;
        }

        .section--compact .tile {
            width: 220px;
        }

        .section--compact .tile img {
            aspect-ratio: 16/9;
        }

        .section--compact .tileTitle {
            max-width: 220px;
            font-size: 12px;
            margin-top: 8px;
        }

        /* Settings */
        .settingsWrap {
            padding: 0;
            display: none
        }

        .settingsSubtabs {
            display: flex;
            gap: 8px;
            padding: 16px 18px 0 18px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }

        .settingsSubtabBtn {
            border: none;
            background: transparent;
            color: rgba(255,255,255,0.65);
            padding: 12px 20px;
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            font-weight: 900;
            font-size: 14px;
            transition: all 150ms ease;
        }

        .settingsSubtabBtn:hover {
            background: rgba(255,255,255,0.04);
            color: rgba(255,255,255,0.85);
        }

        .settingsSubtabBtn.active {
            background: rgba(255,255,255,0.08);
            color: var(--text);
        }

        .settingsPanel {
            padding: 16px 18px 26px 18px;
            display: none;
        }

        .settingsPanel.active {
            display: block;
        }

        .settingsCard {
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.04);
            border-radius: 18px;
            padding: 14px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.35);
            margin-bottom: 14px;
        }

        .settingsFormRow {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .settingsInputRow {
            display: flex;
            gap: 10px;
            align-items: center;
            flex: 1;
            min-width: 260px;
        }

        .settingsActionsRow {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .settingsToggleRow {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(255,255,255,0.04);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.06);
        }

        .settingsToggleRow label {
            flex: 1;
            cursor: pointer;
        }

        /* TV-friendly Settings controls */
        html.tv-compact .settingsSubtabs {
            padding: 12px 12px 0 12px;
        }
        html.tv-compact .settingsPanel {
            padding: 12px 12px 18px 12px;
        }
        html.tv-compact .settingsTitle {
            font-size: 16px;
        }
        html.tv-compact .settingsSub {
            font-size: 11px;
        }
        html.tv-compact .settingsCard {
            padding: 12px;
            border-radius: 16px;
        }
        html.tv-compact .settingsFormRow {
            flex-wrap: nowrap;
            align-items: stretch;
        }
        html.tv-compact .settingsInputRow {
            min-width: 0;
        }
        html.tv-compact .settingsActionsRow {
            flex-wrap: nowrap;
        }
        html.tv-compact .settingsActionsRow .btn {
            padding: 12px 16px;
            font-size: 13px;
        }
        html.tv-compact .settingsWrap input[type="text"],
        html.tv-compact .settingsWrap input[type="password"],
        html.tv-compact .settingsWrap input[type="number"] {
            padding: 12px 14px !important;
            border-radius: 999px !important;
            font-size: 13px;
        }

        /* Switch-style checkboxes in Settings (TV mode) */
        html.tv-compact .settingsWrap input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 54px;
            height: 30px;
            border-radius: 999px;
            background: rgba(255,255,255,0.10);
            border: 1px solid rgba(255,255,255,0.14);
            position: relative;
            cursor: pointer;
            outline: none;
            flex: 0 0 auto;
        }
        html.tv-compact .settingsWrap input[type="checkbox"]::before {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            border-radius: 999px;
            background: rgba(255,255,255,0.85);
            transition: transform 160ms ease, background 160ms ease;
        }
        html.tv-compact .settingsWrap input[type="checkbox"]:checked {
            background: rgba(255,255,255,0.92);
            border-color: rgba(255,255,255,0.92);
        }
        html.tv-compact .settingsWrap input[type="checkbox"]:checked::before {
            transform: translateX(24px);
            background: #0f0f10;
        }
        html.tv-compact .settingsWrap input[type="checkbox"]:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }

        /* Clearer focus in Settings */
        html.tv-compact .settingsWrap .btn:focus,
        html.tv-compact .settingsWrap button:focus,
        html.tv-compact .settingsWrap input:focus,
        html.tv-compact .settingsSubtabBtn:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }

        .settingsTitle {
            font-size: 18px;
            font-weight: 900;
            margin: 4px 0 10px 0
        }

        .settingsSub {
            color: rgba(255,255,255,0.60);
            font-size: 12px;
            margin-bottom: 12px
        }

        /* Catalogs Order UI */
        .catalogOrderList { border: 1px solid rgba(255,255,255,0.06); padding: 8px; border-radius: 8px; background: rgba(255,255,255,0.02); }
        .catalogRow { display:flex; align-items:center; gap:8px; padding:8px; border-radius:8px; margin-bottom:6px; background: rgba(0,0,0,0.14); cursor:grab; }
        .catalogRow.dragging { opacity:0.5; }
        .dragHandle { width:22px; text-align:center; font-size:18px; color:rgba(255,255,255,0.7); }
        .catalogName { flex:1; font-weight:700; }
        .catalogSmall { color: rgba(255,255,255,0.6); font-size:12px; margin-left:6px; }

        .installRow {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            padding: 12px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            margin-bottom: 12px;
        }

            .installRow input {
                flex: 1;
                min-width: 280px;
                background: rgba(255,255,255,0.06);
                border: 1px solid rgba(255,255,255,0.10);
                border-radius: 999px;
                padding: 10px 14px;
                color: var(--text);
                outline: none;
            }

        .addonRow {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            padding: 12px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            margin-bottom: 10px;
        }

        /* Episode List Styles */
        .episode-card {
            display: flex;
            gap: 16px;
            padding: 14px;
            border-radius: 10px;
            background: transparent;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
            align-items: center;
            border: 1px solid rgba(255,255,255,0.04);
            border-left: 3px solid transparent;
        }
        .episode-card:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(255,255,255,0.10);
        }
        .episode-card.active {
            background: rgba(255,255,255,0.12);
            border-left-color: rgba(255,255,255,0.92);
            border-color: rgba(255,255,255,0.16);
        }
        .episode-card:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.14);
        }

        .tv-main-folder-btn:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: -3px;
        }

        .tv-card:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
            transform: translateY(-3px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            border-color: rgba(59, 130, 246, 0.5) !important;
        }

        .tv-history-item:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }
        .episode-thumb {
            width: 160px;
            height: 90px;
            border-radius: 8px;
            object-fit: cover;
            background: #222;
            flex-shrink: 0;
        }

        .episode-thumbPlaceholder {
            width: 160px;
            height: 90px;
            border-radius: 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            color: rgba(255,255,255,0.60);
            font-size: 12px;
            font-weight: 900;
            letter-spacing: 0.2px;
        }
        .episode-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 3px;
            min-width: 0;
        }
        .episode-kicker {
            font-weight: 700;
            font-size: 12px;
            color: rgba(255,255,255,0.60);
        }
        .episode-title {
            font-weight: 900;
            font-size: 14px;
            line-height: 1.25;
            white-space: normal;
            overflow: hidden;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .episode-meta {
            font-size: 13px;
            color: rgba(255,255,255,0.60);
        }
        .episode-right {
            min-width: 60px;
            text-align: right;
            color: rgba(255,255,255,0.55);
            font-size: 13px;
            font-weight: 700;
        }
        
        /* Season Selector Styles */
        .season-selector {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: transparent;
            padding: 10px 0;
            margin-bottom: 10px;
        }

        .season-selectWrap {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            border-radius: 999px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
        }

        .season-select {
            background: transparent;
            color: var(--text);
            border: none;
            font-size: 14px;
            font-weight: 900;
            cursor: pointer;
            outline: none;
            appearance: none;
            padding: 0;
        }

        .season-select:focus {
            outline: 3px solid rgba(255,255,255,0.75);
            outline-offset: 3px;
            border-radius: 999px;
        }

        .season-selectArrow {
            font-size: 10px;
            opacity: 0.75;
            pointer-events: none;
        }
        .season-nav-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            padding: 5px 10px;
            transition: color 0.2s;
        }
        .season-nav-btn:hover { color: #fff; }
        .season-nav-btn:disabled { opacity: 0.3; cursor: default; }
        
        .season-dropdown-trigger {
            background: transparent;
            color: #fff;
            border: none;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .season-dropdown-trigger:after {
            content: 'â–¼';
            font-size: 10px;
            opacity: 0.7;
        }

        /* Modal Styles Override */
        .detailsDescription {
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 16px;
            color: rgba(255,255,255,0.86);
            line-height: 1.55;
            font-size: 14px;
            margin: 6px 0 10px 0;
        }

        .detailsMetaGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px 16px;
            margin: 8px 0 14px 0;
        }

        .detailsMetaItem {
            font-size: 13px;
            color: rgba(255,255,255,0.75);
        }

        .detailsMetaLabel {
            color: rgba(255,255,255,0.55);
            font-weight: 900;
            margin-bottom: 3px;
        }

        .detailsMetaValue {
            color: rgba(255,255,255,0.92);
            font-weight: 700;
        }

        .episodesHeader {
            font-size: 22px;
            font-weight: 900;
            margin: 14px 0 10px 0;
        }

        .addonName {
            font-weight: 900;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .addonMeta {
            margin-top: 6px;
            color: rgba(255,255,255,0.60);
            font-size: 11px;
            line-height: 1.5;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            line-clamp: 3;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            max-width: 100%;
            word-break: break-word;
        }

        .addonRight {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
            flex-wrap: wrap
        }

        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 900;
            user-select: none
        }

            .toggle input {
                transform: scale(1.2)
            }

        /* Modal */
        .modalBackdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.72);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 20px;
            overscroll-behavior: contain;
        }

        .modal {
            width: min(1400px, 95vw);
            height: min(90vh, 980px);
            max-width: 100%;
            background: rgba(20,20,24,0.98);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 18px;
            box-shadow: 0 30px 90px rgba(0,0,0,0.75);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            overscroll-behavior: contain;
        }

        .modalGrid {
            display: grid;
            grid-template-columns: 360px 1fr;
            gap: 0;
            min-height: 0;
            flex: 1;
        }

        .modal.hasSide .modalGrid {
            grid-template-columns: 360px minmax(0, 1fr) 440px;
        }

        .modalPoster {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #202028;
            min-height: 100%
        }

        .modalBody {
            padding: 26px 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .modalHeader {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 0;
        }

        .modalSide {
            display: none;
            padding: 26px 18px;
            border-left: 1px solid rgba(255,255,255,0.08);
            min-height: 0;
        }

        .modal.hasSide .modalSide {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .episodesList {
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: auto;
            padding-right: 6px;
            min-height: 0;
            flex: 1;
        }

        /* TV Series details (clean two-column browser) */
        .seriesBrowser {
            display: grid;
            grid-template-columns: 240px minmax(0, 1fr);
            gap: 12px;
            min-height: 0;
        }
        .seriesSeasons {
            min-height: 0;
            overflow: auto;
            padding-right: 6px;
        }
        .seriesSeasonsTitle {
            font-weight: 900;
            font-size: 13px;
            color: rgba(255,255,255,0.75);
            margin: 2px 0 8px 0;
        }
        .seasonBtn {
            width: 100%;
            text-align: left;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.04);
            color: rgba(255,255,255,0.86);
            padding: 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            outline: none;
            font-weight: 900;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .seasonBtn.active {
            background: rgba(255,255,255,0.10);
            border-color: rgba(255,255,255,0.18);
            color: rgba(255,255,255,0.95);
        }
        .seasonBtn:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }
        .seriesMain {
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        .seriesMainHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 2px;
            margin: 2px 0 8px 0;
        }
        .seriesMainTitle {
            font-weight: 900;
            font-size: 13px;
            color: rgba(255,255,255,0.75);
        }
        .miniBackBtn {
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(255,255,255,0.06);
            color: rgba(255,255,255,0.92);
            padding: 8px 12px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 900;
            font-size: 12px;
            outline: none;
        }
        .miniBackBtn:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
        }
        .seriesListBox {
            flex: 1;
            min-height: 0;
            overflow: auto;
            padding-right: 6px;
        }

        /* Movie details (TV-style) */
        .movieHero {
            display: none;
            margin-top: 10px;
            gap: 12px;
            align-items: stretch;
            flex: 1;
            min-height: 0;
        }

        .movieLeft {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
            min-height: 0;
        }

        .movieOverview {
            color: rgba(255,255,255,0.78);
            font-size: 13px;
            line-height: 1.5;
            display: -webkit-box;
            line-clamp: 4;
            -webkit-line-clamp: 4;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        html.tv-compact .movieOverview {
            line-clamp: 3;
            -webkit-line-clamp: 3;
        }

        .movieActions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
            flex: 1;
        }

        /* Scrollable list styling (used for movie sources and series lists) */
        .seriesListBox::-webkit-scrollbar {
            width: 10px;
        }
        .seriesListBox::-webkit-scrollbar-track {
            background: transparent;
        }
        .seriesListBox::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.16);
            border-radius: 999px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        .seriesListBox::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.26);
            background-clip: padding-box;
        }
        .seriesListBox {
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.18) transparent;
        }

        .actionBtn {
            text-align: left;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.92);
            padding: 12px 12px;
            border-radius: 14px;
            cursor: pointer;
            font-weight: 900;
            font-size: 14px;
            outline: none;
        }

        html.tv-compact .actionBtn {
            padding: 10px 10px;
            border-radius: 12px;
            font-size: 13px;
        }

        .actionBtn:focus {
            outline: 3px solid rgba(255,255,255,0.85);
            outline-offset: 2px;
            background: rgba(255,255,255,0.92);
            color: var(--bg);
            border-color: rgba(255,255,255,0.30);
        }

        .actionBtnSub {
            font-size: 12px;
            font-weight: 700;
            color: rgba(255,255,255,0.65);
            margin-top: 4px;
        }

        html.tv-compact .actionBtnSub {
            font-size: 11px;
            margin-top: 3px;
        }

        .actionBtn:focus .actionBtnSub {
            color: rgba(0,0,0,0.70);
        }

        .movieArt {
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(255,255,255,0.04);
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            min-height: 240px;
            height: 100%;
        }

        .movieArt::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, rgba(15,15,16,0.95) 0%, rgba(15,15,16,0.55) 32%, rgba(15,15,16,0.05) 70%);
            pointer-events: none;
        }

        html.tv-compact .movieHero {
            display: grid;
            grid-template-columns: minmax(0, 420px) minmax(0, 1fr);
        }

        html.tv-compact .movieArt {
            /* Keep the art tall on TV, but responsive so it doesn't break the modal layout */
            height: clamp(340px, 52vh, 620px);
            min-height: 0;
            /* Keep top of poster visible (avoid cropping the title area) */
            background-position: top center;
        }

        /* TV movie mode: header is full-width (title + meta) */
        html.tv-compact .modal.movieTvMode .modalTitle,
        html.tv-compact .modal.movieTvMode .modalMeta {
            max-width: none;
        }

        html.tv-compact .seriesBrowser {
            grid-template-columns: 200px minmax(0, 1fr);
            gap: 10px;
        }
        html.tv-compact .seasonBtn {
            padding: 12px 12px;
            font-size: 13px;
        }

        .modalTitle {
            font-size: 40px;
            font-weight: 900;
            margin: 0;
            line-height: 1.15;
        }

        .modalMeta {
            color: rgba(255,255,255,0.60);
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .imdbBadge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.15), rgba(255, 152, 0, 0.15));
            border: 1px solid rgba(255, 193, 7, 0.4);
            border-radius: 6px;
            font-weight: 600;
            color: #ffc107;
            font-size: 13px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .imdbBadge::before {
            content: "â˜…";
            font-size: 14px;
        }

        .metaInfo {
            display: contents;
        }

        .streamList {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: auto;
            padding-right: 6px;
            min-height: 0;
            flex: 1
        }

        .streamItem {
            padding: 12px 12px;
            border-radius: 14px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.10);
            cursor: pointer;
            outline: none;
            transition: transform 120ms ease, background 120ms ease, outline 120ms ease
        }

            .streamItem:hover {
                background: rgba(255,255,255,0.08);
                transform: translateY(-1px)
            }

            .streamItem:focus {
                outline: 3px solid rgba(255,255,255,0.85);
                outline-offset: 2px
            }

        .streamName {
            font-weight: 900;
            font-size: 13px
        }

        .streamUrl {
            margin-top: 6px;
            font-size: 11px;
            color: rgba(255,255,255,0.55);
            word-break: break-all
        }

        .modalFooter {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 14px 18px;
            border-top: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03)
        }

        .modalFooterLeft,
        .modalFooterRight {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        @media (max-width: 920px) {
            .heroCard {
                grid-template-columns: 180px 1fr
            }

            .modalGrid {
                grid-template-columns: 200px 1fr
            }

            .modal.hasSide .modalGrid {
                grid-template-columns: 200px 1fr
            }

            .modalSide {
                display: none !important;
            }
        }

        @media (max-width: 720px) {
            .heroCard {
                grid-template-columns: 1fr
            }

            .modalGrid {
                grid-template-columns: 1fr
            }

            .modal.hasSide .modalGrid {
                grid-template-columns: 1fr
            }

            .modalSide {
                display: none !important;
            }

            .modalPoster {
                min-height: 280px
            }

            .search {
                display: none
            }
        }
    </style>
</head>

<body>
    <div id="bootSplash" class="bootSplash" aria-hidden="false">
        <div class="bootSpinner" aria-hidden="true"></div>
        <div id="bootSplashText" class="bootText">Startingâ€¦</div>
        <div class="bootSub">Loadingâ€¦</div>
    </div>

    <div class="topbar">
        <div class="brandMenu">
            <button id="brandMenuBtn" class="brandMenuBtn" aria-label="Menu" aria-haspopup="true" aria-expanded="false">
                <img class="brandIcon" src="/assets/app-icon-Q6ppP0u8.png" alt="App icon" onerror="this.style.display='none'" />
            </button>
            <div id="brandMenuDropdown" class="brandMenuDropdown" aria-hidden="true">
                <button class="btn brandMenuItem" id="brandMenuRefresh">Refresh</button>
                <button class="btn brandMenuItem" id="brandMenuSettings">Settings</button>
            </div>
        </div>
        <div class="tabs">
            <div id="tabIndicator" class="tabIndicator" aria-hidden="true"></div>
            <button class="tabBtn active" id="tabHome">Home</button>
            <button class="tabBtn" id="tabMovies">Movies</button>
            <button class="tabBtn" id="tabSeries">Series</button>
            <button class="tabBtn" id="tabAnime">Anime</button>
            <button class="tabBtn" id="tabMyList">My List</button>
            <button class="tabBtn" id="tabTV" style="display: none;">TV</button>
        </div>

        <div class="search collapsed" id="searchWrap" aria-hidden="true">
            <input id="searchInput" placeholder="Search titlesâ€¦" />
            <button id="searchBtn" class="btn" style="margin-left:8px;">Search</button>
        </div>

        <!-- Search results container: appears directly under the search bar when active -->
        <div id="searchResultsContainer" style="display:none;">
            <!-- populated dynamically -->
        </div>

        <div class="topbarActions">
            <button class="btn iconBtn" id="searchToggleBtn" title="Search" aria-label="Search">
                <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M10 2a8 8 0 105.293 14.293l4.707 4.707 1.414-1.414-4.707-4.707A8 8 0 0010 2zm0 2a6 6 0 110 12 6 6 0 010-12z"/></svg>
            </button>
        </div>
    </div>

    <div id="status">Loadingâ€¦</div>

    <!-- FULLSCREEN PLAYER OVERLAY -->
    <div class="playerOverlay" id="playerOverlay" aria-hidden="true">
        <!-- MPV renders into this rectangle (Electron child window positioned here) -->
        <div class="playerVideoHost" id="playerVideoHost"></div>

        <div class="playerTopBar">
            <button class="btn" id="playerBackBtn" title="Back">â†</button>
            <div class="playerTitle" id="playerTitle">Nothing playing</div>
            <button class="btn" id="playerFsBtn" title="Exit fullscreen">â¤¢</button>
        </div>

        <div class="playerBottomBar">
            <div class="playerProgressRow">
                <div class="playerTime" id="playerTimeCur">00:00</div>
                <input class="playerProgress" id="playerProgress" type="range" min="0" max="1000" step="1" value="0" />
                <div class="playerTime" id="playerTimeDur">00:00</div>
            </div>
            <div class="playerControlsRow">
                <button class="btn" id="playerPlayPauseBtn" title="Play/Pause">Play/Pause</button>
                <button class="btn" id="playerRewindBtn" title="Seek -10s">-10s</button>
                <button class="btn" id="playerForwardBtn" title="Seek +10s">+10s</button>

                <div class="playerVolume" title="Volume">
                    <span style="color:rgba(255,255,255,0.7); font-size:12px; font-weight:900;">Vol</span>
                    <input id="playerVolumeRange" type="range" min="0" max="100" step="1" value="100" />
                </div>

                <div class="spacer"></div>
                <button class="btn" id="playerStopBtn" title="Stop">Stop</button>
            </div>
        </div>
    </div>

    <!-- HOME -->
    <div id="homeWrap">
        <!-- Hero banner removed per user preference -->

        <div class="section" id="rowsContainer"></div>
    </div>

    <!-- TV CHANNELS -->
    <div id="tvWrap" style="display: none; padding: 0; position: fixed; top: 0; left: 0; right: 0; bottom: 0; overflow: hidden; z-index: 5;">
        <div style="display: flex; height: 100%; flex-direction: row; width: 100%; padding-top: 60px;" id="tvMainContainer">
        <!-- Main Categories (Left) -->
        <div id="tvMainCategories" style="
            width: 180px;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border-right: 1px solid rgba(59, 130, 246, 0.2);
            padding: 15px 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.3s ease;
        ">
            <div id="tvMainCategoriesList" style="overflow-y: auto; flex: 1; display: flex; flex-direction: column; justify-content: center; gap: 8px;"></div>
        </div>
        
        <!-- Subfolders (Middle) -->
        <div id="tvSubfolders" style="
            width: 220px;
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            border-right: 1px solid rgba(59, 130, 246, 0.2);
            padding: 15px 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        ">
            <div id="tvSubfoldersList" style="
                overflow-y: auto;
                flex: 1;
                display: flex;
                flex-direction: column;
                justify-content: flex-start;
                gap: 8px;
                padding: 12px 10px;
            "></div>
        </div>
        
        <!-- Channels (Right) -->
        <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
            <!-- Player and Info Row -->
            <div style="display: flex; gap: 15px; padding: 20px; padding-bottom: 10px; flex-shrink: 0;">
                <!-- Player Container (Left, Smaller) -->
                <div id="tvPlayerContainer" style="
                    width: 350px;
                    height: 200px;
                    background: #000;
                    border: 2px solid rgba(59, 130, 246, 0.3);
                    border-radius: 8px;
                    display: flex;
                    flex-direction: column;
                    position: relative;
                    overflow: hidden;
                    flex-shrink: 0;
                ">
                    <div id="tvPlayerContent" style="
                        width: 100%;
                        height: 100%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 10px;
                        background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(30, 41, 59, 0.8));
                        cursor: pointer;
                    ">
                        <div style="color: #94a3b8; font-size: 14px;">Select a channel to play</div>
                    </div>
                    <div id="tvFullscreenBadge" style="
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: rgba(59, 130, 246, 0.8);
                        color: #e2e8f0;
                        padding: 6px 12px;
                        border-radius: 4px;
                        font-size: 11px;
                        display: none;
                        cursor: pointer;
                        z-index: 10;
                    ">Click to Fullscreen</div>
                    <div id="tvPlayPauseBtn" style="
                        position: absolute;
                        bottom: 10px;
                        right: 10px;
                        background: rgba(59, 130, 246, 0.9);
                        color: #e2e8f0;
                        padding: 8px 16px;
                        border-radius: 4px;
                        font-size: 13px;
                        font-weight: 600;
                        display: none;
                        cursor: pointer;
                        z-index: 10;
                        transition: all 0.2s ease;
                    ">â¸ Pause</div>
                </div>
                
                <!-- Channel List Header + EPG preview (right) -->
                <div style="flex: 1; display: flex; flex-direction: column; gap: 8px; padding-left: 20px; min-width: 0;">
                    <div style="display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap;">
                        <h2 id="tvCategoryTitle" style="margin: 0; color: #e2e8f0; font-size: 18px;">All Channels</h2>
                        <div id="tvChannelCount" style="font-size: 12px; color: #94a3b8;"></div>
                    </div>
                    <div id="tvEpgPanel" style="
                        background: rgba(15, 23, 42, 0.7);
                        border: 1px solid rgba(59, 130, 246, 0.3);
                        border-radius: 8px;
                        padding: 10px 12px;
                        color: #e2e8f0;
                        min-height: 64px;
                        display: flex;
                        flex-direction: column;
                        gap: 6px;
                        max-width: 420px;
                    ">
                        <div style="font-size: 12px; color: #94a3b8;">EPG</div>
                        <div style="font-size: 13px; color: #cbd5e1;">Select a channel to load guide</div>
                    </div>
                </div>
            </div>
            
            <!-- Channels Grid (EPG Style) -->
            <div id="tvChannelsContainer" style="
                flex: 1;
                overflow-y: auto;
                padding: 0 20px 20px 20px;
            "></div>
        </div>
        <div id="tvCacheStatus" style="position: absolute; bottom: 5px; right: 5px; font-size: 11px; color: #64748b; text-align: right; pointer-events: none;"></div>
        </div>
    </div>

    <!-- SETTINGS -->
    <div class="settingsWrap" id="settingsWrap">
        <div class="settingsSubtabs">
            <button class="settingsSubtabBtn active" id="settingsTabGeneral">General</button>
            <button class="settingsSubtabBtn" id="settingsTabAddons">Addons</button>
        </div>

        <!-- General Settings Panel -->
        <div class="settingsPanel active" id="settingsPanelGeneral">
            <div class="settingsCard" id="backendCard">
                <div class="settingsTitle">Backend</div>
                <div class="settingsSub">Set the backend base URL (example: http://192.168.x.x:3000). Required on Android/TV app builds.</div>

                <div class="settingsFormRow">
                    <div class="settingsInputRow">
                        <input id="backendUrlInput" placeholder="http://192.168.178.44:3000"
                               style="flex:1; min-width:260px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 999px; padding: 10px 12px; color: var(--text); outline: none;" />
                    </div>
                    <div class="settingsActionsRow dpadRow">
                        <button class="btn btnPrimary" id="saveBackendUrlBtn">Save & Reload</button>
                        <button class="btn" id="clearBackendUrlBtn">Reset</button>
                    </div>
                </div>

                <div id="backendUrlHint" style="margin-top:8px; color:rgba(255,255,255,0.55); font-size:12px;"></div>
            </div>

            <div class="settingsCard" id="accountCard">
                <div class="settingsTitle">Account</div>
                <div class="settingsSub">Log in to sync Continue Watching, My List, and settings.</div>

                <div id="accountLoggedOut">
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                        <input id="authUsername" placeholder="Username" autocomplete="username"
                               style="flex:1; min-width:180px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 10px; padding: 10px 12px; color: var(--text); outline: none;" />
                        <input id="authPassword" placeholder="Password" type="password" autocomplete="current-password"
                               style="flex:1; min-width:180px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 10px; padding: 10px 12px; color: var(--text); outline: none;" />
                        <button class="btn btnPrimary" id="loginBtn">Login</button>
                        <button class="btn" id="registerBtn">Register</button>
                    </div>
                    <div style="margin-top:8px; color:rgba(255,255,255,0.55); font-size:12px;">User data is stored locally on this machine (backend JSON files).</div>
                </div>

                <div id="accountLoggedIn" style="display:none;">
                    <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                        <div style="color:rgba(255,255,255,0.8);">Logged in as <span id="accountUsername" style="font-weight:900;"></span></div>
                        <div style="flex:1;"></div>
                        <button class="btn" id="logoutBtn">Logout</button>
                    </div>
                </div>
            </div>

            <div class="settingsCard" id="streamLimitCard">
                <div class="settingsTitle">Streaming</div>
                <div class="settingsSub">Limit stream results to reduce provider/API usage.</div>


                <div class="settingsFormRow">
                    <div class="settingsToggleRow dpadRow">
                        <input type="checkbox" id="limitStreamsToggle" />
                        <label for="limitStreamsToggle" style="font-weight:900;">Limit stream results</label>
                    </div>

                    <label style="display:flex; align-items:center; gap:8px;">
                        <span style="color:rgba(255,255,255,0.7); font-size:13px;">Max</span>
                        <input id="limitStreamsValue" type="number" min="1" max="200" step="1"
                               style="width:90px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.10); border-radius: 10px; padding: 8px 10px; color: var(--text); outline: none;" />
                        <span style="color:rgba(255,255,255,0.55); font-size:12px;">(1â€“200)</span>
                    </label>

                    <div style="flex:1;"></div>
                    <div class="settingsActionsRow dpadRow">
                        <button class="btn btnPrimary" id="saveStreamLimitBtn">Save</button>
                    </div>
                </div>
            </div>

            <div class="settingsCard" id="catalogsCard">
                <div class="settingsTitle">Catalogs Order</div>
                <div class="settingsSub">Drag to reorder enabled addons that provide catalogs. The order affects homepage rows.</div>

                <div id="catalogOrderList" class="catalogOrderList">Loadingâ€¦</div>

                <div class="settingsActionsRow dpadRow" style="justify-content:flex-end; margin-top:8px;">
                    <button class="btn btnPrimary" id="saveCatalogOrderBtn">Save order</button>
                    <button class="btn" id="resetCatalogOrderBtn">Reset</button>
                </div>
            </div>
        </div>

        <!-- Addons Settings Panel -->
        <div class="settingsPanel" id="settingsPanelAddons">
            <div class="settingsCard">
                <div class="settingsTitle">Install Addon</div>
                <div class="settingsSub">Install remote addon URLs (must expose manifest.json + catalogs + catalog + streams).</div>

                <div class="installRow">
                    <input id="installUrl" placeholder="https://example.com/my-addon" />
                    <button class="btn btnPrimary" id="installBtn">Install</button>
                </div>
            </div>

            <div class="settingsCard">
                <div class="settingsTitle">IPTV Configuration</div>
                <div class="settingsSub">Add m3u playlists to watch live TV channels.</div>
                
                <div class="settingsFormRow" style="margin-bottom:12px;">
                    <div class="settingsInputRow">
                        <input type="text" id="iptvM3uInput" placeholder="Enter m3u URL..." style="flex: 1; padding: 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); color: white;">
                    </div>
                    <div class="settingsActionsRow dpadRow">
                        <button class="btn btnPrimary" id="iptvLoadBtn">Load</button>
                    </div>
                </div>

                <div class="settingsFormRow" style="margin-bottom:12px;">
                    <div class="settingsInputRow">
                        <input type="text" id="iptvEpgInput" placeholder="Enter EPG URL (XMLTV)..." style="flex: 1; padding: 10px; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); color: white;">
                    </div>
                    <div class="settingsActionsRow dpadRow">
                        <button class="btn btnPrimary" id="iptvSaveEpgBtn">Save</button>
                    </div>
                </div>
                
                <div class="settingsToggleRow dpadRow" style="margin-bottom:12px;">
                    <input type="checkbox" id="iptvToggle" />
                    <label for="iptvToggle">Enable IPTV (adds TV menu)</label>
                    <span id="iptvStatus" style="color: rgba(255,255,255,0.6); font-size: 12px;">Disabled</span>
                </div>
                
                <div id="iptvChannelCount" style="color: rgba(255,255,255,0.6); font-size: 12px;"></div>
                <button class="btn" id="iptvClearCacheBtn" style="margin-top: 8px; font-size: 12px; padding: 6px 12px;">Clear TV Cache</button>
            </div>

            <div class="settingsCard">
                <div class="settingsTitle">IMDb Scores</div>
                <div class="settingsSub">Show IMDb ratings on title information.</div>
                
                <div class="settingsToggleRow dpadRow" style="margin-bottom:12px;">
                    <input type="checkbox" id="imdbScoresToggle" />
                    <label for="imdbScoresToggle">Enable IMDb scores addon</label>
                    <span id="imdbScoresStatus" style="color: rgba(255,255,255,0.6); font-size: 12px;">Disabled</span>
                </div>
                
                <div style="margin-top: 10px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <label style="color: #cbd5e1; font-size: 12px;">OMDB API Key (free at omdbapi.com)</label>
                        <span id="omdbKeyStatus" style="font-size: 11px; color: rgba(255,255,255,0.5);"></span>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <input type="password" id="omdbApiKeyInput" placeholder="Paste your free OMDB API key..." style="flex: 1; padding: 10px; border-radius: 6px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); color: white; box-sizing: border-box;">
                        <button id="saveOmdbKeyBtn" class="btn" style="font-size: 12px; padding: 8px 16px; white-space: nowrap; transition: all 0.3s ease;">Save</button>
                    </div>
                </div>
            </div>

            <div class="settingsCard">
                <div class="settingsTitle">Installed Addons</div>
                <div class="settingsSub">Manage your installed addons.</div>

                <div id="addonsList"></div>
            </div>
        </div>
    </div>

    <!-- Details / Stream Modal -->
    <div id="modalBackdrop" class="modalBackdrop">
        <div class="modal" id="detailsModal" role="dialog" aria-modal="true">
            <div class="modalGrid">
                <img id="modalPoster" class="modalPoster" alt="Poster" />
                <div class="modalBody">
                    <div class="modalHeader">
                        <h2 id="modalTitle" class="modalTitle">Title</h2>
                        <div id="modalMeta" class="modalMeta">
                            <div id="metaText" class="metaInfo"></div>
                            <div id="imdbBadgeContainer"></div>
                        </div>
                    </div>

                    <!-- TV-style movie layout (reference: Chaos Walking style) -->
                    <div id="movieHero" class="movieHero" aria-hidden="true">
                        <div class="movieLeft">
                            <div id="movieOverview" class="movieOverview"></div>
                            <div id="movieActions" class="movieActions" aria-label="Actions"></div>
                        </div>
                        <div id="movieArt" class="movieArt" aria-hidden="true"></div>
                    </div>
                    <button id="trailerBtn" class="btn" style="margin-top: 8px; background: rgba(220, 38, 38, 0.9); border-color: rgba(220, 38, 38, 0.6); display: none;">
                        â–¶ Watch Trailer
                    </button>
                    <div id="modalDesc" class="detailsDescription" style="display:none;"></div>
                    <div id="modalEpisodesWrap" class="modalEpisodesWrap" style="display:none;"></div>
                    <div id="streamHeader" style="margin-top:8px; font-weight:900;">Choose a stream</div>
                    <div id="streamList" class="streamList"></div>
                </div>
                <div id="modalSide" class="modalSide"></div>
            </div>
            <div class="modalFooter">
                <div class="modalFooterLeft">
                    <button class="btn" id="footerTrailerBtn" style="display:none;">Trailer</button>
                </div>
                <div class="modalFooterRight">
                <button class="btn" id="libraryToggleBtn" style="display:none;">Add to List</button>
                <button class="btn" id="closeModalBtn">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script src="./platform/media-api.js"></script>
    <script src="./platform/native-player-web.js"></script>
    <script>
        // ---------- Elements ----------
        const statusEl = document.getElementById("status");
        const bootSplashEl = document.getElementById('bootSplash');
        const bootSplashTextEl = document.getElementById('bootSplashText');

        // Backend base URL
        // - When running via Vite on another device: defaults to http(s)://<host>:3000
        // - Override with ?api=http://host:3000 or localStorage key "apiBaseUrl"
        const API_BASE_LS_KEY = 'apiBaseUrl';
        function normalizeBaseUrl(u) {
            u = String(u || '').trim();
            if (!u) return '';
            return u.replace(/\/+$/, '');
        }
        function guessDefaultApiBase() {
            // If UI is served from backend itself, just use origin
            if (String(location.port || '') === '3000') return location.origin;
            // App shells (Capacitor / file / custom schemes): we cannot infer LAN backend host.
            // On Android, Capacitor often serves the app from http://localhost, which is NOT your PC.
            if (!/^https?:$/.test(String(location.protocol || ''))) return '';
            if (String(location.hostname || '').toLowerCase() === 'localhost' && isCapacitorRuntime()) return '';
            // Vite dev server / preview: same host, backend port 3000
            return `${location.protocol}//${location.hostname}:3000`;
        }
        const FALLBACK_PUBLIC_API_BASE = 'https://cds-estimate-foto-pump.trycloudflare.com';
        let API_BASE = normalizeBaseUrl(
            new URLSearchParams(location.search).get('api') ||
            localStorage.getItem(API_BASE_LS_KEY) ||
            guessDefaultApiBase() ||
            FALLBACK_PUBLIC_API_BASE
        );

        const tabHomeBtn = document.getElementById("tabHome");
        const tabMoviesBtn = document.getElementById("tabMovies");
        const tabSeriesBtn = document.getElementById("tabSeries");
        const tabAnimeBtn = document.getElementById("tabAnime");
        const tabTVBtn = document.getElementById("tabTV");
        const tabMyListBtn = document.getElementById("tabMyList");
        const tabSettingsBtn = document.getElementById("tabSettings");
        const tabsWrapEl = document.querySelector('.tabs');
        const tabIndicatorEl = document.getElementById('tabIndicator');
        const homeWrap = document.getElementById("homeWrap");
        const settingsWrap = document.getElementById("settingsWrap");
        const tvWrap = document.getElementById("tvWrap");
        const searchWrap = document.getElementById("searchWrap");

        function pulseViewFade() {
            try {
                if (!homeWrap || homeWrap.style.display === 'none') return;
                homeWrap.classList.remove('uiFadePulse');
                // Force reflow so re-adding restarts the animation
                void homeWrap.offsetWidth;
                homeWrap.classList.add('uiFadePulse');
            } catch { }
        }

        function __nowMs() {
            try { return (performance && typeof performance.now === 'function') ? performance.now() : Date.now(); } catch { }
            return Date.now();
        }
        function __nextFrame() {
            return new Promise((resolve) => {
                try { requestAnimationFrame(() => resolve()); }
                catch { setTimeout(resolve, 0); }
            });
        }
        async function __yieldFrames(n = 1) {
            const count = Math.max(1, Number(n) || 1);
            for (let i = 0; i < count; i++) await __nextFrame();
        }
        function __shouldChunkUiWork() {
            try {
                if (window.__uiTransitioning) return true;
                return document.documentElement.classList.contains('tv-compact');
            } catch { }
            return false;
        }
        async function __yieldIfOverBudget(lastYieldMs, budgetMs = 12) {
            if (!__shouldChunkUiWork()) return lastYieldMs;
            const now = __nowMs();
            if ((now - (lastYieldMs || 0)) > budgetMs) {
                await __nextFrame();
                return __nowMs();
            }
            return lastYieldMs;
        }

        try {
            homeWrap?.addEventListener('animationend', (e) => {
                try {
                    if (e.animationName === 'uiFadePulse') homeWrap.classList.remove('uiFadePulse');
                } catch { }
            });
        } catch { }

        function updateTabIndicator(targetBtn) {
            try {
                if (!tabsWrapEl || !tabIndicatorEl) return;
                const btn = targetBtn || tabsWrapEl.querySelector('.tabBtn.active');
                if (!btn) {
                    tabIndicatorEl.style.width = '0px';
                    return;
                }
                const wrapRect = tabsWrapEl.getBoundingClientRect();
                const btnRect = btn.getBoundingClientRect();
                const left = Math.max(0, btnRect.left - wrapRect.left);
                const width = Math.max(0, btnRect.width);
                const height = Math.max(0, btnRect.height);
                tabIndicatorEl.style.left = `${left}px`;
                tabIndicatorEl.style.width = `${width}px`;
                tabIndicatorEl.style.height = `${height}px`;
            } catch { }
        }

        window.addEventListener('resize', () => {
            try { requestAnimationFrame(() => updateTabIndicator()); } catch { }
        });

        const rowsContainer = document.getElementById("rowsContainer");
        const addonsList = document.getElementById("addonsList");

        const heroPosterEl = document.getElementById("heroPoster");
        const heroTitleEl = document.getElementById("heroTitle");
        const heroMetaEl = document.getElementById("heroMeta");
        const heroOpenBtn = document.getElementById("heroOpenBtn");
        const heroPlayBtn = document.getElementById("heroPlayBtn");

        const searchInput = document.getElementById("searchInput");
        const refreshBtn = document.getElementById("refreshBtn");
        const searchToggleBtn = document.getElementById('searchToggleBtn');

        // Brand (logo) dropdown menu
        const brandMenuBtn = document.getElementById('brandMenuBtn');
        const brandMenuDropdown = document.getElementById('brandMenuDropdown');
        const brandMenuRefreshBtn = document.getElementById('brandMenuRefresh');
        const brandMenuSettingsBtn = document.getElementById('brandMenuSettings');

        // Fullscreen player overlay elements
        const playerOverlay = document.getElementById('playerOverlay');
        const playerVideoHost = document.getElementById('playerVideoHost');
        const playerBackBtn = document.getElementById('playerBackBtn');
        const playerTitleEl = document.getElementById('playerTitle');
        const playerFsBtn = document.getElementById('playerFsBtn');

        const playerTimeCurEl = document.getElementById('playerTimeCur');
        const playerTimeDurEl = document.getElementById('playerTimeDur');
        const playerProgressEl = document.getElementById('playerProgress');

        const playerPlayPauseBtn = document.getElementById('playerPlayPauseBtn');
        const playerRewindBtn = document.getElementById('playerRewindBtn');
        const playerForwardBtn = document.getElementById('playerForwardBtn');
        const playerVolumeRange = document.getElementById('playerVolumeRange');
        const playerStopBtn = document.getElementById('playerStopBtn');

        let playerIsActive = false;
        let playerScrubbing = false;
        let playerPollTimer = null;

        // MPV progress tracking for TV playback (resume + continue watching)
        let mpvProgressTimer = null;
        let mpvProgressCtx = null;
        let mpvProgressDirty = false; // set true when we saved CW so UI can refresh on stop
        let playerAppFullscreen = false;

        const installUrl = document.getElementById("installUrl");
        const installBtn = document.getElementById("installBtn");

        // Account UI
        const accountLoggedOutEl = document.getElementById('accountLoggedOut');
        const accountLoggedInEl = document.getElementById('accountLoggedIn');
        const accountUsernameEl = document.getElementById('accountUsername');
        const authUsernameEl = document.getElementById('authUsername');
        const authPasswordEl = document.getElementById('authPassword');
        const loginBtn = document.getElementById('loginBtn');
        const registerBtn = document.getElementById('registerBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const imdbScoresToggle = document.getElementById('imdbScoresToggle');
        const imdbScoresStatus = document.getElementById('imdbScoresStatus');
        const omdbApiKeyInput = document.getElementById('omdbApiKeyInput');
        const saveOmdbKeyBtn = document.getElementById('saveOmdbKeyBtn');

        // Backend URL (Settings)
        const backendUrlInput = document.getElementById('backendUrlInput');
        const saveBackendUrlBtn = document.getElementById('saveBackendUrlBtn');
        const clearBackendUrlBtn = document.getElementById('clearBackendUrlBtn');
        const backendUrlHint = document.getElementById('backendUrlHint');

        function updateBackendUrlHint() {
            if (!backendUrlHint) return;
            const active = normalizeBaseUrl(API_BASE || '');
            const saved = normalizeBaseUrl(localStorage.getItem(API_BASE_LS_KEY) || '');
            backendUrlHint.textContent = `Active: ${active || '(not set)'}${saved && saved !== active ? ` â€¢ Saved: ${saved}` : ''}`;
        }

        if (backendUrlInput) {
            const saved = normalizeBaseUrl(localStorage.getItem(API_BASE_LS_KEY) || '');
            backendUrlInput.value = saved || normalizeBaseUrl(API_BASE || '');
        }
        updateBackendUrlHint();

        function saveBackendUrlFromSettings({ reload = false } = {}) {
            const nextRaw = backendUrlInput ? backendUrlInput.value : '';
            const next = normalizeBaseUrl(nextRaw);
            if (!next) {
                localStorage.removeItem(API_BASE_LS_KEY);
                API_BASE = '';
                updateBackendUrlHint();
                setStatus('Backend URL cleared.');
                if (reload) {
                    try { location.reload(); } catch { }
                }
                return true;
            }
            if (!/^https?:\/\//i.test(next)) {
                setStatus('Backend URL must start with http:// or https://', true);
                return false;
            }
            localStorage.setItem(API_BASE_LS_KEY, next);
            API_BASE = next;
            updateBackendUrlHint();
            if (reload) {
                setStatus('Backend URL saved. Reloadingâ€¦');
                try { location.reload(); } catch { }
            } else {
                setStatus('Backend URL saved.');
            }
            return true;
        }

        saveBackendUrlBtn?.addEventListener('click', () => saveBackendUrlFromSettings({ reload: true }));
        backendUrlInput?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveBackendUrlBtn?.click();
            }
        });
        clearBackendUrlBtn?.addEventListener('click', () => {
            try { if (backendUrlInput) backendUrlInput.value = ''; } catch { }
            saveBackendUrlFromSettings({ reload: true });
        });

        const modalBackdrop = document.getElementById("modalBackdrop");
        const closeModalBtn = document.getElementById("closeModalBtn");
        const modalEl = document.getElementById("detailsModal");
        const modalPosterEl = document.getElementById("modalPoster");
        const modalTitleEl = document.getElementById("modalTitle");
        const modalMetaEl = document.getElementById("modalMeta");
        const metaTextEl = document.getElementById("metaText");
        const imdbBadgeContainerEl = document.getElementById("imdbBadgeContainer");
        const modalDescEl = document.getElementById("modalDesc");
        const streamListEl = document.getElementById("streamList");
        const modalSideEl = document.getElementById("modalSide");
        const modalEpisodesWrapEl = document.getElementById("modalEpisodesWrap");
        const libraryToggleBtn = document.getElementById('libraryToggleBtn');
        const trailerBtn = document.getElementById('trailerBtn');

        // ---------- State ----------
        let catalogs = [];
        let catalogItemsCache = new Map(); // key: `${addonUid}:${type}:${id}:${search}`
        let __catalogsCache = { at: 0, value: null };
        let __catalogsInFlight = null;
        const CATALOGS_CACHE_TTL_MS = 1000 * 60 * 5;
        let heroItem = null;
        let searchState = { q: '', page: 1, total_pages: 1 };
        const LAST_TOP_TAB_LS_KEY = 'folder:lastTopTab';
        function getPersistedTopTab() {
            try {
                const t = String(localStorage.getItem(LAST_TOP_TAB_LS_KEY) || '').trim();
                return t === 'tv' ? 'tv' : 'home';
            } catch { }
            return 'home';
        }
        function persistTopTab(tab) {
            try {
                const t = String(tab || '').trim();
                if (t === 'tv') localStorage.setItem(LAST_TOP_TAB_LS_KEY, 'tv');
                else localStorage.removeItem(LAST_TOP_TAB_LS_KEY);
            } catch { }
        }

        let currentTopTab = getPersistedTopTab(); // home | movies | series | anime | mylist | settings

        const tabUiState = Object.create(null);
        function ensureTabUiState(tab) {
            const t = String(tab || 'home');
            if (!tabUiState[t]) tabUiState[t] = { scrollY: 0, focusedTileKey: null };
            return tabUiState[t];
        }

        // Keep rendered DOM per tab to avoid "webpage reload" feel when switching menus.
        // This preserves <img> elements so posters stay decoded in memory.
        let __domCacheHostEl = null;
        const __viewDomCache = Object.create(null); // key -> { rowsEl, searchHtml, searchDisplay, searchOpen }

        function ensureDomCacheHost() {
            try {
                if (__domCacheHostEl) return __domCacheHostEl;
                const el = document.createElement('div');
                el.id = 'domCacheHost';
                el.style.display = 'none';
                document.body.appendChild(el);
                __domCacheHostEl = el;
                return el;
            } catch { }
            return null;
        }

        function getTabDomCacheKey(tab) {
            const t = String(tab || 'home');
            if (t === 'settings' || t === 'tv') return null;
            // Keep caching simple and predictable: only cache when not searching.
            const q = (searchInput?.value || '').trim();
            if (q) return null;
            return t;
        }

        function ensureDomCacheEntry(key) {
            if (!key) return null;
            if (__viewDomCache[key]) return __viewDomCache[key];
            const host = ensureDomCacheHost();
            if (!host) return null;
            const rowsEl = document.createElement('div');
            rowsEl.dataset.cacheKey = key;
            host.appendChild(rowsEl);
            __viewDomCache[key] = { rowsEl, searchHtml: '', searchDisplay: 'none', searchOpen: false };
            return __viewDomCache[key];
        }

        function cacheActiveViewDom(tab) {
            try {
                const key = getTabDomCacheKey(tab);
                if (!key) return;
                const entry = ensureDomCacheEntry(key);
                if (!entry || !entry.rowsEl) return;

                // Move rendered rows to cache container
                while (rowsContainer.firstChild) entry.rowsEl.appendChild(rowsContainer.firstChild);

                // Cache search container state too (even if usually hidden)
                const src = document.getElementById('searchResultsContainer');
                if (src) {
                    entry.searchHtml = src.innerHTML;
                    entry.searchDisplay = src.style.display;
                    entry.searchOpen = src.classList.contains('open');
                    src.classList.remove('open');
                    src.style.display = 'none';
                    src.innerHTML = '';
                }
            } catch { }
        }

        function restoreViewDom(tab) {
            try {
                const key = getTabDomCacheKey(tab);
                if (!key) return false;
                const entry = __viewDomCache[key];
                if (!entry || !entry.rowsEl) return false;
                if (!entry.rowsEl.firstChild) return false;

                rowsContainer.innerHTML = '';
                while (entry.rowsEl.firstChild) rowsContainer.appendChild(entry.rowsEl.firstChild);

                const src = document.getElementById('searchResultsContainer');
                if (src) {
                    src.innerHTML = entry.searchHtml || '';
                    src.style.display = entry.searchDisplay || 'none';
                    src.classList.toggle('open', !!entry.searchOpen);
                }
                return true;
            } catch { }
            return false;
        }

        function getFocusedTileKey() {
            try {
                const el = document.activeElement;
                if (!el) return null;
                const tile = el.classList?.contains('tile') ? el : el.closest?.('.tile');
                if (!tile) return null;
                return tile.dataset?.tileKey || null;
            } catch { }
            return null;
        }

        function saveTabState(tab) {
            try {
                const t = String(tab || currentTopTab || 'home');
                const s = ensureTabUiState(t);
                s.scrollY = Number(window.scrollY || 0);
                const key = getFocusedTileKey();
                if (key) s.focusedTileKey = key;
            } catch { }
        }

        function restoreTabState(tab) {
            try {
                const t = String(tab || currentTopTab || 'home');
                const s = ensureTabUiState(t);
                requestAnimationFrame(() => {
                    try { window.scrollTo(0, Number(s.scrollY || 0)); } catch { }
                    if (s.focusedTileKey) {
                        const el = rowsContainer.querySelector(`.tile[data-tile-key="${CSS.escape(s.focusedTileKey)}"]`);
                        if (el) {
                            try { el.focus({ preventScroll: true }); } catch { try { el.focus(); } catch { } }
                            try { el.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch { }
                        }
                    }
                });
            } catch { }
        }

        function clearHomeCaches() {
            __catalogsCache = { at: 0, value: null };
            __catalogsInFlight = null;
            catalogItemsCache = new Map();
        }

        function normalizeType(v) {
            return String(v || '').trim().toLowerCase();
        }

        function itemMatchesTab(item, tab) {
            const t = normalizeType(item?.type);
            const idStr = String(item?.id || '');
            const source = normalizeType(item?.source);
            const isAnime = t === 'anime' || source === 'anilist' || idStr.startsWith('anilist:');
            const isSeries = t === 'series' || t === 'tv';
            const isMovie = t === 'movie';

            if (tab === 'movies') return isMovie;
            if (tab === 'series') return isSeries;
            if (tab === 'anime') return isAnime;
            // home/new: allow all
            return true;
        }

        function catalogMatchesTab(cat, tab) {
            const ct = normalizeType(cat?.type);
            // IPTV channels are intentionally handled in the dedicated TV tab UI.
            // Do not include IPTV catalogs in the home/movies/series/anime row system
            // (they can be huge and will stall boot and rendering).
            if (ct === 'iptv') return false;
            if (!ct || ct === 'mixed' || ct === 'all') return true;
            if (tab === 'movies') return ct === 'movie' || ct === 'movies';
            if (tab === 'series') return ct === 'series' || ct === 'tv';
            if (tab === 'anime') return ct === 'anime';
            // home/new: show everything
            return true;
        }

        function getItemDateMs(item) {
            const tryParse = (v) => {
                if (!v) return null;
                if (typeof v === 'number' && Number.isFinite(v)) {
                    // If it's a year like 2024, approximate Jan 1
                    if (v >= 1900 && v <= 2100) return new Date(`${v}-01-01`).getTime();
                    return v;
                }
                const s = String(v);
                const m = s.match(/^\d{4}-\d{2}-\d{2}/);
                if (m) {
                    const d = new Date(m[0]);
                    return Number.isNaN(d.getTime()) ? null : d.getTime();
                }
                if (/^\d{4}$/.test(s)) {
                    const d = new Date(`${s}-01-01`);
                    return Number.isNaN(d.getTime()) ? null : d.getTime();
                }
                const d = new Date(s);
                return Number.isNaN(d.getTime()) ? null : d.getTime();
            };

            return (
                tryParse(item?.addedAt) ??
                tryParse(item?.date) ??
                tryParse(item?.release_date) ??
                tryParse(item?.first_air_date) ??
                tryParse(item?.year) ??
                null
            );
        }

        function setStatus(text, isError = false) {
            statusEl.textContent = text;
            statusEl.className = isError ? "error" : "";
            try {
                const t = String(text || '').trim();
                statusEl.style.display = t ? 'block' : 'none';
            } catch { }
        }

        function showBootSplash(text = 'Startingâ€¦') {
            try {
                if (!bootSplashEl) return;
                if (bootSplashTextEl) bootSplashTextEl.textContent = String(text || 'Startingâ€¦');
                bootSplashEl.style.display = 'flex';
                bootSplashEl.setAttribute('aria-hidden', 'false');
            } catch { }
        }

        function hideBootSplash() {
            try {
                if (!bootSplashEl) return;
                bootSplashEl.style.display = 'none';
                bootSplashEl.setAttribute('aria-hidden', 'true');
            } catch { }
        }

        // ---------- Backend URL setup (for Android TV / Capacitor) ----------
        function isCapacitorRuntime() {
            try {
                // Capacitor injects a global and also adds UA hints.
                if (window.Capacitor) return true;
                const ua = String(navigator.userAgent || '');
                if (/Capacitor/i.test(ua)) return true;
            } catch { }
            return false;
        }

        function isLocalAppShell() {
            const proto = String(location.protocol || '').toLowerCase();
            return proto === 'capacitor:' || proto === 'file:' || proto === 'ionic:' || isCapacitorRuntime();
        }

        function isAndroidTvUserAgent() {
            try {
                const ua = String(navigator.userAgent || '');
                // Covers many Android TV / Google TV / Fire TV variants.
                return /(Android TV|GoogleTV|AFT|BRAVIA|SmartTV|SMART-TV|TV;)/i.test(ua);
            } catch { }
            return false;
        }

        function shouldUseTvCompactLayout() {
            // Primary: explicit Android TV/Google TV UA markers.
            if (isAndroidTvUserAgent()) return true;

            // Fallback: many Google TV devices report only "Android" in UA.
            // Treat large landscape Android screens as TV.
            try {
                const ua = String(navigator.userAgent || '');
                const isAndroid = /Android/i.test(ua);
                if (!isAndroid) return false;
                const dpr = Math.max(1, Number(window.devicePixelRatio) || 1);
                const w = Math.max(Number(screen.width) || 0, Number(screen.height) || 0) * dpr;
                const h = Math.min(Number(screen.width) || 0, Number(screen.height) || 0) * dpr;
                return w >= 1280 && h >= 720;
            } catch { }

            return false;
        }

        try {
            if (shouldUseTvCompactLayout()) {
                document.documentElement.classList.add('tv-compact');
            }
        } catch { }

        function showBackendSetup(err) {
            try {
                const existing = document.getElementById('backendSetupOverlay');
                if (existing) existing.remove();
            } catch { }

            const overlay = document.createElement('div');
            overlay.id = 'backendSetupOverlay';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                z-index: 3000;
                background: rgba(0,0,0,0.72);
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 18px;
            `;

            const card = document.createElement('div');
            card.style.cssText = `
                width: min(900px, 96vw);
                background: rgba(20,20,24,0.98);
                border: 1px solid rgba(255,255,255,0.10);
                border-radius: 18px;
                box-shadow: 0 30px 90px rgba(0,0,0,0.75);
                padding: 18px;
            `;

            const title = document.createElement('div');
            title.textContent = 'Connect to backend';
            title.style.cssText = 'font-weight:900; font-size:18px; margin-bottom:10px;';

            const info = document.createElement('div');
            info.textContent =
                'This app needs your media backend running on your LAN.\n\n' +
                'Enter the backend base URL (example: http://<your-pc-ip>:3000).';
            info.style.cssText = 'white-space:pre-wrap; color: rgba(255,255,255,0.75); font-size:13px; margin-bottom:12px; line-height:1.5;';

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'http://192.168.x.x:3000';
            input.value = String(localStorage.getItem(API_BASE_LS_KEY) || '').trim();
            input.style.cssText = `
                width: 100%;
                padding: 12px 14px;
                border-radius: 12px;
                border: 1px solid rgba(255,255,255,0.16);
                background: rgba(255,255,255,0.06);
                color: rgba(255,255,255,0.92);
                outline: none;
                font-weight: 700;
                margin-bottom: 12px;
            `;
            input.addEventListener('focus', () => { try { input.scrollIntoView({ block: 'center' }); } catch { } });

            const btnRow = document.createElement('div');
            btnRow.style.cssText = 'display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap;';

            const saveBtn = document.createElement('button');
            saveBtn.className = 'btn btnPrimary';
            saveBtn.textContent = 'Save & Retry';
            saveBtn.tabIndex = 0;

            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.textContent = 'Close';
            cancelBtn.tabIndex = 0;

            const errBox = document.createElement('div');
            errBox.style.cssText = 'margin-top:12px; color: #ff7a7a; font-size:12px; white-space: pre-wrap;';
            errBox.textContent = err ? ('Error: ' + (err?.message || String(err))) : '';

            const applyAndReload = () => {
                const next = normalizeBaseUrl(input.value);
                if (!next || !/^https?:\/\//i.test(next)) {
                    errBox.textContent = 'Please enter a valid URL starting with http:// or https://';
                    return;
                }
                localStorage.setItem(API_BASE_LS_KEY, next);
                API_BASE = next;
                try { location.reload(); } catch { }
            };

            saveBtn.addEventListener('click', applyAndReload);
            saveBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); applyAndReload(); } });
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); applyAndReload(); } });

            cancelBtn.addEventListener('click', () => { try { overlay.remove(); } catch { } });
            cancelBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); cancelBtn.click(); } });

            btnRow.appendChild(cancelBtn);
            btnRow.appendChild(saveBtn);

            card.appendChild(title);
            card.appendChild(info);
            card.appendChild(input);
            card.appendChild(btnRow);
            card.appendChild(errBox);
            overlay.appendChild(card);
            document.body.appendChild(overlay);

            // Focus input first so Android TV shows the on-screen keyboard.
            setTimeout(() => {
                try { input.focus(); } catch { }
            }, 50);
        }

        // Preserve normal vertical page scrolling.
        // Enable horizontal scrolling for catalog rows using:
        // - Shift + mouse wheel, or
        // - Trackpad horizontal scroll (deltaX)
        document.addEventListener('wheel', (e) => {
            try {
                // Never hijack wheel while modal is open
                if (modalBackdrop && modalBackdrop.style.display === 'flex') return;

                const row = e.target && e.target.closest ? e.target.closest('.row') : null;
                if (!row) return;

                const wantsHorizontal = e.shiftKey || Math.abs(e.deltaX) > Math.abs(e.deltaY);
                if (!wantsHorizontal) return;

                let delta = e.shiftKey ? e.deltaY : e.deltaX;
                if (!delta) return;

                if (e.deltaMode === 1) delta *= 24; // lines â†’ px-ish
                if (e.deltaMode === 2) delta *= row.clientWidth; // pages â†’ px

                row.scrollLeft += delta;
                e.preventDefault();
            } catch {
                // ignore
            }
        }, { passive: false });

        // Safety: if modal is closed, ensure overflow isn't stuck on hidden
        window.addEventListener('focus', () => {
            try {
                if (!modalBackdrop || modalBackdrop.style.display !== 'flex') {
                    document.body.style.overflow = '';
                    document.documentElement.style.overflow = '';
                }
            } catch {}
        });

        // ---------- Fullscreen player overlay (deprecated) ----------
        // We now run MPV as its own fullscreen window and show custom controls
        // in a separate transparent Electron overlay window (player.html).
        // The in-page overlay remains but is intentionally inert.
        function getPlayerHostRect() {
            if (!playerVideoHost) return { x: 0, y: 0, width: 1, height: 1 };
            const r = playerVideoHost.getBoundingClientRect();
            // IMPORTANT: this rect is in CONTENT coordinates (what main.js expects)
            return { x: r.left, y: r.top, width: r.width, height: r.height };
        }

        function formatTime(secs) {
            const s = Math.max(0, Math.floor(Number(secs) || 0));
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
            return `${String(m).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
        }

        async function enterPlayerOverlay(titleText) {
            playerIsActive = true;
            if (playerOverlay) {
                playerOverlay.classList.add('isActive');
                playerOverlay.setAttribute('aria-hidden', 'false');
            }
            if (playerTitleEl) playerTitleEl.textContent = titleText || 'Playing';

            // Make the app fullscreen (like the screenshot)
            try {
                playerAppFullscreen = true;
                await window.mediaAPI.app.setFullscreen(true);
            } catch {}

            // Fullscreen transitions can change content bounds asynchronously.
            await new Promise(r => setTimeout(r, 0));
            await syncPlayerSurfaceBounds();
            setTimeout(() => { syncPlayerSurfaceBounds(); }, 120);
            setTimeout(() => { syncPlayerSurfaceBounds(); }, 300);
            startPlayerPolling();
        }

        async function exitPlayerOverlay({ stop } = { stop: true }) {
            try {
                if (stop) await window.mediaAPI.player.stop();
            } catch {}

            stopPlayerPolling();
            playerIsActive = false;
            playerScrubbing = false;
            try {
                playerAppFullscreen = false;
                await window.mediaAPI.app.setFullscreen(false);
            } catch {}

            if (playerOverlay) {
                playerOverlay.classList.remove('isActive');
                playerOverlay.setAttribute('aria-hidden', 'true');
            }
        }

        async function syncPlayerSurfaceBounds() { /* no-op */ }

        async function playInEmbeddedMpv(name, url) {
            if (!url) return;
            setStatus("Starting web playback...");
            
            const playerUrl = 'player.html?url=' + encodeURIComponent(url) + '&title=' + encodeURIComponent(name || '');
            window.location.href = playerUrl;
        }

        // keep MPV surface aligned (no-op)

        async function pollPlayer() {
            if (!playerIsActive) return;
            try {
                const durRes = await window.mediaAPI.player.command('getProperty', 'duration');
                const posRes = await window.mediaAPI.player.command('getProperty', 'time-pos');
                const volRes = await window.mediaAPI.player.command('getProperty', 'volume');
                const pauseRes = await window.mediaAPI.player.command('getProperty', 'pause');

                const duration = Number(durRes?.value || 0);
                const position = Number(posRes?.value || 0);
                const volume = Number(volRes?.value);
                const paused = !!pauseRes?.value;

                if (playerTimeCurEl) playerTimeCurEl.textContent = formatTime(position);
                if (playerTimeDurEl) playerTimeDurEl.textContent = duration > 0 ? formatTime(duration) : '00:00';
                if (!playerScrubbing && playerProgressEl) {
                    const ratio = duration > 0 ? Math.max(0, Math.min(1, position / duration)) : 0;
                    playerProgressEl.value = String(Math.round(ratio * 1000));
                }
                if (playerVolumeRange && Number.isFinite(volume)) {
                    const v = Math.max(0, Math.min(100, Math.round(volume)));
                    playerVolumeRange.value = String(v);
                }

                if (playerPlayPauseBtn) playerPlayPauseBtn.textContent = paused ? 'Play' : 'Pause';
            } catch {
                // ignore polling errors
            }
        }

        function startPlayerPolling() {
            stopPlayerPolling();
            playerPollTimer = setInterval(pollPlayer, 350);
            pollPlayer();
        }

        function stopPlayerPolling() {
            if (playerPollTimer) {
                clearInterval(playerPollTimer);
                playerPollTimer = null;
            }
        }

        function stopMpvProgressTracking() {
            if (mpvProgressTimer) {
                clearInterval(mpvProgressTimer);
                mpvProgressTimer = null;
            }
            const shouldRefresh = mpvProgressDirty;
            mpvProgressDirty = false;
            mpvProgressCtx = null;

            // Refresh home rows so continue-watching progress bars update seamlessly
            if (shouldRefresh) {
                refreshHome({ forceReload: false, clearItemsCache: false }).catch(() => {});
            }
        }

        function startMpvProgressTracking(channel, { enableContinueWatching } = { enableContinueWatching: true }) {
            stopMpvProgressTracking();
            if (!channel || !enableContinueWatching) return;

            mpvProgressCtx = { channel };
            mpvProgressDirty = false;
            mpvProgressTimer = setInterval(async () => {
                try {
                    const posRes = await window.mediaAPI.player.command('getProperty', 'time-pos');
                    const durRes = await window.mediaAPI.player.command('getProperty', 'duration');
                    const pos = Number(posRes?.value || 0);
                    const dur = Number(durRes?.value || 0);
                    if (!Number.isFinite(pos) || !Number.isFinite(dur) || dur <= 0) return;

                    updateContinueWatching(channel, pos, dur);
                    mpvProgressDirty = true;
                } catch (err) {
                    // Stop polling if MPV goes away or errors consistently
                    console.warn('[MPV Progress] polling stopped:', err?.message || err);
                    stopMpvProgressTracking();
                }
            }, 5000);
        }

        if (playerBackBtn) {
            playerBackBtn.addEventListener('click', async () => {
                await exitPlayerOverlay({ stop: true });
            });
        }

        if (playerFsBtn) {
            playerFsBtn.addEventListener('click', async () => {
                try {
                    playerAppFullscreen = !playerAppFullscreen;
                    await window.mediaAPI.app.setFullscreen(playerAppFullscreen);
                    setTimeout(() => { syncPlayerSurfaceBounds(); }, 50);
                } catch {}
            });
        }

        document.addEventListener('keydown', async (e) => {
            if (!playerIsActive) return;
            if (e.key === 'Escape') {
                e.preventDefault();
                await exitPlayerOverlay({ stop: true });
            }
        });

        if (playerStopBtn) {
            playerStopBtn.addEventListener('click', async () => {
                await exitPlayerOverlay({ stop: true });
            });
        }

        if (playerPlayPauseBtn) {
            playerPlayPauseBtn.addEventListener('click', async () => {
                try { await window.mediaAPI.player.command('cyclePause'); } catch { }
            });
        }
        if (playerRewindBtn) {
            playerRewindBtn.addEventListener('click', async () => {
                try { await window.mediaAPI.player.command('seek', -10); } catch { }
            });
        }
        if (playerForwardBtn) {
            playerForwardBtn.addEventListener('click', async () => {
                try { await window.mediaAPI.player.command('seek', 10); } catch { }
            });
        }

        if (playerVolumeRange) {
            playerVolumeRange.addEventListener('input', async () => {
                try { await window.mediaAPI.player.command('setVolume', Number(playerVolumeRange.value || 100)); } catch { }
            });
        }

        if (playerProgressEl) {
            playerProgressEl.addEventListener('pointerdown', () => { playerScrubbing = true; });
            playerProgressEl.addEventListener('pointerup', async () => {
                try {
                    const durRes = await window.mediaAPI.player.command('getProperty', 'duration');
                    const duration = Number(durRes?.value || 0);
                    const ratio = Number(playerProgressEl.value || 0) / 1000;
                    if (duration > 0) {
                        await window.mediaAPI.player.command('seekTo', duration * ratio);
                    }
                } catch {}
                playerScrubbing = false;
            });
            playerProgressEl.addEventListener('input', () => {
                // while scrubbing, update displayed current time based on duration
                if (!playerScrubbing) return;
                try {
                    const ratio = Number(playerProgressEl.value || 0) / 1000;
                    if (playerTimeCurEl && playerTimeDurEl && playerTimeDurEl.textContent) {
                        // best effort without duration; polling will correct
                    }
                } catch {}
            });
        }

        // ---------- Helpers ----------
        function isMagnetLike(url) {
            if (!url) return false;
            const u = url.toLowerCase();
            return u.startsWith("magnet:") || u.includes("xt=urn:btih") || u.includes("infohash");
        }

        // ---------- Backend calls ----------
        const AUTH_TOKEN_LS_KEY = 'authToken';
        let authToken = '';
        let currentUser = null;
        let currentUserSettings = null;

        let currentDetailsCtx = null;

        let libraryCache = null;
        let libraryCacheAt = 0;
        const LIBRARY_CACHE_TTL_MS = 1000 * 20;

        function getAuthToken() {
            if (!authToken) authToken = String(localStorage.getItem(AUTH_TOKEN_LS_KEY) || '').trim();
            return authToken || '';
        }

        function setAuthToken(token) {
            authToken = String(token || '').trim();
            if (authToken) localStorage.setItem(AUTH_TOKEN_LS_KEY, authToken);
            else localStorage.removeItem(AUTH_TOKEN_LS_KEY);
        }

        async function apiFetch(path, opts = {}) {
            const url = path.startsWith('http') ? path : `${API_BASE}${path}`;
            const headers = { ...(opts.headers || {}) };
            const token = getAuthToken();
            if (token) headers['Authorization'] = `Bearer ${token}`;
            return await fetch(url, { ...opts, headers });
        }

        async function apiJson(path, opts = {}) {
            const res = await apiFetch(path, opts);
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data?.error || `HTTP ${res.status} ${res.statusText}`);
            return data;
        }

        function renderAccountUi() {
            const u = currentUser;
            const loggedIn = !!u;
            if (accountLoggedOutEl) accountLoggedOutEl.style.display = loggedIn ? 'none' : 'block';
            if (accountLoggedInEl) accountLoggedInEl.style.display = loggedIn ? 'block' : 'none';
            if (accountUsernameEl) accountUsernameEl.textContent = loggedIn ? (u.username || '') : '';
            if (libraryToggleBtn) libraryToggleBtn.style.display = loggedIn ? 'inline-flex' : 'none';
        }

        async function refreshMe() {
            try {
                const data = await apiJson('/me');
                currentUser = data?.user || null;
                renderAccountUi();
                await loadUserSettings();
            } catch {
                setAuthToken('');
                currentUser = null;
                currentUserSettings = null;
                libraryCache = null;
                renderAccountUi();
            }
        }

        async function authRegister(username, password) {
            await apiJson('/auth/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
        }

        async function authLogin(username, password) {
            const data = await apiJson('/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username, password })
            });
            if (data?.token) setAuthToken(data.token);
            currentUser = data?.user || null;
            renderAccountUi();
            await loadUserSettings();
        }

        async function authLogout() {
            try { await apiJson('/auth/logout', { method: 'POST' }); } catch { }
            setAuthToken('');
            currentUser = null;
            currentUserSettings = null;
            libraryCache = null;
            renderAccountUi();
        }

        async function loadUserSettings() {
            if (!currentUser) { currentUserSettings = null; return; }
            try {
                const data = await apiJson('/user/settings');
                currentUserSettings = (data && typeof data.settings === 'object') ? data.settings : {};
            } catch {
                currentUserSettings = {};
            }
        }

        async function saveUserSettings(patch) {
            if (!currentUser) return;
            const data = await apiJson('/user/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(patch || {})
            });
            currentUserSettings = (data && typeof data.settings === 'object') ? data.settings : (currentUserSettings || {});
        }

        async function fetchContinueWatchingSafe() {
            if (!currentUser) return [];
            try {
                const data = await apiJson('/user/continue-watching');
                return Array.isArray(data?.items) ? data.items : [];
            } catch {
                return [];
            }
        }

        async function fetchLibrarySafe(opts = {}) {
            if (!currentUser) return [];
            const force = !!opts.force;
            if (!force && libraryCache && (Date.now() - libraryCacheAt) < LIBRARY_CACHE_TTL_MS) return libraryCache;
            try {
                const data = await apiJson('/user/library');
                const items = Array.isArray(data?.items) ? data.items : [];
                libraryCache = items;
                libraryCacheAt = Date.now();
                return items;
            } catch {
                return [];
            }
        }

        async function isInLibrary(id) {
            try {
                const items = await fetchLibrarySafe();
                return (items || []).some(x => String(x?.id || '') === String(id || ''));
            } catch {
                return false;
            }
        }

        async function updateLibraryButton() {
            if (!libraryToggleBtn) return;
            if (!currentUser || !currentDetailsCtx?.id) {
                libraryToggleBtn.style.display = 'none';
                return;
            }
            libraryToggleBtn.style.display = 'inline-flex';
            const inLib = await isInLibrary(currentDetailsCtx.id);
            libraryToggleBtn.textContent = inLib ? 'Remove from List' : 'Add to List';
        }

        libraryToggleBtn?.addEventListener('click', async () => {
            if (!currentUser || !currentDetailsCtx?.id) {
                setStatus('Login required to use My List.', true);
                return;
            }

            try {
                libraryToggleBtn.disabled = true;
                const inLib = await isInLibrary(currentDetailsCtx.id);

                if (inLib) {
                    await apiJson(`/user/library/${encodeURIComponent(currentDetailsCtx.id)}`, { method: 'DELETE' });
                } else {
                    await apiJson('/user/library', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: currentDetailsCtx.id,
                            type: currentDetailsCtx.type,
                            title: currentDetailsCtx.title,
                            poster: currentDetailsCtx.poster,
                            source: currentDetailsCtx.source
                        })
                    });
                }

                libraryCache = null;
                await updateLibraryButton();
                setStatus(inLib ? 'Removed from My List.' : 'Added to My List.');

                if (currentTopTab !== 'settings') {
                    await refreshHome({ forceReload: false, clearItemsCache: false });
                }
            } catch (e) {
                setStatus('My List update failed: ' + (e?.message || e), true);
            } finally {
                libraryToggleBtn.disabled = false;
            }
        });

        async function fetchAddons() {
            const res = await apiFetch("/addons");
            if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
            const data = await res.json();
            return Array.isArray(data) ? data : [];
        }

        async function installAddon(url) {
            const res = await apiFetch("/addons/install", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data?.error || `HTTP ${res.status} ${res.statusText}`);
            return data;
        }

        async function removeAddon(uid) {
            const res = await apiFetch("/addons/remove", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ uid })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data?.error || `HTTP ${res.status} ${res.statusText}`);
            return data;
        }

        async function setAddonEnabled(uid, enabled) {
            const res = await apiFetch(`/addons/${encodeURIComponent(uid)}/enabled`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ enabled })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data?.error || `HTTP ${res.status} ${res.statusText}`);
            return data;
        }

        async function fetchCatalogs() {
            const res = await apiFetch("/catalogs");
            if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
            const data = await res.json();
            return Array.isArray(data) ? data : [];
        }

        async function fetchCatalogsCached(opts = {}) {
            const force = !!opts.force;
            const now = Date.now();
            if (!force && __catalogsCache.value && (now - __catalogsCache.at) < CATALOGS_CACHE_TTL_MS) {
                return __catalogsCache.value;
            }

            if (!force && __catalogsInFlight) return __catalogsInFlight;

            __catalogsInFlight = (async () => {
                const list = await fetchCatalogs();
                __catalogsCache = { at: Date.now(), value: list };
                __catalogsInFlight = null;
                return list;
            })().catch((e) => {
                __catalogsInFlight = null;
                throw e;
            });

            return __catalogsInFlight;
        }

        // Catalog order management
        function mapCatalogUidFromBackend(uid) {
            if (uid === 'local:default.catalog') return 'global';
            return uid;
        }
        function mapCatalogUidToBackend(uid) {
            if (uid === 'global') return 'local:default.catalog';
            return uid;
        }

        async function fetchCatalogOrder() {
            const res = await apiFetch('/catalog-order');
            if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
            const data = await res.json();
            if (Array.isArray(data?.order)) {
                data.order = data.order.map(mapCatalogUidFromBackend).filter(Boolean);
            }
            return data;
        }
        async function saveCatalogOrder(order, globalEnabled = true) {
            const mapped = Array.isArray(order) ? order.map(mapCatalogUidToBackend) : [];
            const res = await apiFetch('/catalog-order', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ order: mapped, globalEnabled })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) throw new Error(data?.error || `HTTP ${res.status} ${res.statusText}`);
            return data;
        }

        async function renderCatalogOrder() {
            const container = document.getElementById('catalogOrderList');
            const saveBtn = document.getElementById('saveCatalogOrderBtn');
            const resetBtn = document.getElementById('resetCatalogOrderBtn');
            saveBtn.disabled = true;
            try {
                const j = await fetchCatalogOrder();
                const order = Array.isArray(j.order) ? j.order : [];
                const addons = Array.isArray(j.addons) ? j.addons : [];
                container.innerHTML = '';
                let globalAddon = addons.find(x => x.uid === 'global');

                for (const uid of order) {
                    const a = addons.find(x => x.uid === uid);
                    if (!a) continue;
                    const row = document.createElement('div');
                    row.className = 'catalogRow';
                    row.draggable = true; // all rows are draggable now
                    row.dataset.uid = a.uid;

                    const displayName = uid === 'global' ? 'Default Catalogs' : a.name;
                    const displaySub = uid === 'global' ? ' â€¢ Trending, Popular, Upcoming' : (a.manifestId ? ' â€¢ ' + a.manifestId : '');
                    row.innerHTML = `<span class="dragHandle">${uid === 'global' ? 'âš™' : 'â˜°'}</span><div class="catalogName">${displayName}<span class="catalogSmall">${displaySub}</span></div>`;

                    // enabled toggle
                    const toggle = document.createElement('input');
                    toggle.type = 'checkbox';
                    toggle.checked = !!a.enabled;
                    toggle.title = uid === 'global' ? 'Toggle Default Catalogs visibility (search always works)' : 'Enabled';
                    
                    if (uid === 'global') {
                        // For global, save toggle locally without calling setAddonEnabled
                        toggle.addEventListener('change', async () => {
                            try {
                                toggle.disabled = true;
                                setStatus(`${toggle.checked ? 'Showing' : 'Hiding'} Default Catalogsâ€¦`);
                                await saveCatalogOrder(
                                    Array.from(container.querySelectorAll('.catalogRow')).map(r => r.dataset.uid),
                                    toggle.checked
                                );
                                clearHomeCaches();
                                await refreshHome({ forceReload: true, clearItemsCache: true });
                                setStatus(`${toggle.checked ? 'Showing' : 'Hiding'} Default Catalogs.`);
                            } catch (e) {
                                setStatus('Failed: ' + (e?.message || e), true);
                                toggle.checked = !toggle.checked;
                            } finally { toggle.disabled = false; }
                        });
                    } else {
                        // For addons, call setAddonEnabled
                        toggle.addEventListener('change', async () => {
                            try {
                                toggle.disabled = true;
                                setStatus(`Updating addon: ${a.name}â€¦`);
                                await setAddonEnabled(a.uid, toggle.checked);
                                clearHomeCaches();
                                await refreshHome({ forceReload: true, clearItemsCache: true });
                                await renderCatalogOrder();
                                setStatus(`Updated: ${a.name}`);
                            } catch (e) {
                                setStatus('Failed: ' + (e?.message || e), true);
                                toggle.checked = !toggle.checked;
                            } finally { toggle.disabled = false; }
                        });
                    }

                    row.appendChild(toggle);

                    // drag handlers (all rows draggable)
                    row.addEventListener('dragstart', (ev) => { ev.dataTransfer.setData('text/plain', a.uid); row.classList.add('dragging'); });
                    row.addEventListener('dragend', () => row.classList.remove('dragging'));
                    row.addEventListener('dragover', (ev) => { ev.preventDefault(); });
                    row.addEventListener('drop', (ev) => {
                        ev.preventDefault();
                        const draggedUid = ev.dataTransfer.getData('text/plain');
                        if (!draggedUid) return;
                        const dragged = container.querySelector(`[data-uid="${draggedUid}"]`);
                        const target = ev.currentTarget;
                        if (!dragged || !target || dragged === target) return;
                        container.insertBefore(dragged, target);
                        saveBtn.disabled = false;
                    });

                    container.appendChild(row);
                }

                // Save button
                saveBtn.onclick = async () => {
                    try {
                        saveBtn.disabled = true;
                        const newOrder = Array.from(container.querySelectorAll('.catalogRow')).map(r => r.dataset.uid);
                        const globalToggle = container.querySelector('[data-uid="global"] input[type="checkbox"]');
                        const globalEnabled = globalToggle ? globalToggle.checked : true;
                        await saveCatalogOrder(newOrder, globalEnabled);
                        setStatus('Catalog order saved.');
                        clearHomeCaches();
                        await refreshHome({ forceReload: true, clearItemsCache: true });
                    } catch (e) {
                        setStatus('Save failed: ' + (e?.message || e), true);
                        saveBtn.disabled = false;
                    }
                };

                resetBtn.onclick = async () => {
                    try {
                        resetBtn.disabled = true;
                        await saveCatalogOrder([], true);
                        setStatus('Catalog order reset.');
                        await renderCatalogOrder();
                        clearHomeCaches();
                        await refreshHome({ forceReload: true, clearItemsCache: true });
                    } catch (e) {
                        setStatus('Reset failed: ' + (e?.message || e), true);
                    } finally { resetBtn.disabled = false; }
                };

            } catch (e) {
                container.innerHTML = 'Failed to load: ' + (e?.message || e);
                setStatus('Failed to load catalog order: ' + (e?.message || e), true);
            }
        }

        async function fetchCatalogItems(addonUid, type, catalogId, search) {
            const key = `${addonUid}:${type}:${catalogId}:${search || ""}`;
            if (catalogItemsCache.has(key)) return catalogItemsCache.get(key);
            let res;
            // If this is the new global curated catalog, call the simplified route
            if (addonUid === 'global') {
                const url = new URL(`${API_BASE}/catalog/${encodeURIComponent(type)}/${encodeURIComponent(catalogId)}`);
                if (search) url.searchParams.set("search", search);
                res = await apiFetch(url.toString());
            } else {
                const url = new URL(`${API_BASE}/catalog/${encodeURIComponent(addonUid)}/${encodeURIComponent(type)}/${encodeURIComponent(catalogId)}`);
                if (search) url.searchParams.set("search", search);
                res = await apiFetch(url.toString());
            }
            if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
            const items = await res.json();
            const normalized = Array.isArray(items) ? items : [];

            catalogItemsCache.set(key, normalized);
            return normalized;
        }

        async function fetchStreams(id, item) {
            // Build query with item metadata for better search
            const params = new URLSearchParams();
            params.set('id', id);
            if (item) {
                if (item.title) params.set('title', item.title);
                if (item.type) params.set('type', item.type);
            }

            // Apply stream limit setting (for testing / reducing API usage)
            const cfg = getStreamLimitConfig();
            if (cfg.enabled) params.set('limit', String(cfg.limit));
            else params.set('limit', '200');

            const url = `${API_BASE}/streams/${encodeURIComponent(id)}?${params}`;
            console.log('[fetchStreams] Calling:', url);
            console.log('[fetchStreams] Item:', item);
            
            const res = await apiFetch(url);
            if (!res.ok) {
                console.error('[fetchStreams] HTTP error:', res.status, res.statusText);
                throw new Error(`HTTP ${res.status} ${res.statusText}`);
            }

            const data = await res.json();
            console.log('[fetchStreams] Response:', data);
            console.log('[fetchStreams] Streams count:', Array.isArray(data) ? data.length : (data?.streams?.length || 0));
            
            if (Array.isArray(data)) return data;
            if (data && Array.isArray(data.streams)) return data.streams;
            return [];
        }

        // ---------- Tabs ----------
        function setTab(tab, opts = {}) {
            saveTabState(currentTopTab);
            currentTopTab = tab;
            try {
                // Remember the last non-home tab so BACK can highlight the current menu item
                // even if the platform temporarily focuses Home.
                if (tab && tab !== 'home') window.__tvLastContentTab = tab;
                persistTopTab(tab);
            } catch { }
            const isSettings = tab === 'settings';
            const isTV = tab === 'tv';
            homeWrap.style.display = (isSettings || isTV) ? 'none' : 'block';
            settingsWrap.style.display = isSettings ? 'block' : 'none';
            // Search UI is opened via icon click; keep icon hidden on Settings/TV.
            if (searchToggleBtn) searchToggleBtn.style.display = (isSettings || isTV) ? 'none' : 'inline-flex';
            tvWrap.style.display = isTV ? 'block' : 'none';
            
            // Control body overflow for TV mode
            if (isTV) {
                document.body.classList.add('tv-active');
                // Nothing extra; playback will resume based on saved state
            } else {
                document.body.classList.remove('tv-active');
                stopTVPlayback();
            }

            const btns = {
                home: tabHomeBtn,
                movies: tabMoviesBtn,
                series: tabSeriesBtn,
                anime: tabAnimeBtn,
                tv: tabTVBtn,
                mylist: tabMyListBtn,
                settings: tabSettingsBtn
            };
            Object.entries(btns).forEach(([k, el]) => {
                if (!el) return;
                el.classList.toggle('active', k === tab);
            });

            updateTabIndicator(btns[tab]);
            
            if (isTV && !tvChannelsCache) {
                // Only load TV channels if not already loaded
                loadTVChannels();
            }

        }

        let __tabSwitchTimer = null;
        let __tabSwitchToken = 0;

        async function switchTopTab(tab, opts = {}) {
            const t = String(tab || 'home');
            if (currentTopTab === t && !opts.forceReload && !opts.clearItemsCache) {
                updateTabIndicator();
                return;
            }

            const fromTab = String(currentTopTab || 'home');

            // Switch the active tab state + move the indicator immediately.
            // Then yield a frame so the animation can render smoothly.
            setTab(t);
            pulseViewFade();
            try { await __yieldFrames(1); } catch { }

            // During a transition, chunk heavy DOM work so it doesn't freeze animations.
            window.__uiTransitioning = true;

            // Cache the previous tab's rendered DOM (if eligible) AFTER the indicator started animating.
            cacheActiveViewDom(fromTab);

            try {
                // If we already rendered this tab and nothing forces a reload, restore instantly.
                if (!opts.forceReload && !opts.clearItemsCache) {
                    if (restoreViewDom(t)) {
                        pulseViewFade();
                        restoreTabState(t);
                        return;
                    }
                }

                // Settings/TV don't require re-rendering the catalog rows.
                if (t === 'settings') {
                    try { closeSearchUi({ clear: false }); } catch { }
                    try { await loadSettings(); } catch { }
                    return;
                }
                if (t === 'tv') {
                    try { closeSearchUi({ clear: false }); } catch { }
                    return;
                }

                const token = ++__tabSwitchToken;
                try {
                    // Yield once more so the indicator animation doesn't stall.
                    try { await __yieldFrames(1); } catch { }
                    await refreshHome({
                        forceReload: !!opts.forceReload,
                        clearItemsCache: !!opts.clearItemsCache
                    });
                } catch { }
                if (token !== __tabSwitchToken) return;
                pulseViewFade();
                restoreTabState(t);
            } finally {
                window.__uiTransitioning = false;
            }
        }

        function scheduleTvTabSwitch(tab) {
            try {
                clearTimeout(__tabSwitchTimer);
                __tabSwitchTimer = setTimeout(() => {
                    switchTopTab(tab).catch(() => {});
                }, 120);
            } catch { }
        }

        async function preloadAllCatalogItems(cats = []) {
            const list = (Array.isArray(cats) ? cats : [])
                .filter(c => c && c.addonUid && c.type && c.id)
                .filter(c => normalizeType(c.type) !== 'iptv');
            if (!list.length) return;

            let done = 0;
            const total = list.length;
            const concurrency = 4;
            let idx = 0;

            const worker = async () => {
                while (true) {
                    const i = idx++;
                    if (i >= total) break;
                    const c = list[i];
                    try {
                        await fetchCatalogItems(c.addonUid, c.type, c.id, '');
                    } catch { }
                    done++;
                    if (done === 1 || done === total || done % 6 === 0) {
                        showBootSplash(`Loading catalogsâ€¦ ${done}/${total}`);
                    }
                }
            };

            showBootSplash(`Loading catalogsâ€¦ 0/${total}`);
            await Promise.all(Array.from({ length: Math.min(concurrency, total) }, () => worker()));
        }

        // ---------- TV Channels Cache & Grouping ----------
        const TV_CACHE_KEY_BASE = 'tv_channels_cache';
        // Keep cache longer than a single session; IPTV channel lists are expensive to rebuild.
        const TV_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

        // Cache is keyed by the current M3U URL hash so switching playlists invalidates automatically.
        let tvCacheScope = 'default';

        function hashStringFNV1a(input) {
            try {
                const s = String(input || '');
                let h = 0x811c9dc5;
                for (let i = 0; i < s.length; i++) {
                    h ^= s.charCodeAt(i);
                    // 32-bit FNV-1a
                    h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
                }
                return h.toString(16).padStart(8, '0');
            } catch {
                return '00000000';
            }
        }

        function getEffectiveTvCacheKey() {
            const scope = String(tvCacheScope || 'default');
            return `${TV_CACHE_KEY_BASE}:${scope}`;
        }

        // IndexedDB cache (much larger than localStorage; important for big IPTV lists)
        const TV_IDB_DB = 'media_tv_cache';
        const TV_IDB_STORE = 'kv';
        let __tvIdbPromise = null;
        function openTvCacheDb() {
            if (__tvIdbPromise) return __tvIdbPromise;
            __tvIdbPromise = new Promise((resolve, reject) => {
                try {
                    if (!window.indexedDB) return resolve(null);
                    const req = indexedDB.open(TV_IDB_DB, 1);
                    req.onupgradeneeded = () => {
                        try {
                            const db = req.result;
                            if (!db.objectStoreNames.contains(TV_IDB_STORE)) {
                                db.createObjectStore(TV_IDB_STORE, { keyPath: 'key' });
                            }
                        } catch { }
                    };
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve(null);
                } catch {
                    resolve(null);
                }
            });
            return __tvIdbPromise;
        }

        async function idbGet(key) {
            const db = await openTvCacheDb();
            if (!db) return null;
            return await new Promise((resolve) => {
                try {
                    const tx = db.transaction([TV_IDB_STORE], 'readonly');
                    const store = tx.objectStore(TV_IDB_STORE);
                    const req = store.get(String(key));
                    req.onsuccess = () => resolve(req.result?.value ?? null);
                    req.onerror = () => resolve(null);
                } catch {
                    resolve(null);
                }
            });
        }

        async function idbSet(key, value) {
            const db = await openTvCacheDb();
            if (!db) return false;
            return await new Promise((resolve) => {
                try {
                    const tx = db.transaction([TV_IDB_STORE], 'readwrite');
                    const store = tx.objectStore(TV_IDB_STORE);
                    store.put({ key: String(key), value });
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => resolve(false);
                    tx.onabort = () => resolve(false);
                } catch {
                    resolve(false);
                }
            });
        }

        async function idbDel(key) {
            const db = await openTvCacheDb();
            if (!db) return false;
            return await new Promise((resolve) => {
                try {
                    const tx = db.transaction([TV_IDB_STORE], 'readwrite');
                    const store = tx.objectStore(TV_IDB_STORE);
                    store.delete(String(key));
                    tx.oncomplete = () => resolve(true);
                    tx.onerror = () => resolve(false);
                    tx.onabort = () => resolve(false);
                } catch {
                    resolve(false);
                }
            });
        }

        function slimChannelForCache(ch) {
            // Keep only what the TV UI needs (reduces cache size + speeds parse).
            return {
                id: ch?.id,
                name: ch?.name,
                title: ch?.title,
                logo: ch?.logo,
                poster: ch?.poster,
                url: ch?.url,
                type: ch?.type,
                group: ch?.group
            };
        }
        
        async function getTVChannelsFromCache() {
            try {
                const key = getEffectiveTvCacheKey();

                // 1) Try IndexedDB first
                const cachedIdb = await idbGet(key);
                if (cachedIdb && typeof cachedIdb === 'object') {
                    const { data, timestamp } = cachedIdb;
                    const now = Date.now();
                    if (timestamp && now - timestamp < TV_CACHE_DURATION && Array.isArray(data)) {
                        console.log('[TV Cache] Using IndexedDB cached channels, age:', Math.round((now - timestamp) / 1000), 'seconds');
                        return data;
                    }
                    // expired
                    await idbDel(key);
                }

                // 2) Fallback to localStorage
                const cached = localStorage.getItem(key) || localStorage.getItem(TV_CACHE_KEY_BASE);
                if (!cached) return null;

                const { data, timestamp } = JSON.parse(cached);
                const now = Date.now();
                
                if (now - timestamp < TV_CACHE_DURATION) {
                    console.log('[TV Cache] Using cached channels, age:', Math.round((now - timestamp) / 1000), 'seconds');
                    return data;
                } else {
                    console.log('[TV Cache] Cache expired');
                    try { localStorage.removeItem(key); } catch { }
                    try { localStorage.removeItem(TV_CACHE_KEY_BASE); } catch { }
                    return null;
                }
            } catch (err) {
                console.error('[TV Cache] Error reading cache:', err);
                return null;
            }
        }
        
        async function saveTVChannelsToCache(channels) {
            try {
                const key = getEffectiveTvCacheKey();
                const payload = {
                    data: Array.isArray(channels) ? channels.map(slimChannelForCache) : [],
                    timestamp: Date.now()
                };

                // Prefer IndexedDB (handles big lists)
                const ok = await idbSet(key, payload);
                if (ok) {
                    console.log('[TV Cache] Channels cached (IndexedDB):', payload.data.length);
                    return;
                }

                // Fallback to localStorage (may fail if too big)
                localStorage.setItem(key, JSON.stringify(payload));
                console.log('[TV Cache] Channels cached (localStorage):', payload.data.length);
            } catch (err) {
                console.error('[TV Cache] Error saving cache:', err);
            }
        }
        
        function saveTVState() {
            try {
                localStorage.setItem('tv_state', JSON.stringify({
                    mainFolder: tvSelectedMainFolder,
                    subfolder: tvSelectedSubfolder,
                    page: tvCurrentPage,
                    channelId: tvLastSelectedChannelId || tvCurrentlyPlaying?.id || null
                }));
            } catch (err) {
                console.error('[TV State] Error saving state:', err);
            }
        }
        
        function loadTVState() {
            try {
                const saved = localStorage.getItem('tv_state');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (err) {
                console.error('[TV State] Error loading state:', err);
            }
            return null;
        }
        
        function groupChannelsByActualCategory(channels) {
            const grouped = {};
            channels.forEach(ch => {
                const category = ch.group || 'Other';
                if (!grouped[category]) {
                    grouped[category] = [];
                }
                grouped[category].push(ch);
            });
            return grouped;
        }

        function classifyChannelsContent(channels = []) {
            let movieHits = 0;
            let seriesHits = 0;

            channels.forEach(ch => {
                const name = (ch.name || ch.title || '').toUpperCase();
                const url = (ch.url || '').toUpperCase();

                if (/\bS\d{1,2}E\d{1,3}\b/.test(name) || /\b\d{1,2}X\d{1,3}\b/.test(name) || /\bSEASON\s*\d+\b/.test(name)) {
                    seriesHits++;
                }

                if (/\bEP(ISODE)?\s*\d+\b/.test(name) || /\bBOL(U|Ãœ)M\s*\d+\b/.test(name) || /\bCAP[IÃ]TULO\s*\d+\b/.test(name)) {
                    seriesHits++;
                }

                if (/\b(19[5-9]\d|20[0-4]\d)\b/.test(name)) movieHits++;
                if (/(1080P|720P|BLURAY|WEB[ \-]?DL|HDRIP|DVDRIP)/.test(name)) movieHits++;
                if (/\.(MP4|MKV|AVI|MOV|M4V)$/.test(url)) movieHits++;
                if (/\bMOVIE\b|\bFILM\b|\bPELICULA\b|\bPELIS\b|\bSINEMA\b|\bCINEMA\b/.test(name)) movieHits++;
            });

            const total = channels.length || 1;
            if (seriesHits > movieHits) return 'Series';
            if (movieHits > 0 && movieHits / total >= 0.25 && movieHits >= seriesHits * 2) return 'Movies';
            if (seriesHits > 0) return 'Series';
            if (movieHits > 0) return 'Movies';
            return null;
        }

        // ---------- Favorites ----------
        let tvFavorites = { live: [], movies: [], series: [] };

        function loadTVFavorites() {
            try {
                const saved = localStorage.getItem('tv_favorites');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    tvFavorites = {
                        live: Array.isArray(parsed?.live) ? parsed.live : [],
                        movies: Array.isArray(parsed?.movies) ? parsed.movies : [],
                        series: Array.isArray(parsed?.series) ? parsed.series : []
                    };
                }
            } catch (err) {
                console.warn('[TV Favorites] load error', err);
            }
        }

        // ---------- Continue Watching ----------
        let tvContinueWatching = { movies: {}, series: {} };

        function loadTVContinueWatching() {
            try {
                const saved = localStorage.getItem('tv_continue_watching');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    tvContinueWatching = {
                        movies: parsed?.movies || {},
                        series: parsed?.series || {}
                    };
                }
            } catch (err) {
                console.warn('[TV Continue] load error', err);
            }
        }

        function saveTVContinueWatching() {
            try {
                localStorage.setItem('tv_continue_watching', JSON.stringify(tvContinueWatching));
            } catch (err) {
                console.warn('[TV Continue] save error', err);
            }
        }

        function updateContinueWatching(channel, currentTime, duration) {
            const mainFolder = tvSelectedMainFolder;
            if (mainFolder !== 'Movies' && mainFolder !== 'Series') return;
            const type = mainFolder.toLowerCase();
            const id = channel.id || `${type}-${channel.name || channel.title}`;
            
            const progress = duration > 0 ? (currentTime / duration) : 0;
            const minThreshold = type === 'series' ? 0.02 : 0.01; // 2% for series, 1% for movies
            
            console.log('[TV Continue Watching] Updating:', {
                type,
                channelName: channel.name || channel.title,
                currentTime,
                duration,
                progress: (progress * 100).toFixed(1) + '%',
                minThreshold: (minThreshold * 100).toFixed(1) + '%'
            });
            
            if (progress < minThreshold || progress > 0.99) {
                console.log('[TV Continue Watching] Skipping (too early/too late):', (progress * 100).toFixed(1) + '%');
                delete tvContinueWatching[type][id];
            } else {
                tvContinueWatching[type][id] = {
                    id,
                    name: channel.name || channel.title,
                    poster: channel.poster || channel.logo,
                    currentTime,
                    duration,
                    progress,
                    timestamp: Date.now(),
                    channel
                };
                console.log('[TV Continue Watching] Saved item, total items:', Object.keys(tvContinueWatching[type]).length);
            }
            saveTVContinueWatching();
        }

        function getContinueWatchingList(type) {
            const items = Object.values(tvContinueWatching[type] || {});
            items.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            const result = items.slice(0, 20);
            console.log('[TV Continue Watching] Retrieved for type:', type, 'count:', result.length, 'data:', tvContinueWatching);
            return result;
        }

        // ---------- Recently Watched (Live TV) ----------
        let tvRecentlyWatched = [];

        function loadTVRecentlyWatched() {
            try {
                const saved = localStorage.getItem('tv_recently_watched');
                if (saved) {
                    tvRecentlyWatched = JSON.parse(saved);
                    if (!Array.isArray(tvRecentlyWatched)) tvRecentlyWatched = [];
                }
            } catch (err) {
                console.warn('[TV Recently Watched] load error', err);
                tvRecentlyWatched = [];
            }
        }

        function saveTVRecentlyWatched() {
            try {
                localStorage.setItem('tv_recently_watched', JSON.stringify(tvRecentlyWatched));
            } catch (err) {
                console.warn('[TV Recently Watched] save error', err);
            }
        }

        function addToRecentlyWatched(channel) {
            const id = channel.id || `live-${channel.name || channel.title}`;
            
            // Remove if already exists
            tvRecentlyWatched = tvRecentlyWatched.filter(item => item.id !== id);
            
            // Add to front
            tvRecentlyWatched.unshift({
                id,
                name: channel.name || channel.title,
                poster: channel.poster || channel.logo,
                logo: channel.logo || channel.poster,
                timestamp: Date.now(),
                channel
            });
            
            // Keep only last 20
            tvRecentlyWatched = tvRecentlyWatched.slice(0, 20);
            
            console.log('[TV Recently Watched] Added channel, total items:', tvRecentlyWatched.length);
            saveTVRecentlyWatched();
        }

        function getRecentlyWatchedList() {
            return tvRecentlyWatched.slice(0, 20);
        }

        function saveTVFavorites() {
            try {
                localStorage.setItem('tv_favorites', JSON.stringify(tvFavorites));
            } catch (err) {
                console.warn('[TV Favorites] save error', err);
            }
        }

        function getMainTypeFromFolder(folderName) {
            if (folderName === 'Movies') return 'movies';
            if (folderName === 'Series') return 'series';
            return 'live';
        }

        function ensureFavoriteShape(item, type) {
            const id = item.id || `${type}-${(item.name || item.title || 'unknown')}`;
            return {
                id,
                name: item.name || item.title || 'Untitled',
                title: item.title || item.name || 'Untitled',
                poster: item.poster || item.logo || '',
                url: item.url || '',
                group: item.group || '',
                tvEpisodesLocal: item.tvEpisodesLocal || item.episodes || [],
                type
            };
        }

        function isFavorite(item, type) {
            const favs = tvFavorites[type] || [];
            const id = item.id || `${type}-${(item.name || item.title || 'unknown')}`;
            return favs.some(f => f.id === id);
        }

        function toggleFavorite(item, type) {
            const favs = tvFavorites[type] || [];
            const safe = ensureFavoriteShape(item, type);
            const idx = favs.findIndex(f => f.id === safe.id);
            if (idx >= 0) {
                favs.splice(idx, 1);
            } else {
                favs.push(safe);
            }
            tvFavorites[type] = favs;
            saveTVFavorites();

            // If viewing favorites, refresh list
            if (tvSelectedSubfolder === 'Favorites' && getMainTypeFromFolder(tvSelectedMainFolder) === type) {
                displayTVCategoryChannels('Favorites', tvFavorites[type]);
            }
        }
        
        function organizeIntoMainFolders(grouped) {
            const mainFolders = {
                'Live TV': {},
                'Movies': {},
                'Series': {}
            };

            const movieKeywords = ['FILM', 'MOVIE', 'VOD', 'CINEMA'];
            const seriesKeywords = ['SERIE', 'SERIES', 'DIZI', 'TV SHOW', 'SERI'];
            const liveNoise = ['TV', 'LIVE', 'SPORT', 'NEWS', 'MUSIC', 'RADIO'];
            const livePattern = /(24[\s\-\/]*7|7[\s\-\/]*24)/; // force Live for 24/7 style categories

            Object.entries(grouped).forEach(([category, channels]) => {
                const catUpper = category.toUpperCase();
                const contentType = classifyChannelsContent(channels);

                const is24x7 = livePattern.test(catUpper);
                const catSaysSeries = seriesKeywords.some(k => catUpper.includes(k));
                const catSaysMovie = movieKeywords.some(k => catUpper.includes(k));

                if (is24x7) {
                    mainFolders['Live TV'][category] = channels;
                    return;
                }

                // Explicit movie label wins even if "TV" is present
                if (catSaysMovie && !catSaysSeries) {
                    mainFolders['Movies'][category] = channels;
                    return;
                }

                // Explicit series label wins when not also marked movie
                if (catSaysSeries && !catSaysMovie) {
                    mainFolders['Series'][category] = channels;
                    return;
                }

                // Mixed labels: defer to content type
                if (catSaysSeries && catSaysMovie) {
                    if (contentType === 'Movies') {
                        mainFolders['Movies'][category] = channels;
                    } else if (contentType === 'Series') {
                        mainFolders['Series'][category] = channels;
                    } else {
                        mainFolders['Movies'][category] = channels; // bias mixed to VOD over Live
                    }
                    return;
                }

                // No strong label: use content heuristics first
                if (contentType === 'Movies') {
                    mainFolders['Movies'][category] = channels;
                } else if (contentType === 'Series') {
                    mainFolders['Series'][category] = channels;
                } else {
                    mainFolders['Live TV'][category] = channels;
                }
            });

            return mainFolders;
        }

        function classifyFolderByCategory(category, channels = []) {
            const movieKeywords = ['FILM', 'MOVIE', 'VOD', 'CINEMA'];
            const seriesKeywords = ['SERIE', 'SERIES', 'DIZI', 'TV SHOW', 'SERI'];
            const liveNoise = ['TV', 'LIVE', 'SPORT', 'NEWS', 'MUSIC', 'RADIO'];
            const livePattern = /(24[\s\-\/]*7|7[\s\-\/]*24)/;
            const catUpper = category.toUpperCase();
            const contentType = classifyChannelsContent(channels);
            const is24x7 = livePattern.test(catUpper);
            const catSaysSeries = seriesKeywords.some(k => catUpper.includes(k));
            const catSaysMovie = movieKeywords.some(k => catUpper.includes(k));

            if (is24x7) return 'Live TV';
            if (catSaysMovie && !catSaysSeries) return 'Movies';
            if (catSaysSeries && !catSaysMovie) return 'Series';
            if (catSaysSeries && catSaysMovie) return contentType === 'Movies' ? 'Movies' : 'Series';
            if (contentType === 'Movies') return 'Movies';
            if (contentType === 'Series') return 'Series';
            return 'Live TV';
        }
        
        // ---------- Load TV Channels ----------
        let tvChannelsCache = null;
        let tvGroupedChannels = {};
        let tvMainFolders = {};
        let tvSelectedMainFolder = null;
        let tvSelectedSubfolder = null;
        let tvCurrentPage = 0;
        let tvItemsPerPage = 30;
        let tvCurrentlyPlaying = null; // Track currently playing channel
        let tvLastSelectedChannelId = null;
        let tvActiveDisplayedChannels = []; // current displayed channels list (used for zapping)
        let tvEmbeddedPlayerActive = false;
        let tvVideoElement = null;
        let tvHlsInstance = null;
        let tvHlsLoading = null;
        let tvStreamRetryAttempts = 0;
        let tvStreamRetryTimer = null;
        const TV_STREAM_RETRY_MAX = 5;
        const TV_STREAM_RETRY_DELAY_MS = 2500;
        const TV_STREAM_START_TIMEOUT_MS = 12000;
        let tvStreamCandidates = [];
        let tvStreamCandidateIndex = 0;
        let tvStateToRestore = null;
        let tvSearchInputEl = null;
        const tvEpgCache = new Map();
        const TV_EPG_CACHE_MS = 5 * 60 * 1000;

        function focusTVChannelById(channelId) {
            try {
                const id = String(channelId || '').trim();
                if (!id) return false;
                const container = document.getElementById('tvChannelsContainer');
                if (!container) return false;
                const el = container.querySelector(`[data-tv-channel-id="${CSS.escape(id)}"]`);
                if (el && isElementVisible(el)) {
                    try { el.focus({ preventScroll: true }); } catch { try { el.focus(); } catch { } }
                    try { el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); } catch { }
                    return true;
                }
            } catch { }
            return false;
        }

        function cleanupTvHls() {
            try {
                if (tvHlsInstance) {
                    tvHlsInstance.destroy();
                }
            } catch (e) {
                console.warn('[TV] HLS destroy failed', e);
            }
            tvHlsInstance = null;
        }

        function showStreamFailureMessage(channel, streamUrl) {
            const playerContent = document.getElementById('tvPlayerContent');
            const fullscreenBadge = document.getElementById('tvFullscreenBadge');
            const playPauseBtn = document.getElementById('tvPlayPauseBtn');
            if (playPauseBtn) playPauseBtn.style.display = 'none';
            if (fullscreenBadge) fullscreenBadge.style.display = 'none';

            if (playerContent) {
                const wrap = document.createElement('div');
                wrap.style.cssText = 'display:flex; flex-direction:column; align-items:center; justify-content:center; color:#e2e8f0; gap:10px; height:100%; text-align:center;';
                const msg = document.createElement('div');
                msg.textContent = 'Stream failed after multiple retries.';
                msg.style.cssText = 'font-weight:600;';
                const hint = document.createElement('div');
                hint.textContent = 'You can retry the embedded player or open externally.';
                hint.style.cssText = 'font-size:13px; color:#94a3b8;';
                const btnRow = document.createElement('div');
                btnRow.style.cssText = 'display:flex; gap:10px;';

                const retryBtn = document.createElement('button');
                retryBtn.textContent = 'Retry Embedded';
                retryBtn.className = 'btn';
                retryBtn.style.cssText = 'padding:10px 14px; background:#3b82f6; border:1px solid rgba(59,130,246,0.6); color:#e2e8f0; border-radius:6px; cursor:pointer; font-weight:700;';
                retryBtn.onclick = () => {
                    tvStreamRetryAttempts = 0;
                    if (tvStreamRetryTimer) {
                        clearTimeout(tvStreamRetryTimer);
                        tvStreamRetryTimer = null;
                    }
                    showTVEmbeddedPlayer(channel, streamUrl, { isRetry: false });
                };

                const extBtn = document.createElement('button');
                extBtn.textContent = 'Open External Player';
                extBtn.className = 'btn';
                extBtn.style.cssText = 'padding:10px 14px; background:#0f172a; border:1px solid rgba(59,130,246,0.6); color:#e2e8f0; border-radius:6px; cursor:pointer; font-weight:700;';
                extBtn.onclick = () => {
                    playTVChannelFullscreen(channel, streamUrl);
                };

                btnRow.appendChild(retryBtn);
                btnRow.appendChild(extBtn);
                wrap.appendChild(msg);
                wrap.appendChild(hint);
                wrap.appendChild(btnRow);
                playerContent.innerHTML = '';
                playerContent.appendChild(wrap);
            }
            tvEmbeddedPlayerActive = false;
            tvCurrentlyPlaying = null;
            cleanupTvHls();
        }

        function buildStreamCandidates(url) {
            const list = [];
            const hasExt = /\.(m3u8|ts|mp4|mkv|mov|mpg|mpeg|avi)(\?|$)/i.test(url);
            list.push(url);
            if (!hasExt) {
                list.push(url.endsWith('/') ? `${url}index.m3u8` : `${url}.m3u8`);
                list.push(url.endsWith('/') ? `${url}index.ts` : `${url}.ts`);
            }
            const withSlash = url.endsWith('/') ? url : `${url}/`;
            list.push(`${withSlash}index.m3u8`);
            list.push(`${withSlash}playlist.m3u8`);
            list.push(`${withSlash}chunklist.m3u8`);
            list.push(`${withSlash}live.m3u8`);
            // dedupe
            return [...new Set(list)];
        }
        
        function stopTVPlayback() {
            try {
                if (tvVideoElement) {
                    tvVideoElement.pause();
                    tvVideoElement.removeAttribute('src');
                    tvVideoElement.load();
                }
                cleanupTvHls();
                if (window.mediaAPI?.player?.stop) {
                    window.mediaAPI.player.stop().catch(() => {});
                }
            } catch (err) {
                console.warn('[TV] stop playback error:', err);
            }
            const fullscreenBadge = document.getElementById('tvFullscreenBadge');
            const playPauseBtn = document.getElementById('tvPlayPauseBtn');
            if (fullscreenBadge) fullscreenBadge.style.display = 'none';
            if (playPauseBtn) playPauseBtn.style.display = 'none';
            tvCurrentlyPlaying = null;
            tvEmbeddedPlayerActive = false;
            tvStreamRetryAttempts = 0;
            if (tvStreamRetryTimer) {
                clearTimeout(tvStreamRetryTimer);
                tvStreamRetryTimer = null;
            }
        }

        function renderTvEpgPanel(state = {}) {
            const panel = document.getElementById('tvEpgPanel');
            if (!panel) return;
            const { loading, error, channel, programmes } = state;
            const chLabel = channel ? (channel.name || channel.title || '') : '';
            const header = chLabel ? `EPG Â· ${chLabel}` : 'EPG';

            const now = Date.now();
            let current = null;
            let next = null;
            if (Array.isArray(programmes) && programmes.length) {
                for (const p of programmes) {
                    const start = p?.start ? new Date(p.start).getTime() : NaN;
                    const stop = p?.stop ? new Date(p.stop).getTime() : NaN;
                    if (!Number.isFinite(start) || !Number.isFinite(stop)) continue;
                    if (start <= now && now < stop && !current) current = { ...p, start, stop };
                    if (start > now && !next) next = { ...p, start, stop };
                    if (current && next) break;
                }
                if (!current) current = { ...programmes[0], start: new Date(programmes[0].start || programmes[0].startUtc || programmes[0].startDate || now).getTime(), stop: new Date(programmes[0].stop || now).getTime() };
            }

            const fmt = (ms) => {
                if (!Number.isFinite(ms)) return '';
                const d = new Date(ms);
                const h = d.getHours();
                const m = d.getMinutes().toString().padStart(2, '0');
                const ampm = h >= 12 ? 'PM' : 'AM';
                const h12 = h % 12 || 12;
                return `${h12}:${m} ${ampm}`;
            };

            const renderRow = (label, p, accent) => {
                if (!p) return `<div style="font-size: 13px; color: #94a3b8;">No ${label.toLowerCase()} info</div>`;
                const duration = Number.isFinite(p.start) && Number.isFinite(p.stop)
                    ? `${fmt(p.start)} â€“ ${fmt(p.stop)}`
                    : '';
                const title = (p.title || '').trim() || 'No title';
                return `
                    <div style="display:flex; flex-direction:column; gap:2px;">
                        <div style="font-size: 11px; color:${accent}; text-transform: uppercase; letter-spacing: 0.5px;">${label}</div>
                        <div style="font-size: 14px; color: #e2e8f0; font-weight: 600;">${title}</div>
                        <div style="font-size: 12px; color: #cbd5e1;">${duration || ''}</div>
                    </div>
                `;
            };

            panel.innerHTML = `
                <div style="font-size: 12px; color: #94a3b8;">${header}</div>
                ${loading ? `<div style="font-size:13px; color:#cbd5e1;">Loading guide...</div>` : ''}
                ${error ? `<div style="font-size:13px; color:#fca5a5;">${error}</div>` : ''}
                ${!loading && !error ? `
                    <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; align-items:start;">
                        ${renderRow('Now', current, '#38bdf8')}
                        ${renderRow('Next', next, '#a855f7')}
                    </div>
                ` : ''}
            `;
        }

        async function loadTvEpg(channel) {
            if (!channel || !channel.id) {
                renderTvEpgPanel({ channel: null, programmes: [] });
                return;
            }

            const cached = tvEpgCache.get(channel.id);
            const now = Date.now();
            if (cached && now - cached.fetchedAt < TV_EPG_CACHE_MS) {
                renderTvEpgPanel({ channel, programmes: cached.programmes });
                return;
            }

            renderTvEpgPanel({ channel, loading: true });
            try {
                const res = await apiFetch(`${API_BASE}/iptv/epg/channel/${encodeURIComponent(channel.id)}`);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (!data.ok) throw new Error(data.error || 'EPG unavailable');
                const progs = Array.isArray(data.programmes) ? data.programmes : [];
                tvEpgCache.set(channel.id, { programmes: progs, fetchedAt: now });
                renderTvEpgPanel({ channel, programmes: progs });
            } catch (e) {
                console.error('[TV][EPG] load error', e);
                renderTvEpgPanel({ channel, error: e?.message || 'EPG not available' });
            }
        }

        async function setNativeTvZapEnabled(enabled) {
            try {
                const cap = window.Capacitor;
                const plugins = cap && cap.Plugins ? cap.Plugins : null;
                const tvZap = plugins && plugins.TvZap ? plugins.TvZap : null;
                if (tvZap && typeof tvZap.setEnabled === 'function') {
                    await tvZap.setEnabled({ enabled: !!enabled });
                }
            } catch { }
        }

        // Expose TvZapChannel plugin globally for easy access from native code
        try {
            const cap = window.Capacitor;
            if (cap && cap.Plugins && cap.Plugins.TvZapChannel) {
                window.TvZapChannel = cap.Plugins.TvZapChannel;
            }
        } catch { }

        function getLiveChannelAdjacent(dir) {
            try {
                if (tvSelectedMainFolder !== 'Live TV') return null;
                const list = Array.isArray(tvActiveDisplayedChannels) ? tvActiveDisplayedChannels : [];
                if (!list.length) return null;
                const currentId = String(tvCurrentlyPlaying?.id || tvLastSelectedChannelId || '').trim();
                let idx = list.findIndex(c => String(c?.id || '') === currentId);
                if (idx < 0) idx = 0;
                const delta = dir === 'prev' ? -1 : 1;
                let next = idx + delta;
                if (next < 0) next = list.length - 1;
                if (next >= list.length) next = 0;
                return list[next] || null;
            } catch { }
            return null;
        }

        function getLiveChannelById(channelId) {
            try {
                const id = String(channelId || '').trim();
                if (!id) return null;
                const list = Array.isArray(tvActiveDisplayedChannels) ? tvActiveDisplayedChannels : [];
                if (!list.length) return null;
                return list.find(c => String(c?.id || '') === id) || null;
            } catch { }
            return null;
        }

        // Fetch stream data for channel zapping (called from native during playback)
        window.__tvGetNextChannelStream = async (dir) => {
            try {
                const d = dir === 'prev' ? 'prev' : 'next';
                if (currentTopTab !== 'tv') return null;
                if (tvSelectedMainFolder !== 'Live TV') return null;

                const nextChannel = getLiveChannelAdjacent(d);
                if (!nextChannel) return null;

                const nextId = String(nextChannel.id || '').trim();
                tvLastSelectedChannelId = nextId;
                saveTVState();

                // Get stream URL
                let streamUrl = String(nextChannel?.url || '').trim();
                if (!streamUrl) {
                    const streamList = await fetchStreams(nextChannel.id, { title: nextChannel.title || nextChannel.name, type: 'iptv' });
                    if (Array.isArray(streamList) && streamList.length > 0) {
                        streamUrl = String(streamList[0]?.url || '').trim();
                    }
                }

                if (!streamUrl) return null;

                tvCurrentlyPlaying = nextChannel;
                addToRecentlyWatched(nextChannel);

                return {
                    url: streamUrl,
                    title: nextChannel?.name || nextChannel?.title || 'TV Stream',
                    poster: nextChannel?.logo || nextChannel?.poster || '',
                    channelId: nextId
                };
            } catch (err) {
                console.error('[__tvGetNextChannelStream] Error:', err);
                return null;
            }
        };

        // Called from native key handling (Android TV): UP=next channel, DOWN=previous.
        // For VLC Live TV: seamlessly switches channel without exiting player.
        // For ExoPlayer: shows overlay and exits before switching.
        window.__tvNativeZap = async (dir) => {
            console.log('[__tvNativeZap] Called with dir:', dir, 'currentTopTab:', currentTopTab, 'mainFolder:', tvSelectedMainFolder, 'playerActive:', window.__nativePlayerActive);
            try {
                const d = dir === 'prev' ? 'prev' : 'next';
                if (currentTopTab !== 'tv') {
                    console.log('[__tvNativeZap] Not in TV tab');
                    return false;
                }
                if (tvSelectedMainFolder !== 'Live TV') {
                    console.log('[__tvNativeZap] Not in Live TV folder');
                    return false;
                }

                const nextChannel = getLiveChannelAdjacent(d);
                if (!nextChannel) {
                    console.log('[__tvNativeZap] No next channel found');
                    return false;
                }

                console.log('[__tvNativeZap] Next channel:', nextChannel.name || nextChannel.title);
                const nextId = String(nextChannel.id || '').trim();
                tvLastSelectedChannelId = nextId;
                saveTVState();

                // For VLC (native Android): use seamless broadcasting instead of exiting
                if (window.__nativePlayerActive && typeof Capacitor !== 'undefined') {
                    try {
                        const platform = Capacitor.getPlatform();
                        if (platform === 'android') {
                            console.log('[__tvNativeZap] Using VLC broadcast method...');
                            // Get the next channel's stream URL
                            const streamInfo = await __tvGetNextChannelStream(d);
                            if (!streamInfo || !streamInfo.url) {
                                console.warn('[__tvNativeZap] Could not get stream for next channel');
                                return false;
                            }

                            // Switch channel via broadcast (VLC stays open, no overlay)
                            await Capacitor.Plugins.LiveTvPlayer.switchChannel({
                                url: streamInfo.url,
                                title: streamInfo.title || nextChannel.name || nextChannel.title,
                                channelId: String(nextChannel?.id || '').trim()
                            });
                            return true;
                        }
                    } catch (err) {
                        console.warn('[__tvNativeZap] VLC broadcast failed, falling back to exit:', err);
                        // Fall through to ExoPlayer logic
                    }
                }

                // For ExoPlayer or when VLC method fails: exit, then switch (no overlay)
                if ((window.__nativePlayerActive || window.__nativePlayerStarting) && typeof window.exitNativeVideo === 'function') {
                    console.log('[__tvNativeZap] Player active (ExoPlayer), exiting...');
                    window.__tvPendingZapDir = d;
                    window.__tvPendingZapChannelId = nextId;
                    try { await window.exitNativeVideo(); } catch { }
                    return true;
                }

                // Otherwise, just start the next channel.
                console.log('[__tvNativeZap] Starting channel playback (no active player)...');
                await playTVChannel(nextChannel);
                return true;
            } catch (e) {
                console.error('[__tvNativeZap] Error:', e);
                return false;
            }
        };

        function restoreFocusAfterNativePlayback() {
            try {
                // Prefer restoring the element that initiated playback if it's still around.
                const prev = window.__preNativeFocusEl;
                if (prev && prev instanceof HTMLElement && prev.isConnected && isElementVisible(prev)) {
                    try { prev.focus({ preventScroll: true }); } catch { try { prev.focus(); } catch { } }
                    try { prev.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); } catch { }
                    return true;
                }

                // TV: restore focus to the last selected channel.
                if (currentTopTab === 'tv') {
                    const st = loadTVState();
                    const id = String(tvLastSelectedChannelId || tvCurrentlyPlaying?.id || st?.channelId || '').trim();
                    if (id && focusTVChannelById(id)) return true;
                }

                // Non-TV: restore the last focused tile in the current tab.
                try { restoreTabState(currentTopTab); } catch { }
                return true;
            } catch { }
            return false;
        }

        // When native playback exits, restore focus back to where the user was.
        window.addEventListener('nativePlayerExit', async () => {
            console.log('[nativePlayerExit] Player exited');
            try {
                const pendingDir = window.__tvPendingZapDir;
                const pendingId = window.__tvPendingZapChannelId;
                console.log('[nativePlayerExit] Pending zap - dir:', pendingDir, 'id:', pendingId);
                window.__tvPendingZapDir = null;
                window.__tvPendingZapChannelId = null;

                // Disable zap interception in native once playback is gone.
                try { await setNativeTvZapEnabled(false); } catch { }

                if (pendingDir || pendingId) {
                    console.log('[nativePlayerExit] Processing pending zap...');
                    // Keep overlay visible during channel load (will hide when new player starts)
                    const ch = pendingId ? getLiveChannelById(pendingId) : getLiveChannelAdjacent(pendingDir);
                    if (ch) {
                        console.log('[nativePlayerExit] Playing channel:', ch.name || ch.title);
                        await playTVChannel(ch);
                        // Hide overlay after channel starts (with small delay for player to appear)
                        setTimeout(() => hideBootSplash(), 300);
                        return;
                    } else {
                        console.log('[nativePlayerExit] No channel found for zap');
                        hideBootSplash();
                    }
                }

                console.log('[nativePlayerExit] Restoring focus');
                hideBootSplash();
                restoreFocusAfterNativePlayback();
            } catch (e) {
                console.error('[nativePlayerExit] Error:', e);
                hideBootSplash();
            }
        });
        window.addEventListener('nativePlayerEnded', async () => {
            try {
                window.__tvPendingZapDir = null;
                window.__tvPendingZapChannelId = null;
                try { await setNativeTvZapEnabled(false); } catch { }
                hideBootSplash();
                restoreFocusAfterNativePlayback();
            } catch { }
        });

        async function loadTVChannels() {
            const container = document.getElementById('tvChannelsContainer');
            const mainCategoriesList = document.getElementById('tvMainCategoriesList');
            const subfoldersList = document.getElementById('tvSubfoldersList');
            const cacheStatus = document.getElementById('tvCacheStatus');
            
            if (!container || !mainCategoriesList || !subfoldersList) return;
            loadTVFavorites();
            loadTVContinueWatching();
            loadTVRecentlyWatched();
            
            try {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #94a3b8;">Select a subfolder...</p>';
                
                // Try to get from cache first
                let channels = await getTVChannelsFromCache();
                let fromCache = false;
                
                if (!channels) {
                    console.log('[TV] Fetching channels from addon...');
                    // Load IPTV channels through backend (requires IPTV addon installed in backend)
                    const addons = await fetchAddons().catch(() => []);
                    const iptv = addons.find(a => String(a?.manifestId || '') === 'iptv.addon');
                    if (!iptv?.uid) {
                        container.innerHTML = '<p style="grid-column: 1/-1; color: #ef4444; text-align:center;">IPTV addon not installed in backend. Add it in Settings â†’ Addons.</p>';
                        return;
                    }
                    channels = await fetchCatalogItems(iptv.uid, 'iptv', 'iptv-channels');
                    await saveTVChannelsToCache(channels);
                } else {
                    fromCache = true;
                }
                
                if (!channels.length) {
                    container.innerHTML = '<p style="grid-column: 1/-1;">No channels available</p>';
                    return;
                }
                
                tvChannelsCache = channels;
                tvGroupedChannels = groupChannelsByActualCategory(channels);
                tvMainFolders = organizeIntoMainFolders(tvGroupedChannels);
                tvCurrentPage = 0;
                tvSelectedMainFolder = null;
                tvSelectedSubfolder = null;
                
                // Build main folders (left column)
                buildMainFolders(mainCategoriesList);
                
                // Clear subfolders and channels
                subfoldersList.innerHTML = '';
                container.innerHTML = '';
                
                // Restore saved state if available
                const savedState = loadTVState();
                if (savedState && savedState.mainFolder && tvMainFolders[savedState.mainFolder]) {
                    console.log('[TV State] Restoring saved state:', savedState);
                    tvStateToRestore = savedState;
                    // Find and click the main folder button
                    const mainButtons = mainCategoriesList.children;
                    for (let btn of mainButtons) {
                        if (btn.querySelector('span')?.textContent === savedState.mainFolder) {
                            btn.click();
                            
                            // Wait a moment then restore subfolder
                            if (savedState.subfolder) {
                                setTimeout(() => {
                                    const subButtons = subfoldersList.children;
                                    for (let subBtn of subButtons) {
                                        const nameSpan = subBtn.querySelector('span');
                                        if (nameSpan && nameSpan.textContent === savedState.subfolder) {
                                            subBtn.click();
                                            // After subfolder restore, restore focus to last channel (do not auto-play).
                                            if (savedState.channelId) {
                                                setTimeout(() => {
                                                    try { focusTVChannelById(savedState.channelId); } catch { }
                                                }, 150);
                                            }
                                            tvStateToRestore = null;
                                            break;
                                        }
                                    }
                                }, 100);
                            }
                            break;
                        }
                    }
                }
                
                // Show cache status
                cacheStatus.textContent = fromCache ? '(Cached)' : '(Fresh)';
                
            } catch (err) {
                console.error('[loadTVChannels] Error:', err);
                container.innerHTML = '<p style="grid-column: 1/-1; color: #ef4444;">Failed to load channels</p>';
            }
        }
        
        function buildMainFolders(mainCategoriesList) {
            mainCategoriesList.innerHTML = '';
            
            // Add Search entry FIRST
            const searchBtn = document.createElement('div');
            searchBtn.className = 'tv-main-folder-btn';
            searchBtn.tabIndex = 0;
            searchBtn.setAttribute('role', 'button');
            searchBtn.style.cssText = `
                padding: 12px 12px;
                cursor: pointer;
                font-size: 13px;
                color: #cbd5e1;
                background: rgba(59, 130, 246, 0.05);
                border-left: 3px solid transparent;
                transition: all 0.2s ease;
                display: flex;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                gap: 6px;
                user-select: none;
                border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                font-weight: 500;
                text-align: center;
            `;

            const searchIcon = document.createElement('div');
            searchIcon.className = 'tv-folder-icon';
            searchIcon.innerHTML = '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path></svg>';
            searchIcon.style.cssText = `
                transition: all 0.2s ease;
            `;

            const searchNameSpan = document.createElement('span');
            searchNameSpan.className = 'tv-folder-name';
            searchNameSpan.textContent = 'Search';
            searchNameSpan.style.cssText = `
                flex: 1;
                transition: opacity 0.2s ease;
            `;

            searchBtn.appendChild(searchIcon);
            searchBtn.appendChild(searchNameSpan);

            searchBtn.addEventListener('mouseenter', () => {
                if (tvSelectedMainFolder !== 'Search') {
                    searchBtn.style.setProperty('background', 'rgba(59, 130, 246, 0.15)', 'important');
                    searchBtn.style.setProperty('border-left-color', 'rgba(59, 130, 246, 0.5)', 'important');
                }
            });
            searchBtn.addEventListener('mouseleave', () => {
                if (tvSelectedMainFolder !== 'Search') {
                    searchBtn.style.setProperty('background', 'rgba(59, 130, 246, 0.05)', 'important');
                    searchBtn.style.setProperty('border-left-color', 'transparent', 'important');
                }
            });
            searchBtn.addEventListener('click', () => {
                selectMainFolder('Search', searchBtn, mainCategoriesList);
            });
            // Netflix-style TV behavior: focus selects (no OK press).
            searchBtn.addEventListener('focus', () => {
                try {
                    if (tvSelectedMainFolder === 'Search') return;
                    const el = searchBtn;
                    setTimeout(() => {
                        try { if (document.activeElement === el) el.click(); } catch { }
                    }, 120);
                } catch { }
            });
            searchBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    searchBtn.click();
                }
            });

            mainCategoriesList.appendChild(searchBtn);
            
            // Icon mapping for folders with modern SVG icons
            const folderIcons = {
                'Live TV': '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline></svg>',
                'Movies': '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line></svg>',
                'Series': '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>'
            };
            
            Object.entries(tvMainFolders).forEach(([folderName, subfolders]) => {
                const count = Object.values(subfolders).reduce((total, channels) => total + channels.length, 0);
                
                const btn = document.createElement('div');
                btn.className = 'tv-main-folder-btn';
                btn.tabIndex = 0;
                btn.setAttribute('role', 'button');
                btn.style.cssText = `
                    padding: 12px 12px;
                    cursor: pointer;
                    font-size: 13px;
                    color: #cbd5e1;
                    background: rgba(59, 130, 246, 0.05);
                    border-left: 3px solid transparent;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    flex-direction: column;
                    gap: 6px;
                    user-select: none;
                    border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                    font-weight: 500;
                    text-align: center;
                `;
                
                const icon = document.createElement('div');
                icon.className = 'tv-folder-icon';
                icon.innerHTML = folderIcons[folderName] || '<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
                icon.style.cssText = `
                    transition: all 0.2s ease;
                `;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'tv-folder-name';
                nameSpan.textContent = folderName;
                nameSpan.style.cssText = `
                    flex: 1;
                    transition: opacity 0.2s ease;
                `;
                
                const countSpan = document.createElement('span');
                countSpan.className = 'tv-folder-count';
                countSpan.textContent = count;
                countSpan.style.cssText = `
                    font-size: 10px;
                    background: rgba(59, 130, 246, 0.5);
                    padding: 3px 6px;
                    border-radius: 3px;
                    color: #93c5fd;
                    font-weight: 600;
                    transition: opacity 0.2s ease;
                `;
                
                btn.appendChild(icon);
                btn.appendChild(nameSpan);
                btn.appendChild(countSpan);
                
                btn.addEventListener('mouseenter', () => {
                    if (tvSelectedMainFolder !== folderName) {
                        btn.style.setProperty('background', 'rgba(59, 130, 246, 0.15)', 'important');
                        btn.style.setProperty('border-left-color', 'rgba(59, 130, 246, 0.5)', 'important');
                    }
                });
                
                btn.addEventListener('mouseleave', () => {
                    if (tvSelectedMainFolder !== folderName) {
                        btn.style.setProperty('background', 'rgba(59, 130, 246, 0.05)', 'important');
                        btn.style.setProperty('border-left-color', 'transparent', 'important');
                    }
                });
                
                btn.addEventListener('click', () => {
                    selectMainFolder(folderName, btn, mainCategoriesList);
                    
                // Netflix-style TV behavior: focus selects (no OK press).
                btn.addEventListener('focus', () => {
                    try {
                        if (tvSelectedMainFolder === folderName) return;
                        const el = btn;
                        setTimeout(() => {
                            try { if (document.activeElement === el) el.click(); } catch { }
                        }, 120);
                    } catch { }
                });
                    // Collapse main categories when a folder is selected
                    const mainCategoriesDiv = document.getElementById('tvMainCategories');
                    mainCategoriesDiv.style.width = '70px';
                    
                    // Hide text elements in collapsed state
                    const header = document.getElementById('tvMainCategoriesHeader');
                    if (header) header.style.opacity = '0';
                    
                    const allBtns = mainCategoriesList.querySelectorAll('.tv-main-folder-btn');
                    allBtns.forEach(b => {
                        const name = b.querySelector('.tv-folder-name');
                        const count = b.querySelector('.tv-folder-count');
                        if (name) name.style.opacity = '0';
                        if (count) count.style.opacity = '0';
                    });
                });
                btn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        btn.click();
                    }
                });
                
                mainCategoriesList.appendChild(btn);
            });
            
            // Add hover expand/collapse for main categories sidebar
            const mainCategoriesDiv = document.getElementById('tvMainCategories');
            mainCategoriesDiv.addEventListener('mouseenter', () => {
                // Expand on hover
                mainCategoriesDiv.style.width = '180px';
                const header = document.getElementById('tvMainCategoriesHeader');
                if (header) header.style.opacity = '1';
                
                const allBtns = mainCategoriesList.querySelectorAll('.tv-main-folder-btn');
                allBtns.forEach(b => {
                    const name = b.querySelector('.tv-folder-name');
                    const count = b.querySelector('.tv-folder-count');
                    if (name) name.style.opacity = '1';
                    if (count) count.style.opacity = '1';
                });
            });
            
            mainCategoriesDiv.addEventListener('mouseleave', () => {
                // Collapse back if a folder is selected
                if (tvSelectedMainFolder) {
                    mainCategoriesDiv.style.width = '70px';
                    const header = document.getElementById('tvMainCategoriesHeader');
                    if (header) header.style.opacity = '0';
                    
                    const allBtns = mainCategoriesList.querySelectorAll('.tv-main-folder-btn');
                    allBtns.forEach(b => {
                        const name = b.querySelector('.tv-folder-name');
                        const count = b.querySelector('.tv-folder-count');
                        if (name) name.style.opacity = '0';
                        if (count) count.style.opacity = '0';
                    });
                }
            });
        }
        
        function selectMainFolder(folderName, btnElement, mainCategoriesList) {
            tvSelectedMainFolder = folderName;
            tvSelectedSubfolder = null;
            
            // Show/hide player container - only visible for Live TV
            const playerContainer = document.getElementById('tvPlayerContainer');
            if (playerContainer) {
                playerContainer.style.display = folderName === 'Live TV' ? 'flex' : 'none';
            }
            
            // Build subfolders for selected main folder
            const subfoldersList = document.getElementById('tvSubfoldersList');
            const subfolders = tvMainFolders[folderName];
            if (folderName === 'Search') {
                renderTVSearchUI();
            } else if (subfolders) {
                buildSubfolders(subfoldersList, subfolders, folderName);
                // Auto-select first subfolder (Continue Watching if it exists, otherwise first item)
                setTimeout(() => {
                    const firstSub = subfoldersList.firstElementChild;
                    if (firstSub) firstSub.click();
                }, 0);
            }
            
            // Update all main folder buttons - reset to default colors
            Array.from(mainCategoriesList.children).forEach(el => {
                el.style.setProperty('background', 'rgba(59, 130, 246, 0.05)', 'important');
                el.style.setProperty('border-left-color', 'transparent', 'important');
                el.style.setProperty('color', '#cbd5e1', 'important');
            });
            
            // Highlight selected - only change colors, not dimensions
            btnElement.style.setProperty('background', 'rgba(59, 130, 246, 0.9)', 'important');
            btnElement.style.setProperty('border-left-color', '#3b82f6', 'important');
            btnElement.style.setProperty('color', '#e2e8f0', 'important');
            
            // Save state
            saveTVState();
        }
        
        function buildSubfolders(subfoldersList, subfolders, mainFolderName) {
            subfoldersList.innerHTML = '';

            const type = getMainTypeFromFolder(mainFolderName);
            
            // Determine if this is Live TV or Movies/Series
            const isLiveTV = mainFolderName === 'Live TV';
            const watchLabel = isLiveTV ? 'Recently Watched' : 'Continue Watching';
            const watchList = isLiveTV ? getRecentlyWatchedList() : getContinueWatchingList(type);
            
            // Add Continue Watching / Recently Watched button
            const continueBtn = document.createElement('div');
            continueBtn.dataset.continue = 'true';
            continueBtn.tabIndex = 0;
            continueBtn.setAttribute('role', 'button');
            continueBtn.style.cssText = `
                padding: 10px 12px;
                cursor: pointer;
                font-size: 12px;
                color: #3b82f6;
                background: rgba(59, 130, 246, 0.08);
                border-left: 3px solid rgba(59, 130, 246, 0.5);
                transition: all 0.2s ease;
                display: flex;
                justify-content: space-between;
                align-items: center;
                user-select: none;
                border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                font-weight: 600;
            `;
            
            const continueLabel = document.createElement('span');
            continueLabel.textContent = isLiveTV ? 'â± Recently Watched' : 'â–¶ Continue Watching';
            
            const continueCount = document.createElement('span');
            continueCount.textContent = watchList.length;
            continueCount.style.cssText = `
                font-size: 10px;
                background: rgba(59, 130, 246, 0.7);
                padding: 2px 6px;
                border-radius: 3px;
                color: #e2e8f0;
                font-weight: 700;
            `;
            
            continueBtn.appendChild(continueLabel);
            if (watchList.length > 0) {
                continueBtn.appendChild(continueCount);
            }
            
            continueBtn.addEventListener('mouseenter', () => {
                if (tvSelectedSubfolder !== watchLabel) {
                    continueBtn.style.background = 'rgba(59, 130, 246, 0.15)';
                    continueBtn.style.borderLeftColor = 'rgba(59, 130, 246, 0.8)';
                }
            });
            continueBtn.addEventListener('mouseleave', () => {
                if (tvSelectedSubfolder !== watchLabel) {
                    continueBtn.style.background = 'rgba(59, 130, 246, 0.08)';
                    continueBtn.style.borderLeftColor = 'rgba(59, 130, 246, 0.5)';
                }
            });
            continueBtn.addEventListener('click', () => {
                selectSubfolder(watchLabel, watchList, continueBtn, subfoldersList);
            });
            // Netflix-style TV behavior: focus selects (no OK press).
            continueBtn.addEventListener('focus', () => {
                try {
                    if (tvSelectedSubfolder === watchLabel) return;
                    const el = continueBtn;
                    setTimeout(() => {
                        try { if (document.activeElement === el) el.click(); } catch { }
                    }, 120);
                } catch { }
            });
            continueBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    continueBtn.click();
                }
            });
            
            // Always add Continue Watching / Recently Watched button (even if empty)
            subfoldersList.appendChild(continueBtn);

            const favCount = tvFavorites[type]?.length || 0;
            const favBtn = document.createElement('div');
            favBtn.tabIndex = 0;
            favBtn.setAttribute('role', 'button');
            favBtn.style.cssText = `
                padding: 10px 12px;
                cursor: pointer;
                font-size: 12px;
                color: #cbd5e1;
                background: rgba(59, 130, 246, 0.08);
                border-left: 3px solid transparent;
                transition: all 0.2s ease;
                display: flex;
                justify-content: space-between;
                align-items: center;
                user-select: none;
                border-bottom: 1px solid rgba(59, 130, 246, 0.12);
                font-weight: 700;
            `;
            const favName = document.createElement('span');
            favName.textContent = 'Favorites';
            favName.style.flex = '1';
            favName.style.marginRight = '8px';
            const favCountSpan = document.createElement('span');
            favCountSpan.textContent = favCount;
            favCountSpan.style.cssText = `
                font-size: 10px;
                background: rgba(59, 130, 246, 0.7);
                padding: 3px 6px;
                border-radius: 3px;
                color: #e2e8f0;
                font-weight: 700;
                flex-shrink: 0;
            `;
            favBtn.appendChild(favName);
            favBtn.appendChild(favCountSpan);
            favBtn.addEventListener('mouseenter', () => {
                if (tvSelectedSubfolder !== 'Favorites') {
                    favBtn.style.background = 'rgba(59, 130, 246, 0.16)';
                    favBtn.style.borderLeftColor = 'rgba(59, 130, 246, 0.6)';
                }
            });
            favBtn.addEventListener('mouseleave', () => {
                if (tvSelectedSubfolder !== 'Favorites') {
                    favBtn.style.background = 'rgba(59, 130, 246, 0.08)';
                    favBtn.style.borderLeftColor = 'transparent';
                }
            });
            favBtn.addEventListener('click', () => {
                selectSubfolder('Favorites', tvFavorites[type] || [], favBtn, subfoldersList);
            });
            // Do NOT auto-open subfolders on focus (user wants browsing highlight only).
            favBtn.addEventListener('focus', () => {
                try {
                    if (tvSelectedSubfolder === 'Favorites') return;
                    favBtn.style.background = 'rgba(59, 130, 246, 0.16)';
                    favBtn.style.borderLeftColor = 'rgba(59, 130, 246, 0.6)';
                } catch { }
            });
            favBtn.addEventListener('blur', () => {
                try {
                    if (tvSelectedSubfolder === 'Favorites') return;
                    favBtn.style.background = 'rgba(59, 130, 246, 0.08)';
                    favBtn.style.borderLeftColor = 'transparent';
                } catch { }
            });
            favBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    favBtn.click();
                }
            });
            subfoldersList.appendChild(favBtn);
            
            const sortedSubfolders = Object.entries(subfolders).sort((a, b) => a[0].localeCompare(b[0]));
            
            sortedSubfolders.forEach(([subfolderName, channels]) => {
                const btn = document.createElement('div');
                btn.tabIndex = 0;
                btn.setAttribute('role', 'button');
                btn.style.cssText = `
                    padding: 10px 12px;
                    cursor: pointer;
                    font-size: 12px;
                    color: #cbd5e1;
                    background: rgba(59, 130, 246, 0.05);
                    border-left: 3px solid transparent;
                    transition: all 0.2s ease;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    user-select: none;
                    border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                `;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = subfolderName;
                nameSpan.style.flex = '1';
                nameSpan.style.marginRight = '8px';
                nameSpan.style.wordBreak = 'break-word';
                
                const countSpan = document.createElement('span');
                countSpan.textContent = channels.length;
                countSpan.style.cssText = `
                    font-size: 10px;
                    background: rgba(59, 130, 246, 0.5);
                    padding: 3px 6px;
                    border-radius: 3px;
                    color: #93c5fd;
                    font-weight: 600;
                    flex-shrink: 0;
                `;
                
                btn.appendChild(nameSpan);
                btn.appendChild(countSpan);
                
                btn.addEventListener('mouseenter', () => {
                    if (tvSelectedSubfolder !== subfolderName) {
                        btn.style.background = 'rgba(59, 130, 246, 0.15)';
                        btn.style.borderLeftColor = 'rgba(59, 130, 246, 0.5)';
                    }
                });
                
                btn.addEventListener('mouseleave', () => {
                    if (tvSelectedSubfolder !== subfolderName) {
                        btn.style.background = 'rgba(59, 130, 246, 0.05)';
                        btn.style.borderLeftColor = 'transparent';
                    }
                });
                
                btn.addEventListener('click', () => {
                    selectSubfolder(subfolderName, channels, btn, subfoldersList);
                });
                // Do NOT auto-open subfolders on focus (user wants browsing highlight only).
                btn.addEventListener('focus', () => {
                    try {
                        if (tvSelectedSubfolder === subfolderName) return;
                        btn.style.background = 'rgba(59, 130, 246, 0.15)';
                        btn.style.borderLeftColor = 'rgba(59, 130, 246, 0.5)';
                    } catch { }
                });
                btn.addEventListener('blur', () => {
                    try {
                        if (tvSelectedSubfolder === subfolderName) return;
                        btn.style.background = 'rgba(59, 130, 246, 0.05)';
                        btn.style.borderLeftColor = 'transparent';
                    } catch { }
                });
                btn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        btn.click();
                    }
                });
                
                subfoldersList.appendChild(btn);
            });
        }
        
        function selectSubfolder(subfolderName, channels, btnElement, subfoldersList) {
            tvSelectedSubfolder = subfolderName;
            tvCurrentPage = 0;
            const mainType = getMainTypeFromFolder(tvSelectedMainFolder);
            const isFavorites = subfolderName === 'Favorites';
            const isContinue = subfolderName === 'Continue Watching';
            const isRecentlyWatched = subfolderName === 'Recently Watched';
            let channelsToUse = channels;
            if (isFavorites) channelsToUse = tvFavorites[mainType] || [];
            if (isContinue) {
                const items = getContinueWatchingList(mainType);
                channelsToUse = items.map(item => item.channel || item);
            }
            if (isRecentlyWatched) {
                const items = getRecentlyWatchedList();
                channelsToUse = items.map(item => item.channel || item);
            }
            
            // Update all subfolder buttons
            Array.from(subfoldersList.children).forEach(el => {
                el.style.background = 'rgba(59, 130, 246, 0.05)';
                el.style.borderLeftColor = 'transparent';
                el.style.color = '#cbd5e1';
            });
            
            // Highlight selected
            btnElement.style.background = 'rgba(59, 130, 246, 0.9)';
            btnElement.style.borderLeftColor = '#3b82f6';
            btnElement.style.color = '#e2e8f0';
            
            // Display channels
            displayTVCategoryChannels(subfolderName, channelsToUse);
            
            // Save state
            saveTVState();
        }

        function styleFavoriteButton(btn, isFav) {
            btn.textContent = isFav ? 'â˜…' : 'â˜†';
            btn.title = isFav ? 'Remove from Favorites' : 'Add to Favorites';
            btn.style.background = isFav ? 'linear-gradient(135deg, #facc15, #f59e0b)' : 'rgba(15,23,42,0.9)';
            btn.style.color = isFav ? '#0f172a' : '#fbbf24';
            btn.style.borderColor = isFav ? 'rgba(250,204,21,0.9)' : 'rgba(59,130,246,0.5)';
            btn.style.boxShadow = isFav ? '0 0 0 1px rgba(250,204,21,0.35)' : 'none';
        }

        function normalizeSeriesTitle(rawName) {
            if (!rawName) return 'Unknown';
            let t = rawName;
            t = t.replace(/\bS\d{1,2}\s*E\d{1,3}\b/ig, ''); // S01E01 or S01 E01
            t = t.replace(/\bS\d{1,2}\b/ig, '');           // S01
            t = t.replace(/\bE\d{1,3}\b/ig, '');           // E01
            t = t.replace(/\b\d{1,2}x\d{1,3}\b/ig, '');    // 1x01
            t = t.replace(/\bSEASON\s*\d+\b/ig, '');
            t = t.replace(/\bEP(ISODE)?\.?\s*\d+\b/ig, '');
            t = t.replace(/[_\.\-]/g, ' ');
            t = t.replace(/\s+/g, ' ').trim();
            return t || 'Unknown';
        }

        function groupSeriesItems(items) {
            const seriesMap = {};

            items.forEach((ch) => {
                const key = normalizeSeriesTitle(ch.name || ch.title);
                const episodesArr = Array.isArray(ch.tvEpisodesLocal) && ch.tvEpisodesLocal.length
                    ? ch.tvEpisodesLocal
                    : [{ displayTitle: ch.name || ch.title || 'Episode', channel: ch }];

                if (!seriesMap[key]) {
                    seriesMap[key] = {
                        title: key,
                        name: key,
                        poster: ch.poster || ch.logo || '',
                        tvEpisodesLocal: []
                    };
                }

                episodesArr.forEach((ep) => {
                    seriesMap[key].tvEpisodesLocal.push({
                        displayTitle: ep.displayTitle || ep.channel?.name || ep.channel?.title || ch.name || ch.title || 'Episode',
                        channel: ep.channel || ch
                    });
                });
            });

            return Object.values(seriesMap);
        }
        
        function displayTVCategoryChannels(subfolderName, channels) {
            const container = document.getElementById('tvChannelsContainer');
            const titleEl = document.getElementById('tvCategoryTitle');
            const countEl = document.getElementById('tvChannelCount');
            
            // Skip if in Search view; search renders its own layout
            if (tvSelectedMainFolder === 'Search') {
                return;
            }

            titleEl.textContent = subfolderName;
            const isRecentlyWatched = subfolderName === 'Recently Watched';
            const isContinueWatching = subfolderName === 'Continue Watching';
            countEl.textContent = `${channels.length} ${(isContinueWatching || isRecentlyWatched) ? 'items' : 'channels'}`;
            
            // Clear container
            container.innerHTML = '';
            
            // Show empty state for Continue Watching
            if (isContinueWatching && channels.length === 0) {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #94a3b8; padding: 40px 20px; font-size: 14px;">No continue watching items yet. Start watching something to see it here!</p>';
                return;
            }
            
            // Show empty state for Recently Watched
            if (isRecentlyWatched && channels.length === 0) {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #94a3b8; padding: 40px 20px; font-size: 14px;">No recently watched channels yet. Start watching Live TV to see them here!</p>';
                return;
            }
            
            const isLive = tvSelectedMainFolder === 'Live TV';
            const isSeriesFolder = tvSelectedMainFolder === 'Series';

            // Keep a reference to the currently displayed list for channel zapping.
            try {
                tvActiveDisplayedChannels = isLive ? (Array.isArray(channels) ? channels.slice() : []) : [];
            } catch { }
            
            if (isLive) {
                const grid = document.createElement('div');
                grid.style.cssText = `
                    display: grid;
                    grid-template-columns: 40px 50px auto 100px;
                    gap: 0;
                    border: 1px solid rgba(59, 130, 246, 0.2);
                    border-radius: 6px;
                    overflow: hidden;
                `;
                
                channels.forEach((channel, idx) => {
                    const numCell = document.createElement('div');
                    numCell.textContent = (idx + 1).toString();
                    numCell.style.cssText = `
                        padding: 6px 4px;
                        text-align: center;
                        color: #94a3b8;
                        font-size: 11px;
                        font-weight: 600;
                        background: ${idx % 2 === 0 ? 'rgba(15, 23, 42, 0.5)' : 'rgba(30, 41, 59, 0.5)'};
                        border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const logoCell = document.createElement('div');
                    logoCell.style.cssText = `
                        padding: 4px;
                        background: ${idx % 2 === 0 ? 'rgba(15, 23, 42, 0.5)' : 'rgba(30, 41, 59, 0.5)'};
                        border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    if (channel.poster) {
                        const img = document.createElement('img');
                        img.src = channel.poster;
                        img.loading = 'lazy';
                        img.style.cssText = `
                            width: 32px;
                            height: 32px;
                            object-fit: contain;
                            border-radius: 3px;
                        `;
                        img.onerror = () => {
                            img.style.display = 'none';
                        };
                        logoCell.appendChild(img);
                    }
                    
                    const nameCell = document.createElement('div');
                    nameCell.textContent = channel.name || channel.title || 'Unknown';
                    nameCell.tabIndex = 0;
                    nameCell.setAttribute('role', 'button');
                    try { nameCell.dataset.tvChannelId = String(channel.id || ''); } catch { }
                    try {
                        nameCell.dataset.tvDpadKind = 'channel-name';
                        nameCell.dataset.tvDpadIndex = String(idx);
                    } catch { }
                    nameCell.style.cssText = `
                        padding: 6px 8px;
                        font-weight: 600;
                        font-size: 12px;
                        color: #e2e8f0;
                        background: ${idx % 2 === 0 ? 'rgba(15, 23, 42, 0.5)' : 'rgba(30, 41, 59, 0.5)'};
                        border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        justify-content: space-between;
                        cursor: pointer;
                        transition: all 0.15s ease;
                    `;
                    nameCell.title = channel.name || channel.title;
                    nameCell.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            playTVChannel(channel);
                        }
                    });
                    nameCell.addEventListener('focus', () => {
                        try {
                            tvLastSelectedChannelId = String(channel.id || '');
                            saveTVState();
                            loadTvEpg(channel);
                        } catch { }
                    });

                    const favType = 'live';
                    const favBtn = document.createElement('button');
                    favBtn.tabIndex = 0;
                    try {
                        favBtn.dataset.tvDpadKind = 'channel-fav';
                        favBtn.dataset.tvDpadIndex = String(idx);
                        favBtn.dataset.tvChannelId = String(channel.id || '');
                    } catch { }
                    favBtn.style.cssText = `
                        margin-left: 6px;
                        background: rgba(15,23,42,0.9);
                        color: #fbbf24;
                        border: 1px solid rgba(59,130,246,0.5);
                        border-radius: 3px;
                        font-size: 11px;
                        width: 22px;
                        height: 22px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                    `;
                    styleFavoriteButton(favBtn, isFavorite(channel, favType));

                    const toggleFavOnly = (ev) => {
                        try { ev.preventDefault(); } catch { }
                        try { ev.stopPropagation(); } catch { }
                        toggleFavorite(channel, favType);
                        styleFavoriteButton(favBtn, isFavorite(channel, favType));
                    };

                    // Ensure clicking/tapping the star NEVER triggers the row's play handler.
                    favBtn.addEventListener('pointerdown', (e) => { try { e.stopPropagation(); } catch { } });
                    favBtn.addEventListener('mousedown', (e) => { try { e.stopPropagation(); } catch { } });
                    favBtn.addEventListener('click', (e) => {
                        toggleFavOnly(e);
                    });

                    // Remote/keyboard: Enter/Space toggles favorite when star is focused.
                    favBtn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            toggleFavOnly(e);
                        }
                    });
                    nameCell.appendChild(favBtn);
                    
                    const now = new Date();
                    const currentHour = now.getHours();
                    
                    const formatTime = (h) => {
                        const ampm = h >= 12 ? 'PM' : 'AM';
                        const hour12 = h % 12 || 12;
                        return `${hour12}${ampm}`;
                    };
                    
                    const timeNow = formatTime(currentHour);
                    
                    const timeCell = document.createElement('div');
                    timeCell.textContent = timeNow;
                    timeCell.style.cssText = `
                        padding: 6px 8px;
                        font-size: 11px;
                        color: #94a3b8;
                        background: ${idx % 2 === 0 ? 'rgba(15, 23, 42, 0.5)' : 'rgba(30, 41, 59, 0.5)'};
                        border-bottom: 1px solid rgba(59, 130, 246, 0.1);
                        border-left: 1px solid rgba(59, 130, 246, 0.1);
                        cursor: pointer;
                        transition: all 0.15s ease;
                        text-align: center;
                        font-weight: 500;
                    `;
                    
                    const cells = [numCell, logoCell, nameCell, timeCell];
                    cells.forEach(cell => {
                        cell.addEventListener('mouseenter', () => {
                            cells.forEach(c => c.style.background = 'rgba(59, 130, 246, 0.2)');
                        });
                        cell.addEventListener('mouseleave', () => {
                            const bg = idx % 2 === 0 ? 'rgba(15, 23, 42, 0.5)' : 'rgba(30, 41, 59, 0.5)';
                            cells.forEach(c => c.style.background = bg);
                        });
                        cell.addEventListener('click', (e) => {
                            // Clicking the favorite button should not start playback.
                            try {
                                if (e && e.target && e.target.closest && e.target.closest('button')) return;
                            } catch { }
                            playTVChannel(channel);
                        });
                    });
                    
                    grid.appendChild(numCell);
                    grid.appendChild(logoCell);
                    grid.appendChild(nameCell);
                    grid.appendChild(timeCell);
                });
                
                container.appendChild(grid);
                return;
            }
            
            // Poster grid for Movies or Series
            const cardGrid = document.createElement('div');
            cardGrid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
                gap: 10px;
                padding: 8px 6px 16px 6px;
            `;

            const buildCard = (item, episodes = null) => {
                const baseItem = episodes ? { ...item, tvEpisodesLocal: episodes } : item;
                const continueData = isContinueWatching ? tvContinueWatching[tvSelectedMainFolder.toLowerCase()]?.[item.id] : null;

                const card = document.createElement('div');
                card.classList.add('tv-card');
                card.tabIndex = 0;
                card.setAttribute('role', 'button');
                try { card.dataset.tvChannelId = String(item?.id || ''); } catch { }
                card.style.cssText = `
                    background: rgba(15, 23, 42, 0.6);
                    border: 1px solid rgba(59, 130, 246, 0.2);
                    border-radius: 8px;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    position: relative;
                    cursor: pointer;
                    transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
                `;

                // TV -> Movies/Series: short OK clicks the tile; long OK opens a small favorites dropdown.
                // For Series, only enable this for the "normal" show tiles (not Continue Watching / Recently Watched episode tiles).
                const useHoldFavMenu =
                    (isTvNavMode && typeof isTvNavMode === 'function' && isTvNavMode()) &&
                    (
                        (tvSelectedMainFolder === 'Movies') ||
                        (tvSelectedMainFolder === 'Series' && !isContinueWatching && !isRecentlyWatched)
                    );
                if (useHoldFavMenu) {
                    const HOLD_MS = 520;

                    const onKeyDown = (e) => {
                        if (e.key !== 'Enter') return;
                        // Prevent any other Enter->click synthesizers.
                        try { e.preventDefault(); } catch { }
                        try { e.stopPropagation(); } catch { }
                        try { e.stopImmediatePropagation(); } catch { }

                        if (card.__tvHoldArmed) return;
                        card.__tvHoldArmed = true;
                        card.__tvHoldTriggered = false;
                        card.__tvHoldTimer = setTimeout(() => {
                            try {
                                card.__tvHoldTriggered = true;
                                const ft = (tvSelectedMainFolder === 'Series') ? 'series' : 'movies';
                                openTvHoldFavoriteMenu({ item: baseItem, favType: ft, anchorEl: card });
                            } catch { }
                        }, HOLD_MS);

                    };

                    const onKeyUp = (e) => {
                        if (e.key !== 'Enter') return;
                        // Prevent any other Enter->click synthesizers on release.
                        try { e.preventDefault(); } catch { }
                        try { e.stopPropagation(); } catch { }
                        try { e.stopImmediatePropagation(); } catch { }

                        const t = card.__tvHoldTimer;
                        card.__tvHoldTimer = null;
                        card.__tvHoldArmed = false;
                        if (t) {
                            try { clearTimeout(t); } catch { }
                        }

                        // If long-press fired, do nothing on release.
                        if (card.__tvHoldTriggered) {
                            try { e.preventDefault(); e.stopPropagation(); } catch { }
                            return;
                        }

                        // Short press: normal click.
                        try { card.click(); } catch { }

                    };

                    // Capture phase so we beat any other listeners attached to this element.
                    card.addEventListener('keydown', onKeyDown, true);
                    card.addEventListener('keyup', onKeyUp, true);
                } else {
                    card.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            card.click();
                        }
                    });
                }
                card.addEventListener('focus', () => {
                    try {
                        tvLastSelectedChannelId = String(item?.id || '');
                        saveTVState();
                    } catch { }
                });

                const poster = document.createElement('div');
                poster.style.cssText = `
                    position: relative;
                    width: 100%;
                    padding-top: 150%;
                    background: linear-gradient(135deg, #1e293b, #0f172a);
                `;

                if (item.poster) {
                    const img = document.createElement('img');
                    img.src = item.poster;
                    img.loading = 'lazy';
                    img.style.cssText = `
                        position: absolute;
                        top: 0; left: 0; right: 0; bottom: 0;
                        width: 100%; height: 100%;
                        object-fit: cover;
                    `;
                    img.onerror = () => { img.style.display = 'none'; };
                    poster.appendChild(img);
                }

                if (continueData && continueData.progress !== undefined) {
                    const progressBar = document.createElement('div');
                    progressBar.style.cssText = `
                        position: absolute;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        height: 3px;
                        background: rgba(0,0,0,0.6);
                    `;
                    const progressFill = document.createElement('div');
                    const progressPercent = Math.round(Math.min(100, Math.max(0, continueData.progress * 100)));
                    progressFill.style.cssText = `
                        height: 100%;
                        width: ${progressPercent}%;
                        background: linear-gradient(90deg, #3b82f6, #60a5fa);
                        transition: width 0.3s ease;
                    `;
                    progressBar.appendChild(progressFill);
                    poster.appendChild(progressBar);
                    console.log('[TV Card] Progress bar shown:', progressPercent + '%', 'for', item.name || item.title);
                }

                const title = document.createElement('div');
                title.textContent = item.name || item.title || 'Untitled';
                title.style.cssText = `
                    padding: 6px;
                    font-size: 11px;
                    font-weight: 600;
                    color: #e2e8f0;
                    min-height: 36px;
                    display: flex;
                    align-items: center;
                `;
                title.title = item.name || item.title || '';

                // Favorites button:
                // - TV -> Movies/Series: removed (favorites handled via long-press OK menu)
                // - Otherwise: keep the star button
                if (!useHoldFavMenu) {
                    const favType = isSeriesFolder ? 'series' : 'movies';
                    const favBtn = document.createElement('button');
                    favBtn.style.cssText = `
                        position: absolute;
                        top: 4px;
                        right: 4px;
                        background: rgba(15,23,42,0.9);
                        color: #fbbf24;
                        border: 1px solid rgba(59,130,246,0.5);
                        border-radius: 50%;
                        width: 22px;
                        height: 22px;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        z-index: 2;
                        font-size: 10px;
                    `;
                    styleFavoriteButton(favBtn, isFavorite(baseItem, favType));
                    favBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFavorite(baseItem, favType);
                        styleFavoriteButton(favBtn, isFavorite(baseItem, favType));
                    });

                    card.appendChild(favBtn);
                }
                card.appendChild(poster);
                card.appendChild(title);

                card.addEventListener('mouseenter', () => {
                    card.style.transform = 'translateY(-3px)';
                    card.style.boxShadow = '0 6px 18px rgba(0,0,0,0.35)';
                    card.style.borderColor = 'rgba(59, 130, 246, 0.5)';
                });
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'translateY(0)';
                    card.style.boxShadow = 'none';
                    card.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                });

                if (!isSeriesFolder) {
                    card.addEventListener('click', () => {
                        const resumeTime = isContinueWatching && continueData?.currentTime ? continueData.currentTime : 0;
                        console.log('[TV Card Click] Playing with resumeTime:', resumeTime, 'isContinueWatching:', isContinueWatching);
                        playTVChannel(baseItem, { resumeTime });
                    });
                } else {
                    // Series: if in Continue Watching, play the episode directly. Otherwise open episode selection.
                    card.addEventListener('click', () => {
                        if (isContinueWatching && continueData?.channel) {
                            // Resume the specific episode directly
                            const resumeTime = continueData.currentTime || 0;
                            console.log('[TV Series Click] Continue Watching - Playing episode directly with resumeTime:', resumeTime);
                            playTVChannel(continueData.channel, { resumeTime });
                        } else {
                            // Normal series click: open episode selection
                            const slug = (baseItem.title || baseItem.name || 'show').toLowerCase().replace(/[^a-z0-9]+/g, '-');
                            const tvItem = {
                                id: `tv-local-${slug}`,
                                title: baseItem.title || baseItem.name,
                                name: baseItem.name || baseItem.title,
                                poster: baseItem.poster,
                                type: 'series',
                                source: 'tv-local',
                                tvEpisodesLocal: episodes || []
                            };
                            openDetails(tvItem);
                        }
                    });
                }

                return card;
            };

            if (isSeriesFolder && !isContinueWatching && !isRecentlyWatched) {
                // Group series by title for normal folders, but NOT for Continue Watching or Recently Watched
                const grouped = groupSeriesItems(channels);

                grouped.forEach((show) => {
                    cardGrid.appendChild(buildCard(show, show.tvEpisodesLocal));
                });
            } else {
                // For Continue Watching, Recently Watched, or Movies, display each item individually
                channels.forEach((channel) => {
                    cardGrid.appendChild(buildCard(channel));
                });
            }

            container.appendChild(cardGrid);
        }

        // TV Search History Management
        function getTVSearchHistory() {
            try {
                const history = localStorage.getItem('tvSearchHistory');
                return history ? JSON.parse(history) : [];
            } catch {
                return [];
            }
        }

        function saveTVSearchHistory(history) {
            try {
                localStorage.setItem('tvSearchHistory', JSON.stringify(history));
            } catch {}
        }

        function addToTVSearchHistory(query) {
            if (!query || !query.trim()) return;
            const q = query.trim();
            let history = getTVSearchHistory();
            // Remove if already exists
            history = history.filter(item => item !== q);
            // Add to front
            history.unshift(q);
            // Keep only last 10
            history = history.slice(0, 10);
            saveTVSearchHistory(history);
        }

        function removeFromTVSearchHistory(query) {
            let history = getTVSearchHistory();
            history = history.filter(item => item !== query);
            saveTVSearchHistory(history);
        }

        function renderTVSearchUI(reset = false) {
            const subfoldersList = document.getElementById('tvSubfoldersList');
            const container = document.getElementById('tvChannelsContainer');
            if (!subfoldersList || !container) return;

            subfoldersList.innerHTML = '';

            const searchWrap = document.createElement('div');
            searchWrap.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 10px;
                width: 100%;
            `;

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Search IPTV (Live, Movies, Series)';
            input.style.cssText = `
                width: 100%;
                padding: 10px 12px;
                border-radius: 6px;
                border: 1px solid rgba(59, 130, 246, 0.4);
                background: rgba(15, 23, 42, 0.6);
                color: #e2e8f0;
                outline: none;
            `;
            if (reset) input.value = '';
            tvSearchInputEl = input;

            const btn = document.createElement('button');
            btn.textContent = 'Search';
            btn.style.cssText = `
                padding: 10px 12px;
                border-radius: 6px;
                border: 1px solid rgba(59, 130, 246, 0.6);
                background: rgba(59, 130, 246, 0.85);
                color: #e2e8f0;
                font-weight: 600;
                cursor: pointer;
            `;

            const onSearch = () => {
                const q = input.value.trim();
                if (q) {
                    addToTVSearchHistory(q);
                    renderSearchHistory(); // Re-render history after search
                }
                handleTVSearch(q);
            };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') onSearch();
            });
            btn.addEventListener('click', onSearch);

            searchWrap.appendChild(input);
            searchWrap.appendChild(btn);

            // Add search history section
            const historyContainer = document.createElement('div');
            historyContainer.id = 'tvSearchHistoryContainer';
            historyContainer.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%;
                margin-top: 8px;
            `;

            const renderSearchHistory = () => {
                historyContainer.innerHTML = '';
                const history = getTVSearchHistory();
                
                if (history.length > 0) {
                    const historyLabel = document.createElement('div');
                    historyLabel.textContent = 'Recent Searches';
                    historyLabel.style.cssText = `
                        font-size: 11px;
                        color: #94a3b8;
                        font-weight: 600;
                        text-transform: uppercase;
                        margin-bottom: 4px;
                        letter-spacing: 0.5px;
                    `;
                    historyContainer.appendChild(historyLabel);

                    history.forEach(query => {
                        const historyItem = document.createElement('div');
                        historyItem.classList.add('tv-history-item');
                        historyItem.tabIndex = 0;
                        historyItem.setAttribute('role', 'button');
                        historyItem.style.cssText = `
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            padding: 8px 10px;
                            border-radius: 4px;
                            background: rgba(15, 23, 42, 0.6);
                            border: 1px solid rgba(59, 130, 246, 0.2);
                            cursor: pointer;
                            transition: all 0.2s ease;
                        `;

                        const queryText = document.createElement('span');
                        queryText.textContent = query;
                        queryText.style.cssText = `
                            flex: 1;
                            color: #cbd5e1;
                            font-size: 13px;
                            overflow: hidden;
                            text-overflow: ellipsis;
                            white-space: nowrap;
                        `;

                        const removeBtn = document.createElement('button');
                        removeBtn.innerHTML = 'Ã—';
                        removeBtn.style.cssText = `
                            width: 20px;
                            height: 20px;
                            border-radius: 50%;
                            border: none;
                            background: rgba(239, 68, 68, 0.8);
                            color: white;
                            font-size: 16px;
                            font-weight: bold;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            padding: 0;
                            line-height: 1;
                            transition: all 0.2s ease;
                            flex-shrink: 0;
                        `;

                        removeBtn.addEventListener('mouseenter', () => {
                            removeBtn.style.background = 'rgba(239, 68, 68, 1)';
                            removeBtn.style.transform = 'scale(1.1)';
                        });

                        removeBtn.addEventListener('mouseleave', () => {
                            removeBtn.style.background = 'rgba(239, 68, 68, 0.8)';
                            removeBtn.style.transform = 'scale(1)';
                        });

                        removeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            removeFromTVSearchHistory(query);
                            renderSearchHistory();
                        });

                        historyItem.addEventListener('mouseenter', () => {
                            historyItem.style.background = 'rgba(59, 130, 246, 0.15)';
                            historyItem.style.borderColor = 'rgba(59, 130, 246, 0.5)';
                        });

                        historyItem.addEventListener('mouseleave', () => {
                            historyItem.style.background = 'rgba(15, 23, 42, 0.6)';
                            historyItem.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                        });

                        historyItem.addEventListener('click', () => {
                            input.value = query;
                            handleTVSearch(query);
                        });
                        historyItem.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                historyItem.click();
                            }
                        });

                        historyItem.appendChild(queryText);
                        historyItem.appendChild(removeBtn);
                        historyContainer.appendChild(historyItem);
                    });
                }
            };

            searchWrap.appendChild(historyContainer);
            renderSearchHistory();

            subfoldersList.appendChild(searchWrap);

            container.innerHTML = '<p style="text-align: center; color: #94a3b8; margin-top: 30px;">Search across Live TV, Movies, and Series</p>';
        }

        function handleTVSearch(query) {
            const container = document.getElementById('tvChannelsContainer');
            const titleEl = document.getElementById('tvCategoryTitle');
            const countEl = document.getElementById('tvChannelCount');
            if (!container) return;
            const q = (query || '').toLowerCase();
            if (!q) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; margin-top: 30px;">Enter a search term to find channels</p>';
                titleEl.textContent = 'Search';
                countEl.textContent = '';
                return;
            }

            const results = { live: [], movies: [], series: [] };

            Object.entries(tvMainFolders).forEach(([folderName, subfolders]) => {
                Object.entries(subfolders).forEach(([category, channels]) => {
                    channels.forEach(ch => {
                        const name = (ch.name || ch.title || '').toLowerCase();
                        if (name.includes(q)) {
                            if (folderName === 'Movies') results.movies.push(ch);
                            else if (folderName === 'Series') results.series.push(ch);
                            else results.live.push(ch);
                        }
                    });
                });
            });

            titleEl.textContent = 'Search';
            const groupedSeries = groupSeriesItems(results.series);
            const total = results.live.length + results.movies.length + groupedSeries.length;
            countEl.textContent = total ? `${total} results` : '0 results';

            container.innerHTML = '';

            const section = (label, arr, type) => {
                if (!arr.length) return;
                const header = document.createElement('div');
                header.textContent = label;
                header.style.cssText = 'color: #e2e8f0; font-weight: 700; margin: 12px 4px 6px 4px;';
                container.appendChild(header);

                const row = document.createElement('div');
                const baseRowStyles = `
                    display: flex;
                    gap: 10px;
                    overflow-x: auto;
                    overflow-y: hidden;
                    padding: 6px 4px 10px;
                    align-items: flex-start;
                    scroll-snap-type: x mandatory;
                `;
                row.style.cssText = baseRowStyles;

                arr.forEach((item, idx) => {
                    if (type === 'live') {
                        const card = document.createElement('div');
                        card.style.cssText = `
                            min-width: 220px;
                            flex: 0 0 220px;
                            flex-shrink: 0;
                            scroll-snap-align: start;
                            background: rgba(15, 23, 42, 0.6);
                            border: 1px solid rgba(59, 130, 246, 0.2);
                            border-radius: 6px;
                            padding: 10px;
                            display: grid;
                            grid-template-columns: 50px 1fr;
                            gap: 10px;
                            cursor: pointer;
                            position: relative;
                        `;
                        const favType = 'live';
                        const favBtn = document.createElement('button');
                        favBtn.style.cssText = `
                            position: absolute;
                            top: 6px;
                            right: 6px;
                            background: rgba(15,23,42,0.9);
                            color: #fbbf24;
                            border: 1px solid rgba(59,130,246,0.5);
                            border-radius: 50%;
                            width: 26px;
                            height: 26px;
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            z-index: 2;
                        `;
                        styleFavoriteButton(favBtn, isFavorite(item, favType));
                        favBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleFavorite(item, favType);
                            styleFavoriteButton(favBtn, isFavorite(item, favType));
                        });
                        const logo = document.createElement('div');
                        logo.style.cssText = 'width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 4px;';
                        if (item.poster) {
                            const img = document.createElement('img');
                            img.src = item.poster;
                            img.loading = 'lazy';
                            img.style.cssText = 'width: 100%; height: 100%; object-fit: contain;';
                            img.onerror = () => { img.style.display = 'none'; };
                            logo.appendChild(img);
                        }
                        const info = document.createElement('div');
                        info.style.cssText = 'display: flex; flex-direction: column; justify-content: center; color: #e2e8f0; font-size: 13px; font-weight: 600;';
                        info.textContent = item.name || item.title || 'Channel';
                        card.appendChild(favBtn);
                        card.appendChild(logo);
                        card.appendChild(info);
                        card.addEventListener('click', () => playTVChannel(item));
                        row.appendChild(card);
                    } else {
                        const card = document.createElement('div');
                        card.style.cssText = `
                            width: 150px;
                            flex: 0 0 150px;
                            flex-shrink: 0;
                            scroll-snap-align: start;
                            background: rgba(15, 23, 42, 0.6);
                            border: 1px solid rgba(59, 130, 246, 0.2);
                            border-radius: 8px;
                            overflow: hidden;
                            cursor: pointer;
                            display: flex;
                            flex-direction: column;
                            position: relative;
                        `;
                        const favType = type === 'series' ? 'series' : 'movies';
                        const favBtn = document.createElement('button');
                        favBtn.style.cssText = `
                            position: absolute;
                            top: 6px;
                            right: 6px;
                            background: rgba(15,23,42,0.9);
                            color: #fbbf24;
                            border: 1px solid rgba(59,130,246,0.5);
                            border-radius: 50%;
                            width: 26px;
                            height: 26px;
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            z-index: 2;
                        `;
                        styleFavoriteButton(favBtn, isFavorite(item, favType));
                        favBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleFavorite(item, favType);
                            styleFavoriteButton(favBtn, isFavorite(item, favType));
                        });
                        const poster = document.createElement('div');
                        poster.style.cssText = 'position: relative; width: 100%; padding-top: 150%; background: linear-gradient(135deg, #1e293b, #0f172a);';
                        if (item.poster) {
                            const img = document.createElement('img');
                            img.src = item.poster;
                            img.loading = 'lazy';
                            img.style.cssText = 'position: absolute; top:0; left:0; right:0; bottom:0; width:100%; height:100%; object-fit: cover;';
                            img.onerror = () => { img.style.display = 'none'; };
                            poster.appendChild(img);
                        }
                        const title = document.createElement('div');
                        title.style.cssText = 'padding: 8px; color: #e2e8f0; font-size: 12px; font-weight: 600; min-height: 38px; display: flex; align-items: center;';
                        title.textContent = item.name || item.title || 'Untitled';
                        card.appendChild(favBtn);
                        card.appendChild(poster);
                        card.appendChild(title);
                        card.addEventListener('click', () => {
                            if (type === 'series') {
                                const slug = (item.title || item.name || 'show').toLowerCase().replace(/[^a-z0-9]+/g, '-');
                                const episodes = Array.isArray(item.tvEpisodesLocal) && item.tvEpisodesLocal.length
                                    ? item.tvEpisodesLocal
                                    : [{ displayTitle: item.name || item.title, channel: item }];
                                const tvItem = {
                                    id: `tv-local-${slug}`,
                                    title: item.title || item.name,
                                    name: item.name || item.title,
                                    poster: item.poster,
                                    type: 'series',
                                    source: 'tv-local',
                                    tvEpisodesLocal: episodes
                                };
                                openDetails(tvItem);
                            } else {
                                playTVChannel(item);
                            }
                        });
                        row.appendChild(card);
                    }
                });

                container.appendChild(row);
            };

            section('Live Channels', results.live, 'live');
            section('Movies', results.movies, 'movie');
            section('Series', groupedSeries, 'series');

            if (!total) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; margin-top: 30px;">No results found</p>';
            }
        }

        // ---------- Play TV Channel ----------
        function scheduleTVStreamRetry(channel, streamUrl, reason = 'unknown') {
            if (tvStreamRetryAttempts >= TV_STREAM_RETRY_MAX) {
                console.warn(`[TV retry] max attempts reached after ${reason}, stopping embedded retry`);
                showStreamFailureMessage(channel, streamUrl);
                return;
            }
            tvStreamRetryAttempts += 1;
            if (tvStreamRetryTimer) clearTimeout(tvStreamRetryTimer);
            tvStreamRetryTimer = setTimeout(() => {
                let nextUrl = streamUrl;
                if (tvStreamCandidateIndex < tvStreamCandidates.length - 1) {
                    tvStreamCandidateIndex += 1;
                    nextUrl = tvStreamCandidates[tvStreamCandidateIndex];
                    console.warn(`[TV retry] attempt ${tvStreamRetryAttempts} after ${reason}, switching candidate to`, nextUrl);
                } else {
                    console.warn(`[TV retry] attempt ${tvStreamRetryAttempts} after ${reason}, retrying same URL`);
                }
                showTVEmbeddedPlayer(channel, nextUrl, { isRetry: true });
            }, TV_STREAM_RETRY_DELAY_MS);
        }

        function loadHlsJsOnce() {
            if (window.Hls) return Promise.resolve(window.Hls);
            if (tvHlsLoading) return tvHlsLoading;
            tvHlsLoading = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/hls.js@1.5.8/dist/hls.light.min.js';
                script.onload = () => resolve(window.Hls);
                script.onerror = (e) => reject(e);
                document.head.appendChild(script);
            });
            return tvHlsLoading;
        }

        async function attachStreamToVideo(videoEl, streamUrl) {
            cleanupTvHls();
            const isHls = /\.m3u8(\?|$)/i.test(streamUrl);
            const nativeHls = videoEl.canPlayType('application/vnd.apple.mpegurl');
            videoEl.playsInline = true;
            videoEl.crossOrigin = 'anonymous';
            if (isHls && !nativeHls) {
                try {
                    const HlsLib = await loadHlsJsOnce();
                    if (HlsLib && HlsLib.isSupported()) {
                        tvHlsInstance = new HlsLib({
                            capLevelToPlayerSize: true,
                            maxBufferLength: 10,
                            startPosition: -1,
                        });
                        tvHlsInstance.loadSource(streamUrl);
                        tvHlsInstance.attachMedia(videoEl);
                        tvHlsInstance.on(HlsLib.Events.ERROR, (evt, data) => {
                            console.warn('[TV][HLS] error', data?.type, data?.details, data?.fatal);
                            if (data?.fatal) {
                                if (data.type === HlsLib.ErrorTypes.NETWORK_ERROR) {
                                    console.warn('[TV][HLS] network fatal, trying to restart load');
                                    tvHlsInstance.startLoad();
                                } else if (data.type === HlsLib.ErrorTypes.MEDIA_ERROR) {
                                    console.warn('[TV][HLS] media fatal, trying to recover');
                                    tvHlsInstance.recoverMediaError();
                                } else {
                                    console.warn('[TV][HLS] unrecoverable fatal, scheduling retry');
                                    scheduleTVStreamRetry(tvCurrentlyPlaying || {}, streamUrl, 'hls-fatal');
                                }
                            }
                        });
                        tvHlsInstance.on(HlsLib.Events.MANIFEST_PARSED, () => {
                            videoEl.play().catch(() => {});
                        });
                        return;
                    }
                } catch (e) {
                    console.warn('[TV] failed to load hls.js, falling back to direct src', e);
                }
            }
            videoEl.src = streamUrl;
            videoEl.load();
            const tryPlay = () => videoEl.play().catch(() => {});
            videoEl.onloadedmetadata = tryPlay;
            setTimeout(tryPlay, 300);
        }

        async function showTVEmbeddedPlayer(channel, streamUrl, opts = {}) {
            const { isRetry = false, resumeTime = null } = opts;

            if (!isRetry) {
                tvStreamRetryAttempts = 0;
                if (tvStreamRetryTimer) {
                    clearTimeout(tvStreamRetryTimer);
                    tvStreamRetryTimer = null;
                }
                tvStreamCandidateIndex = 0;
            }
            const playerContainer = document.getElementById('tvPlayerContainer');
            const playerContent = document.getElementById('tvPlayerContent');
            const fullscreenBadge = document.getElementById('tvFullscreenBadge');
            const nowPlayingTitle = document.getElementById('tvNowPlayingTitle');
            
            tvCurrentlyPlaying = channel;
            tvEmbeddedPlayerActive = true;
            
            // Update title (this element is outside playerContent so it won't be removed)
            if (nowPlayingTitle) {
                nowPlayingTitle.textContent = channel.name || channel.title || 'Playing...';
            }
            
            // Show fullscreen badge
            fullscreenBadge.style.display = 'block';
            
            // Show play/pause button
            const playPauseBtn = document.getElementById('tvPlayPauseBtn');
            if (playPauseBtn) {
                playPauseBtn.style.display = 'block';
                playPauseBtn.textContent = 'â¸ Pause';
            }
            
            // Create video element for embedded playback
            playerContent.innerHTML = `
                <video id="tvEmbeddedVideo" style="width: 100%; height: 100%; object-fit: contain; background: #000;">
                    Your browser does not support the video tag.
                </video>
            `;
            
            tvVideoElement = document.getElementById('tvEmbeddedVideo');
            
            if (tvVideoElement) {
                // Set video source with HLS fallback if needed
                tvVideoElement.controls = false;
                tvVideoElement.autoplay = true;
                tvVideoElement.volume = 0.7;

                await attachStreamToVideo(tvVideoElement, streamUrl);

                // Resume from saved position if provided
                if (resumeTime && resumeTime > 0) {
                    tvVideoElement.addEventListener('loadedmetadata', () => {
                        if (tvVideoElement.duration > resumeTime) {
                            tvVideoElement.currentTime = resumeTime;
                            console.log('[TV] Resuming from', resumeTime);
                        }
                    }, { once: true });
                }
                
                // Handle errors - retry and advance candidate immediately if available
                tvVideoElement.onerror = () => {
                    if (!tvEmbeddedPlayerActive) return;
                    const err = tvVideoElement?.error;
                    console.warn('[TV] HTML5 video error, scheduling retry', err?.code, err?.message || err);
                    if (tvStreamCandidateIndex < tvStreamCandidates.length - 1) {
                        tvStreamCandidateIndex += 1;
                        const nextUrl = tvStreamCandidates[tvStreamCandidateIndex];
                        console.warn('[TV] switching to next candidate after error', nextUrl);
                        showTVEmbeddedPlayer(channel, nextUrl, { isRetry: true });
                        return;
                    }
                    scheduleTVStreamRetry(channel, streamUrl, 'error');
                };
                
                // Also handle if playback doesn't start after a delay
                const playbackTimeoutId = setTimeout(() => {
                    if (!tvEmbeddedPlayerActive) return;
                    if (!tvVideoElement || tvVideoElement.paused) {
                        console.warn('[TV] Playback timeout, scheduling retry');
                        scheduleTVStreamRetry(channel, streamUrl, 'timeout');
                    }
                }, TV_STREAM_START_TIMEOUT_MS);
                
                // Clear timeout if video actually starts playing
                tvVideoElement.onplay = () => {
                    clearTimeout(playbackTimeoutId);
                    tvStreamRetryAttempts = 0;
                    if (tvStreamRetryTimer) {
                        clearTimeout(tvStreamRetryTimer);
                        tvStreamRetryTimer = null;
                    }
                };

                // Track playback progress for continue watching
                let progressInterval = null;
                const trackProgress = () => {
                    if (tvVideoElement && !tvVideoElement.paused && tvVideoElement.duration > 0) {
                        updateContinueWatching(channel, tvVideoElement.currentTime, tvVideoElement.duration);
                    }
                };
                tvVideoElement.addEventListener('play', () => {
                    if (progressInterval) clearInterval(progressInterval);
                    progressInterval = setInterval(trackProgress, 5000);
                });
                tvVideoElement.addEventListener('pause', () => {
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                    trackProgress();
                });
                tvVideoElement.addEventListener('ended', () => {
                    if (progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                    }
                    trackProgress();
                });
                
                // Play/Pause button functionality
                if (playPauseBtn) {
                    playPauseBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (tvVideoElement.paused) {
                            tvVideoElement.play();
                            playPauseBtn.textContent = 'â¸ Pause';
                        } else {
                            tvVideoElement.pause();
                            playPauseBtn.textContent = 'â–¶ Play';
                        }
                    };
                    
                    // Update button on video state changes
                    tvVideoElement.addEventListener('play', () => {
                        playPauseBtn.textContent = 'â¸ Pause';
                    });
                    tvVideoElement.addEventListener('pause', () => {
                        playPauseBtn.textContent = 'â–¶ Play';
                    });
                    
                    // Hover effect
                    playPauseBtn.addEventListener('mouseenter', () => {
                        playPauseBtn.style.background = 'rgba(59, 130, 246, 1)';
                    });
                    playPauseBtn.addEventListener('mouseleave', () => {
                        playPauseBtn.style.background = 'rgba(59, 130, 246, 0.9)';
                    });
                }
            }
            
            // Setup fullscreen click
            fullscreenBadge.onclick = (e) => {
                e.stopPropagation();
                playTVChannelFullscreen(channel, streamUrl);
            };
            
            // Also setup container click for fullscreen
            playerContent.onclick = () => {
                if (tvEmbeddedPlayerActive && tvCurrentlyPlaying) {
                    playTVChannelFullscreen(tvCurrentlyPlaying, streamUrl);
                }
            };
        }
        
        async function playTVChannelFullscreen(channel, streamUrl) {
            stopMpvProgressTracking();
            const startTime = tvVideoElement ? Number(tvVideoElement.currentTime || 0) : 0;
            try {
                if (tvVideoElement) {
                    tvVideoElement.pause();
                }
                cleanupTvHls();
                tvEmbeddedPlayerActive = false;
                if (tvStreamRetryTimer) {
                    clearTimeout(tvStreamRetryTimer);
                    tvStreamRetryTimer = null;
                }
            } catch {}

            // Prefer native Android fullscreen playback (ExoPlayer + VLC fallback) when available.
            try {
                if (typeof window.playNativeVideo === 'function') {
                    const title = channel?.name || channel?.title || 'TV Stream';
                    const poster = channel?.logo || channel?.poster || '';
                    const res = await window.playNativeVideo(streamUrl, { title, poster });
                    if (res && res.ok) {
                        tvCurrentlyPlaying = channel;
                        saveTVState();
                        return;
                    }
                }
            } catch { }

            const content = {
                id: channel.id,
                type: 'tv',
                title: channel.name || channel.title || 'TV Stream',
                poster: channel.poster || '',
                logo: channel.logo || '',
                url: streamUrl
            };
            try {
                // Determine resume time from continue watching (movies/series only)
                let resumeTime = startTime;
                const mainFolder = tvSelectedMainFolder;
                if (mainFolder === 'Movies' || mainFolder === 'Series') {
                    const typeKey = mainFolder.toLowerCase();
                    const saved = tvContinueWatching[typeKey]?.[channel.id];
                    if (saved?.currentTime) resumeTime = saved.currentTime;
                }

                await window.mediaAPI.player.play(content);

                // Seek to resume position if available
                if (resumeTime > 0.25) {
                    setTimeout(() => {
                        window.mediaAPI.player.command('setProperty', 'time-pos', resumeTime).catch(() => {});
                    }, 200);
                }

                // Start MPV progress polling to keep Continue Watching in sync
                const enableCW = (tvSelectedMainFolder === 'Movies' || tvSelectedMainFolder === 'Series');
                startMpvProgressTracking(channel, { enableContinueWatching: enableCW });
            } catch {}
        }
        
        async function playTVChannel(channel, opts = {}) {
            console.log('[playTVChannel] Playing:', channel.name || channel.title, 'opts.forceFullscreen=', !!opts.forceFullscreen);

            try {
                tvLastSelectedChannelId = String(channel?.id || '');
            } catch { }

            try { saveTVState(); } catch { }
            
            // Add to Recently Watched if this is a Live TV channel
            if (tvSelectedMainFolder === 'Live TV') {
                addToRecentlyWatched(channel);
            }
            
            try {
                // IMPORTANT: For IPTV, the catalog item already contains the per-channel URL.
                // Using the generic backend /streams aggregator can return unrelated results
                // (often the same list for every iptv-* id), causing every channel to play the same stream.
                let streamUrl = String(channel?.url || '').trim();

                // Fallback: if the channel URL is missing, ask the backend resolver.
                if (!streamUrl) {
                    const streamList = await fetchStreams(channel.id, { title: channel.title || channel.name, type: 'iptv' });
                    if (Array.isArray(streamList) && streamList.length > 0) {
                        streamUrl = String(streamList[0]?.url || '').trim();
                    }
                }
                
                if (!streamUrl) {
                    console.error('[playTVChannel] No stream URL available');
                    alert('Unable to play channel: no stream URL');
                    return;
                }
                
                console.log('[playTVChannel] Stream URL:', streamUrl.substring(0, 50) + '...');

                // Load EPG preview for this channel
                loadTvEpg(channel);
                
                tvStreamCandidates = buildStreamCandidates(streamUrl);
                console.log('[TV] stream candidates', tvStreamCandidates);
                tvStreamCandidateIndex = 0;

                // Live TV: first OK shows embedded preview; second OK (same channel) goes fullscreen/native.
                const shouldPreview = (tvSelectedMainFolder === 'Live TV') && !opts.forceFullscreen && !tvEmbeddedPlayerActive;
                if (shouldPreview) {
                    await showTVEmbeddedPlayer(channel, tvStreamCandidates[0], { resumeTime: opts.resumeTime });
                    return;
                }

                // If preview is already active on this channel, force fullscreen/native.
                if (tvSelectedMainFolder === 'Live TV' && tvEmbeddedPlayerActive && tvCurrentlyPlaying && tvCurrentlyPlaying.id === channel.id) {
                    opts.forceFullscreen = true;
                }

                // On Android/TV app shells, use the native fullscreen player for Live TV fullscreen.
                try {
                    // For Live TV, always use VLC (much better for IPTV streaming)
                    if (tvSelectedMainFolder === 'Live TV' && typeof Capacitor !== 'undefined') {
                        try {
                            const platform = Capacitor.getPlatform();
                            if (platform === 'android') {
                                console.log('[playTVChannel] Using VLC for Live TV');
                                // Push the current displayed channel list to native so VLC can zap instantly.
                                try {
                                    if (!window.__nativeLiveTvListPushed) window.__nativeLiveTvListPushed = false;
                                    const list = Array.isArray(tvActiveDisplayedChannels) ? tvActiveDisplayedChannels : [];
                                    const channelsForNative = list
                                        .map(c => ({
                                            id: String(c?.id || '').trim(),
                                            url: String(c?.url || '').trim(),
                                            title: String(c?.name || c?.title || '').trim()
                                        }))
                                        .filter(c => c.id && c.url);

                                    // Only push if we have something meaningful; update whenever list length changes.
                                    const sig = String(channelsForNative.length);
                                    if (window.__nativeLiveTvListSig !== sig) {
                                        await Capacitor.Plugins.LiveTvPlayer.setChannelList({
                                            channels: channelsForNative,
                                            currentId: String(channel?.id || '').trim()
                                        });
                                        window.__nativeLiveTvListSig = sig;
                                        window.__nativeLiveTvListPushed = true;
                                    }
                                } catch (e) {
                                    console.warn('[playTVChannel] setChannelList failed:', e);
                                }

                                // Remember where we were so we can restore focus after BACK.
                                try { window.__preNativeFocusEl = document.activeElement; } catch { }

                                const title = channel?.name || channel?.title || 'TV Stream';
                                const poster = channel?.logo || channel?.poster || '';

                                // Use VLC for Live TV
                                try {
                                    await Capacitor.Plugins.LiveTvPlayer.playLiveStream({
                                        url: streamUrl,
                                        title: title,
                                        poster: poster,
                                        channelId: String(channel?.id || '').trim()
                                    });
                                    tvCurrentlyPlaying = channel;
                                    tvEmbeddedPlayerActive = false;
                                    try { cleanupTvHls(); } catch { }
                                    try {
                                        const fullscreenBadge = document.getElementById('tvFullscreenBadge');
                                        const playPauseBtn = document.getElementById('tvPlayPauseBtn');
                                        if (fullscreenBadge) fullscreenBadge.style.display = 'none';
                                        if (playPauseBtn) playPauseBtn.style.display = 'none';
                                    } catch { }
                                    // Enable native UP/DOWN zapping only for Live TV playback.
                                    try { await setNativeTvZapEnabled(true); } catch { }
                                    saveTVState();
                                    console.log('[playTVChannel] VLC playback started successfully');
                                    return;
                                } catch (err) {
                                    console.warn('[playTVChannel] VLC failed:', err?.message || err);
                                }
                            }
                        } catch (err) {
                            console.warn('[playTVChannel] VLC plugin error:', err);
                        }
                    }
                    
                    // Fallback to ExoPlayer for non-Live TV or non-native
                    if (typeof window.playNativeVideo === 'function') {
                        // Remember where we were so we can restore focus after BACK.
                        try { window.__preNativeFocusEl = document.activeElement; } catch { }

                        const title = channel?.name || channel?.title || 'TV Stream';
                        const poster = channel?.logo || channel?.poster || '';

                        // Enable native UP/DOWN zapping only for Live TV playback.
                        try { await setNativeTvZapEnabled(tvSelectedMainFolder === 'Live TV'); } catch { }

                        for (const candidateUrl of tvStreamCandidates.slice(0, 5)) {
                            const r = await window.playNativeVideo(candidateUrl, { title, poster });
                            if (r && r.ok) {
                                tvCurrentlyPlaying = channel;
                                tvEmbeddedPlayerActive = false;
                                try { cleanupTvHls(); } catch { }
                                try {
                                    const fullscreenBadge = document.getElementById('tvFullscreenBadge');
                                    const playPauseBtn = document.getElementById('tvPlayPauseBtn');
                                    if (fullscreenBadge) fullscreenBadge.style.display = 'none';
                                    if (playPauseBtn) playPauseBtn.style.display = 'none';
                                } catch { }
                                saveTVState();
                                return;
                            }
                        }
                    }
                } catch { }

                // If native playback failed, ensure zapping is disabled.
                try { await setNativeTvZapEnabled(false); } catch { }

                try {
                    // Prefer MPV for playback (better on Android TV)
                    await playTVChannelFullscreen(channel, tvStreamCandidates[0]);
                } catch (err) {
                    console.warn('[playTVChannel] MPV failed, falling back to HTML player:', err?.message || err);
                    await showTVEmbeddedPlayer(channel, tvStreamCandidates[0], { resumeTime: opts.resumeTime });
                }
                saveTVState();
                
            } catch (err) {
                console.error('[playTVChannel] Error:', err);
                alert('Error loading stream: ' + err.message);
            }
        }
        
        tabHomeBtn.addEventListener("click", () => switchTopTab("home"));
        tabMoviesBtn?.addEventListener("click", () => switchTopTab("movies"));
        tabSeriesBtn?.addEventListener("click", () => switchTopTab("series"));
        tabAnimeBtn?.addEventListener("click", () => switchTopTab("anime"));
        tabTVBtn?.addEventListener("click", () => switchTopTab("tv"));
        tabMyListBtn?.addEventListener("click", () => switchTopTab("mylist"));
        tabSettingsBtn?.addEventListener("click", () => switchTopTab("settings"));

        // Netflix-style behavior on TV: moving focus onto a tab activates it (no OK press).
        // We move the highlight immediately, and debounce the content switch slightly.
        function isTvNavMode() {
            try { return document.documentElement.classList.contains('tv-compact'); } catch { }
            return false;
        }
        function handleTabFocus(tab, btn) {
            try {
                if (!isTvNavMode()) return;
                console.log('[TAB FOCUS] tab=' + tab + ', ignoreFlag=' + !!window.__tvBackIgnoreNextTabSwitch);
                // If BACK just focused this button to return to menu, don't switch tabs
                // (the tab should already be correct, or will be corrected by handleBackAction's 350ms window).
                if (window.__tvBackIgnoreNextTabSwitch) {
                    window.__tvBackIgnoreNextTabSwitch = false;
                    updateTabIndicator(btn);
                    console.log('[TAB FOCUS] Ignored tab switch due to BACK flag');
                    return;
                }
                updateTabIndicator(btn);
                scheduleTvTabSwitch(tab);
            } catch { }
        }
        tabHomeBtn.addEventListener('focus', () => handleTabFocus('home', tabHomeBtn));
        tabMoviesBtn?.addEventListener('focus', () => handleTabFocus('movies', tabMoviesBtn));
        tabSeriesBtn?.addEventListener('focus', () => handleTabFocus('series', tabSeriesBtn));
        tabAnimeBtn?.addEventListener('focus', () => handleTabFocus('anime', tabAnimeBtn));
        tabTVBtn?.addEventListener('focus', () => handleTabFocus('tv', tabTVBtn));
        tabMyListBtn?.addEventListener('focus', () => handleTabFocus('mylist', tabMyListBtn));
        tabSettingsBtn?.addEventListener('focus', () => handleTabFocus('settings', tabSettingsBtn));

        // Initial indicator position
        try { requestAnimationFrame(() => updateTabIndicator()); } catch { }

        // ---------- Home Rendering ----------
        function renderHeroFromItem(item) {
            heroItem = item;
            // If hero elements were removed from DOM, do nothing
            if (!heroPosterEl || !heroTitleEl || !heroMetaEl) return;
            if (!item) {
                heroPosterEl.src = "";
                heroTitleEl.textContent = "Select a title";
                heroMetaEl.textContent = "Rows come from enabled addons (catalogs).";
                if (heroOpenBtn) heroOpenBtn.disabled = true;
                if (heroPlayBtn) heroPlayBtn.disabled = true;
                return;
            }
            heroPosterEl.src = item.poster || "";
            heroPosterEl.onerror = () => { heroPosterEl.style.opacity = 0.2; };
            heroTitleEl.textContent = item.title || item.id || "Untitled";
            heroMetaEl.textContent = `Type: ${item.type || "unknown"} â€¢ ID: ${item.id}`;
            if (heroOpenBtn) heroOpenBtn.disabled = false;
            if (heroPlayBtn) heroPlayBtn.disabled = false;
        }

        function createTile(item, index = 0) {
            const tile = document.createElement("div");
            tile.className = "tile";
            tile.tabIndex = 0;
            try {
                const k = `${String(item?.type || 'm')}:${String(item?.id || '')}`;
                tile.dataset.tileKey = k;
            } catch { }

            const img = document.createElement("img");
            try {
                img.decoding = 'async';
            } catch { }
            img.src = item.poster || "";
            img.alt = item.title || item.id || "Poster";
            img.onerror = () => { img.style.opacity = 0.2; };

            const title = document.createElement("div");
            title.className = "tileTitle";
            title.textContent = item.title || item.id || "Untitled";

            tile.appendChild(img);
            tile.appendChild(title);

            tile.addEventListener("click", () => openDetails(item));
            tile.addEventListener("keydown", (e) => { if (e.key === "Enter") openDetails(item); });

            tile.addEventListener("focus", () => {
                renderHeroFromItem(item);
                try {
                    const s = ensureTabUiState(currentTopTab);
                    if (tile.dataset && tile.dataset.tileKey) s.focusedTileKey = tile.dataset.tileKey;
                } catch { }
            });
            tile.addEventListener("mouseenter", () => renderHeroFromItem(item));

            return tile;
        }

        async function renderRowsPlaceholder(displayCatalogs = catalogs, opts = {}) {
            const append = !!opts.append;
            if (!append) rowsContainer.innerHTML = "";
            let lastYield = __nowMs();
            const list = Array.isArray(displayCatalogs) ? displayCatalogs : [];
            for (const c of list) {
                const section = document.createElement("div");
                section.className = "section";

                const header = document.createElement("div");
                header.className = "sectionHeader";

                const hTitle = document.createElement("div");
                hTitle.className = "sectionTitle";
                hTitle.textContent = c.name;

                const hint = document.createElement("div");
                hint.className = "sectionHint";
                hint.textContent = `From: ${c.addonId}`;

                header.appendChild(hTitle);
                header.appendChild(hint);

                const rowWrapper = document.createElement("div");
                rowWrapper.className = "rowWrapper";

                const leftNav = document.createElement("div");
                leftNav.className = "rowNav left";
                leftNav.innerHTML = '<svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';

                const row = document.createElement("div");
                row.className = "row";
                row.dataset.addonUid = c.addonUid;
                row.dataset.type = c.type;
                row.dataset.catalogId = c.id;

                const rightNav = document.createElement("div");
                rightNav.className = "rowNav right";
                rightNav.innerHTML = '<svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';

                leftNav.addEventListener("click", () => {
                    const scrollAmount = row.clientWidth - 100;
                    leftNav.classList.add('scrolling');
                    row.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                    setTimeout(() => {
                        leftNav.classList.remove('scrolling');
                    }, 400);
                });

                rightNav.addEventListener("click", () => {
                    const scrollAmount = row.clientWidth - 100;
                    rightNav.classList.add('scrolling');
                    row.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                    setTimeout(() => {
                        rightNav.classList.remove('scrolling');
                    }, 400);
                });

                rowWrapper.appendChild(leftNav);
                rowWrapper.appendChild(row);
                rowWrapper.appendChild(rightNav);

                section.appendChild(header);
                section.appendChild(rowWrapper);

                rowsContainer.appendChild(section);
                lastYield = await __yieldIfOverBudget(lastYield, 10);
            }
        }

        function appendStaticRowSection(titleText, hintText, items, opts = {}) {
            const section = document.createElement("div");
            section.className = "section";
            if (opts && opts.compact) section.classList.add('section--compact');

            const header = document.createElement("div");
            header.className = "sectionHeader";

            const hTitle = document.createElement("div");
            hTitle.className = "sectionTitle";
            hTitle.textContent = titleText;

            const hint = document.createElement("div");
            hint.className = "sectionHint";
            hint.textContent = hintText || "";

            header.appendChild(hTitle);
            header.appendChild(hint);

            const rowWrapper = document.createElement("div");
            rowWrapper.className = "rowWrapper";

            const leftNav = document.createElement("div");
            leftNav.className = "rowNav left";
            leftNav.innerHTML = '<svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>';

            const row = document.createElement("div");
            row.className = "row";
            row.dataset.search = "1"; // skip fillRows() auto-population

            const rightNav = document.createElement("div");
            rightNav.className = "rowNav right";
            rightNav.innerHTML = '<svg viewBox="0 0 24 24"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>';

            leftNav.addEventListener("click", () => {
                const scrollAmount = row.clientWidth - 100;
                leftNav.classList.add('scrolling');
                row.scrollBy({ left: -scrollAmount, behavior: 'smooth' });
                setTimeout(() => leftNav.classList.remove('scrolling'), 400);
            });

            rightNav.addEventListener("click", () => {
                const scrollAmount = row.clientWidth - 100;
                rightNav.classList.add('scrolling');
                row.scrollBy({ left: scrollAmount, behavior: 'smooth' });
                setTimeout(() => rightNav.classList.remove('scrolling'), 400);
            });

            (items || []).forEach((item, index) => row.appendChild(createTile(item, index)));

            rowWrapper.appendChild(leftNav);
            rowWrapper.appendChild(row);
            rowWrapper.appendChild(rightNav);

            section.appendChild(header);
            section.appendChild(rowWrapper);
            rowsContainer.appendChild(section);
        }

        async function fillRows(search, disabledCatalogKeys = new Set(), viewTab = currentTopTab) {
            const rows = Array.from(rowsContainer.querySelectorAll(".row"));
            let lastYield = __nowMs();
            for (const row of rows) {
                // skip the temporary search results row inserted at top
                if (row.dataset && row.dataset.search === "1") continue;

                const addonUid = row.dataset.addonUid;
                const type = row.dataset.type;
                const catalogId = row.dataset.catalogId;

                // If this catalog contributed to the top search aggregation, hide its header+row
                const catalogKey = `${addonUid}::${catalogId}`;
                if (disabledCatalogKeys && disabledCatalogKeys.has(catalogKey)) {
                    row.style.display = "none";
                    const prev = row.previousElementSibling;
                    if (prev && prev.classList && prev.classList.contains('sectionHeader')) prev.style.display = "none";
                    continue;
                } else {
                    row.style.display = "flex";
                    const prev = row.previousElementSibling;
                    if (prev && prev.classList && prev.classList.contains('sectionHeader')) prev.style.display = "flex";
                }

                row.innerHTML = "";
                const items = await fetchCatalogItems(addonUid, type, catalogId, search);
                const view = viewTab === 'settings' ? 'home' : viewTab;
                let filtered = (items || []).filter(it => itemMatchesTab(it, view));
                if (view === 'new') {
                    filtered = filtered
                        .map((it) => ({ it, t: getItemDateMs(it) }))
                        .sort((a, b) => (b.t ?? -1) - (a.t ?? -1))
                        .map(x => x.it);
                }

                if (!filtered.length) {
                    row.style.display = 'none';
                    const prev = row.previousElementSibling;
                    if (prev && prev.classList && prev.classList.contains('sectionHeader')) prev.style.display = 'none';
                    continue;
                }

                // Chunk tile rendering to keep animations smooth.
                for (let i = 0; i < filtered.length; i++) {
                    row.appendChild(createTile(filtered[i], i));
                    if ((i % 8) === 7) lastYield = await __yieldIfOverBudget(lastYield, 10);
                }
                lastYield = await __yieldIfOverBudget(lastYield, 10);
            }
        }

        // ---------- Modal ----------
        let lastFocusedEl = null;
        let prevBodyOverflow = null;
        let prevHtmlOverflow = null;

        function openModal() {
            modalBackdrop.style.display = "flex";

            // Prevent background page scroll while modal is open
            prevBodyOverflow = document.body.style.overflow;
            prevHtmlOverflow = document.documentElement.style.overflow;
            document.body.style.overflow = "hidden";
            document.documentElement.style.overflow = "hidden";

            // TV movie: shrink long titles to fit the fixed title box
            try {
                if (document.documentElement.classList.contains('tv-compact') && modalEl && modalEl.classList.contains('movieTvMode')) {
                    const fitTitle = () => {
                        try {
                            const el = modalTitleEl;
                            if (!el) return;
                            const maxFontPx = 26;
                            const minFontPx = 16;
                            el.style.fontSize = `${maxFontPx}px`;
                            let font = maxFontPx;
                            let guard = 0;
                            while (font > minFontPx && (el.scrollHeight > el.clientHeight + 1) && guard < 48) {
                                font -= 1;
                                el.style.fontSize = `${font}px`;
                                guard++;
                            }
                        } catch { }
                    };
                    requestAnimationFrame(fitTitle);
                }
            } catch { }

            setTimeout(() => {
                try {
                    const auto = modalEl?.querySelector('[data-modal-autofocus="true"]');
                    if (auto && typeof auto.focus === 'function') {
                        auto.focus();
                        return;
                    }
                } catch { }
                try {
                    const firstStream = streamListEl.querySelector(".streamItem");
                    if (firstStream) firstStream.focus();
                } catch { }
            }, 0);
        }
        function closeModal() {
            modalBackdrop.style.display = "none";
            streamListEl.innerHTML = "";
            if (modalSideEl) modalSideEl.innerHTML = "";
            if (modalEl) modalEl.classList.remove("hasSide");
            if (modalDescEl) {
                modalDescEl.textContent = "";
                modalDescEl.style.display = "none";
            }
            if (trailerBtn) trailerBtn.style.display = "none";
            try {
                const footerTrailerBtn = document.getElementById('footerTrailerBtn');
                if (footerTrailerBtn) footerTrailerBtn.style.display = 'none';
            } catch { }
            if (modalEpisodesWrapEl) {
                modalEpisodesWrapEl.innerHTML = "";
                modalEpisodesWrapEl.style.display = "none";
            }

            document.body.style.overflow = prevBodyOverflow ?? "";
            document.documentElement.style.overflow = prevHtmlOverflow ?? "";
            if (lastFocusedEl) lastFocusedEl.focus();
        }

        closeModalBtn.addEventListener("click", closeModal);
        modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); });

        // ---------- Remote / DPAD navigation (Android TV) ----------
        function isTypingTarget(el) {
            if (!el) return false;
            const tag = (el.tagName || '').toUpperCase();

            // On TV, we keep Settings inputs focusable but NOT editable unless the user presses OK/Enter.
            // While an input is focused-but-readonly, DPAD should still navigate.
            try {
                if (isTvNavMode && typeof isTvNavMode === 'function' && isTvNavMode()) {
                    if (tag === 'INPUT' || tag === 'TEXTAREA') {
                        return !el.readOnly;
                    }
                }
            } catch { }

            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return true;
            if (el.isContentEditable) return true;
            return false;
        }

        function bindTvReadonlyInputs(rootNode) {
            try {
                if (!isTvNavMode || typeof isTvNavMode !== 'function' || !isTvNavMode()) return;
                const root = rootNode && rootNode.querySelectorAll ? rootNode : document;
                const inputs = Array.from(root.querySelectorAll('#settingsWrap input, #tvSubfoldersList input'))
                    .filter((el) => el instanceof HTMLInputElement);

                const setReadonly = (inputEl, ro) => {
                    try {
                        if (!inputEl.dataset) inputEl.dataset = {};
                    } catch { }
                    try {
                        if (!inputEl.dataset.tvOrigInputmode) {
                            inputEl.dataset.tvOrigInputmode = String(inputEl.getAttribute('inputmode') || '');
                        }
                    } catch { }

                    try { inputEl.readOnly = !!ro; } catch { }
                    try {
                        if (ro) {
                            inputEl.setAttribute('inputmode', 'none');
                            inputEl.dataset.tvEditing = '0';
                        } else {
                            const orig = inputEl.dataset.tvOrigInputmode;
                            if (orig) inputEl.setAttribute('inputmode', orig);
                            else inputEl.removeAttribute('inputmode');
                            inputEl.dataset.tvEditing = '1';
                        }
                    } catch { }
                };

                const enableEdit = (inputEl) => {
                    try {
                        setReadonly(inputEl, false);
                        // Ensure caret is visible and placed at end
                        const v = String(inputEl.value || '');
                        try { inputEl.setSelectionRange(v.length, v.length); } catch { }
                    } catch { }
                };

                const disableEdit = (inputEl) => {
                    try { setReadonly(inputEl, true); } catch { }
                };

                for (const inputEl of inputs) {
                    // Skip checkboxes (we use switch styling for those)
                    if (inputEl.type === 'checkbox') continue;

                    // Initialize as readonly in TV mode
                    if (inputEl.dataset && inputEl.dataset.tvReadonlyBound === '1') continue;
                    disableEdit(inputEl);

                    inputEl.addEventListener('focus', () => {
                        // Keep readonly on focus unless already editing
                        try {
                            if (String(inputEl.dataset?.tvEditing || '0') !== '1') disableEdit(inputEl);
                        } catch { }
                    });

                    inputEl.addEventListener('blur', () => {
                        // Exit edit mode on blur
                        disableEdit(inputEl);
                    });

                    inputEl.addEventListener('keydown', (e) => {
                        const isEnter = e.key === 'Enter' || e.keyCode === 66;
                        if (!isEnter) return;
                        // Toggle into edit mode only when user presses OK/Enter
                        e.preventDefault();
                        e.stopPropagation();
                        enableEdit(inputEl);
                        try { inputEl.focus({ preventScroll: true }); } catch { try { inputEl.focus(); } catch { } }
                    });

                    // For touch/mouse, enable editing BEFORE focus happens.
                    // On Android, if the element becomes editable only after the focus event,
                    // the soft keyboard often won't appear.
                    inputEl.addEventListener('pointerdown', () => {
                        enableEdit(inputEl);
                    });
                    inputEl.addEventListener('mousedown', () => {
                        enableEdit(inputEl);
                    });
                    inputEl.addEventListener('touchstart', () => {
                        enableEdit(inputEl);
                    }, { passive: true });

                    inputEl.addEventListener('click', () => {
                        // Also allow click to enter edit mode (mouse / touch)
                        enableEdit(inputEl);
                        // Refocus now that it's editable so Android shows the keyboard.
                        try { inputEl.focus({ preventScroll: true }); } catch { try { inputEl.focus(); } catch { } }
                        try {
                            // Some WebViews need a tick after switching readOnly/inputmode.
                            setTimeout(() => {
                                try { inputEl.focus({ preventScroll: true }); } catch { try { inputEl.focus(); } catch { } }
                            }, 0);
                        } catch { }
                    });

                    if (inputEl.dataset) inputEl.dataset.tvReadonlyBound = '1';
                }
            } catch { }
        }

        function isElementVisible(el) {
            if (!el) return false;
            const style = window.getComputedStyle(el);
            if (style.display === 'none' || style.visibility === 'hidden') return false;
            const rects = el.getClientRects();
            return rects && rects.length > 0;
        }

        function getNavRoot() {
            try {
                // If a trailer overlay is open, navigation should be scoped to it.
                // Otherwise DPAD candidates stay inside the details modal and the Close button can't be reached.
                const tr = window.__trailerOverlayEl;
                if (tr && tr.isConnected) return tr;
                const hold = window.__tvHoldMenuEl;
                if (hold && hold.isConnected && hold.style.display !== 'none') return hold;
                if (modalBackdrop && modalBackdrop.style.display === 'flex') return modalBackdrop;
            } catch { }
            return document;
        }

        function getFocusableCandidates(root) {
            const scope = root && root.querySelectorAll ? root : document;
            const selector = [
                // Native focusables
                'button',
                'a[href]',
                'input',
                'select',
                'textarea',
                '[tabindex]:not([tabindex="-1"])',

                // App-specific focusables
                '.tile',
                '.streamItem',
                '.episode-card',
                '.tv-main-folder-btn',
                '.tv-card',
                '.tv-history-item',
                '#tvPlayerContent',
                '#tvFullscreenBadge',
                '#tvPlayPauseBtn',
                '.catalogRow'
            ].join(',');

            return Array.from(scope.querySelectorAll(selector))
                .filter((el) => isElementVisible(el))
                .filter((el) => {
                    const ariaHidden = el.getAttribute && el.getAttribute('aria-hidden');
                    if (ariaHidden === 'true') return false;
                    if (el.disabled) return false;
                    return true;
                });
        }

        function isInTopbar(el) {
            try {
                return !!(el && el.closest && el.closest('.topbar'));
            } catch { }
            return false;
        }

        function isInSettings(el) {
            try {
                if (!settingsWrap || settingsWrap.style.display === 'none') return false;
                return !!(el && el.closest && el.closest('#settingsWrap'));
            } catch { }
            return false;
        }

        function shouldAllowUpIntoTopbar(activeEl) {
            // Only allow focusing the top menu when the current focus is already
            // near the top of the visible content.
            try {
                const topbar = document.querySelector('.topbar');
                if (!topbar || !activeEl?.getBoundingClientRect) return true;
                const topbarRect = topbar.getBoundingClientRect();
                const activeRect = activeEl.getBoundingClientRect();
                const threshold = topbarRect.bottom + 48;

                // If we're on the very first visible row/section, always allow UP into the topbar.
                try {
                    const section = activeEl.closest && activeEl.closest('.section');
                    if (section && rowsContainer) {
                        const sections = Array.from(rowsContainer.querySelectorAll('.section'))
                            .filter((s) => isElementVisible(s));
                        const first = sections[0];
                        if (first && first === section) return true;
                    }
                } catch { }

                return activeRect.top <= threshold;
            } catch { }
            return true;
        }

        function getActiveTopTabButton() {
            try {
                const map = {
                    home: tabHomeBtn,
                    movies: tabMoviesBtn,
                    series: tabSeriesBtn,
                    anime: tabAnimeBtn,
                    tv: tabTVBtn,
                    mylist: tabMyListBtn,
                    settings: tabSettingsBtn
                };
                const btn = map[String(currentTopTab || 'home')];
                return btn || tabHomeBtn || tabSettingsBtn || null;
            } catch { }
            return null;
        }

        function focusBestContentForCurrentTab() {
            try {
                const s = ensureTabUiState(currentTopTab);
                const key = s && s.focusedTileKey ? String(s.focusedTileKey) : '';
                if (key) {
                    const el = rowsContainer?.querySelector?.(`.tile[data-tile-key="${CSS.escape(key)}"]`);
                    if (el && isElementVisible(el)) {
                        try { el.focus({ preventScroll: true }); } catch { try { el.focus(); } catch { } }
                        try { el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); } catch { }
                        return true;
                    }
                }

                const firstTile = rowsContainer?.querySelector?.('.tile');
                if (firstTile && isElementVisible(firstTile)) {
                    try { firstTile.focus({ preventScroll: true }); } catch { try { firstTile.focus(); } catch { } }
                    try { firstTile.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' }); } catch { }
                    return true;
                }
            } catch { }
            return false;
        }

        function isContentBelowTopbar(el) {
            try {
                const topbar = document.querySelector('.topbar');
                if (!topbar || !el?.getBoundingClientRect) return false;
                const topbarRect = topbar.getBoundingClientRect();
                const r = el.getBoundingClientRect();
                // Consider it content if it's clearly below the topbar.
                return r.top >= (topbarRect.bottom + 4);
            } catch { }
            return false;
        }

        function focusBestCandidate(fromEl, direction, candidates) {
            if (!candidates || !candidates.length) return null;

            const active = fromEl && fromEl.getBoundingClientRect ? fromEl : null;
            const fromRect = active ? active.getBoundingClientRect() : null;
            const fromCx = fromRect ? (fromRect.left + fromRect.right) / 2 : 0;
            const fromCy = fromRect ? (fromRect.top + fromRect.bottom) / 2 : 0;

            let best = null;
            let bestScore = Infinity;

            for (const el of candidates) {
                if (!el || el === fromEl) continue;
                const r = el.getBoundingClientRect();
                const cx = (r.left + r.right) / 2;
                const cy = (r.top + r.bottom) / 2;
                const dx = cx - fromCx;
                const dy = cy - fromCy;

                const eps = 1;
                let inDir = false;
                let primary = 0;
                let secondary = 0;

                if (direction === 'left') {
                    inDir = dx < -eps;
                    primary = Math.abs(dx);
                    secondary = Math.abs(dy);
                } else if (direction === 'right') {
                    inDir = dx > eps;
                    primary = Math.abs(dx);
                    secondary = Math.abs(dy);
                } else if (direction === 'up') {
                    inDir = dy < -eps;
                    primary = Math.abs(dy);
                    secondary = Math.abs(dx);
                } else if (direction === 'down') {
                    inDir = dy > eps;
                    primary = Math.abs(dy);
                    secondary = Math.abs(dx);
                }

                if (!inDir) continue;

                // For vertical movement, strongly prefer staying in the same column.
                const alignWeight = (direction === 'up' || direction === 'down') ? 0.8 : 0.35;
                const score = primary + secondary * alignWeight;
                if (score < bestScore) {
                    bestScore = score;
                    best = el;
                }
            }

            if (best) {
                try { best.focus({ preventScroll: true }); } catch { try { best.focus(); } catch { } }
                // Smooth vertical scrolling (up/down) feels more natural on TV.
                try {
                    const isVertical = direction === 'up' || direction === 'down';
                    best.scrollIntoView({
                        behavior: isVertical ? 'smooth' : 'auto',
                        block: isVertical ? 'center' : 'nearest',
                        inline: 'nearest'
                    });
                } catch {
                    try { best.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch { }
                }
            }
            return best;
        }

        function makeClickableFocusable(el) {
            if (!el || !(el instanceof HTMLElement)) return;
            if (el.dataset && el.dataset.dpadBound === '1') return;

            const tag = (el.tagName || '').toUpperCase();
            const isNative = tag === 'BUTTON' || tag === 'A' || tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA';
            if (!isNative && !el.hasAttribute('tabindex')) el.tabIndex = 0;
            if (!isNative && !el.getAttribute('role')) el.setAttribute('role', 'button');

            // Only synthesize Enter->click for non-native controls.
            if (!isNative) {
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        try { el.click(); } catch { }
                    }
                });
            }

            if (el.dataset) el.dataset.dpadBound = '1';
        }

        const DPAD_CLICKABLE_SELECTOR = [
            // App-specific focusables
            '.tile',
            '.streamItem',
            '.tv-main-folder-btn',
            '.episode-card',
            '.tv-card',
            '.tv-history-item',
            '#tvPlayerContent',
            '#tvFullscreenBadge',
            '#tvPlayPauseBtn',
            '.catalogRow'
        ].join(',');

        function applyRemoteFocusability(rootNode) {
            const root = rootNode && rootNode.querySelectorAll ? rootNode : document;
            const toFix = root.querySelectorAll(DPAD_CLICKABLE_SELECTOR);
            toFix.forEach(makeClickableFocusable);
        }

        // Keep dynamically-rendered TV items focusable
        try {
            applyRemoteFocusability(document);
            try { bindTvReadonlyInputs(document); } catch { }
            const obs = new MutationObserver((mutations) => {
                for (const m of mutations) {
                    for (const node of m.addedNodes || []) {
                        if (!(node instanceof HTMLElement)) continue;
                        // Only mark known interactive nodes as focusable.
                        // Avoid making layout containers focusable (causes focus to land "between" tiles).
                        try {
                            if (node.matches && node.matches(DPAD_CLICKABLE_SELECTOR)) {
                                makeClickableFocusable(node);
                            }
                        } catch { }
                        applyRemoteFocusability(node);
                        try { bindTvReadonlyInputs(node); } catch { }
                    }
                }
            });
            obs.observe(document.body, { childList: true, subtree: true });
        } catch { }

        function getIsTvModeForBack() {
            try {
                if (document.documentElement.classList.contains('tv-compact')) return true;
                const ua = String(navigator.userAgent || '');
                if (!/Android/i.test(ua)) return false;
                const dpr = Math.max(1, Number(window.devicePixelRatio) || 1);
                const w = Math.max(Number(screen.width) || 0, Number(screen.height) || 0) * dpr;
                const h = Math.min(Number(screen.width) || 0, Number(screen.height) || 0) * dpr;
                return w >= 1280 && h >= 720;
            } catch { }
            return false;
        }

        function getIsAndroidAppShell() {
            try {
                const ua = String(navigator.userAgent || '');
                if (!/Android/i.test(ua)) return false;
                return isLocalAppShell();
            } catch { }
            return false;
        }

        function getCapacitorAppPlugin() {
            try {
                const cap = window.Capacitor;
                const plugins = cap && cap.Plugins ? cap.Plugins : null;
                return plugins && plugins.App ? plugins.App : null;
            } catch { }
            return null;
        }

        // Track when focus first enters the top menu so BACK can reliably jump to the
        // current tab's menu item even if Android initially focuses Home.
        try {
            if (!window.__tvTopMenuFocusTrackerBound) {
                window.__tvTopMenuFocusTrackerBound = true;
                window.__tvTopMenuEnteredAt = 0;
                window.__tvWasOnTopMenu = false;
                document.addEventListener('focusin', (e) => {
                    try {
                        const t = e && e.target ? e.target : null;
                        const id = t && t.id ? String(t.id) : '';
                        const isTop = id === 'tabHome' || id === 'tabMovies' || id === 'tabSeries' || id === 'tabAnime' || id === 'tabTV' || id === 'tabMyList' || id === 'tabSettings';
                        if (isTop && !window.__tvWasOnTopMenu) window.__tvTopMenuEnteredAt = Date.now();
                        window.__tvWasOnTopMenu = isTop;
                    } catch { }
                }, true);
            }
        } catch { }

        function handleBackAction({ allowExit } = { allowExit: false }) {
            const isTvMode = getIsTvModeForBack();
            const isAndroidAppShell = getIsAndroidAppShell();
            const shouldIntercept = isTvMode || isAndroidAppShell;
            const now = Date.now();
            if (!window.__tvLastBackAt) window.__tvLastBackAt = 0;

            // 0) If the native fullscreen player is active, BACK exits playback first.
            try {
                if ((window.__nativePlayerActive || window.__nativePlayerStarting) && typeof window.exitNativeVideo === 'function') {
                    window.exitNativeVideo();
                    return true;
                }
            } catch { }

            // 0) TV long-press menu should close first
            try {
                const hold = window.__tvHoldMenuEl;
                if (hold && hold.isConnected && hold.style.display !== 'none') {
                    hold.style.display = 'none';
                    return true;
                }
            } catch { }

            // 0) Brand menu dropdown should close first
            try {
                if (window.__brandMenuIsOpen && typeof window.__closeBrandMenu === 'function') {
                    window.__closeBrandMenu();
                    return true;
                }
            } catch { }

            // 0) Trailer overlay should exit first
            try {
                if (window.__trailerOverlayEl && window.__trailerOverlayEl.isConnected) {
                    if (typeof window.__closeTrailerOverlay === 'function') window.__closeTrailerOverlay();
                    else {
                        try { window.__trailerOverlayEl.remove(); } catch { }
                        window.__trailerOverlayEl = null;
                    }
                    return true;
                }
            } catch { }

            // 1) Player overlay should exit first
            if (playerIsActive) {
                exitPlayerOverlay({ stop: true }).catch(() => { });
                return true;
            }
            // 2) Modal should close
            if (modalBackdrop && modalBackdrop.style.display === 'flex') {
                closeModal();
                return true;
            }
            // 3) Exit browser fullscreen if any
            if (document.fullscreenElement && typeof document.exitFullscreen === 'function') {
                document.exitFullscreen().catch(() => { });
                return true;
            }

            if (!shouldIntercept) return false;

            const activeEl = document.activeElement;
            const activeId = activeEl && activeEl.id ? String(activeEl.id) : '';
            const isFocusOnTopMenu = activeId === 'tabHome' || activeId === 'tabMovies' || activeId === 'tabSeries' || activeId === 'tabAnime' || activeId === 'tabTV' || activeId === 'tabMyList' || activeId === 'tabSettings';

            const btnIdMap = {
                home: 'tabHome',
                movies: 'tabMovies',
                series: 'tabSeries',
                anime: 'tabAnime',
                tv: 'tabTV',
                mylist: 'tabMyList',
                settings: 'tabSettings'
            };

            // Prefer the last real content tab if currentTopTab was reset to home by the platform.
            const preferredTab = (() => {
                const lastContent = window.__tvLastContentTab;
                if (currentTopTab && currentTopTab !== 'home') return currentTopTab;
                if (lastContent) return lastContent;
                return currentTopTab || 'home';
            })();

            const targetBtnId = btnIdMap[preferredTab] || 'tabHome';
            const targetBtn = document.getElementById(targetBtnId);
            const activeIsPreferred = isFocusOnTopMenu && activeId === targetBtnId;

            console.log('[BACK] preferredTab=' + preferredTab + ', currentTopTab=' + currentTopTab + ', activeId=' + activeId + ', isFocusOnTopMenu=' + isFocusOnTopMenu + ', activeIsPreferred=' + activeIsPreferred);

            // 4) From anywhere in content OR if focus is on a different top tab: jump to the preferred menu button
            if (!activeIsPreferred) {
                try {
                    console.log('[BACK] Will focus button: ' + targetBtnId + ', found=' + !!targetBtn);
                    if (targetBtn) {
                        window.__tvBackIgnoreNextTabSwitch = true;
                        targetBtn.focus();
                        window.__tvLastBackAt = 0;
                        console.log('[BACK] Focused button: ' + targetBtnId);
                    }
                } catch (e) {
                    console.error('[BACK] Error:', e);
                }
                return true;
            }

            // 5) If already focused on the preferred top menu item: single BACK does nothing; double BACK exits.
            if (now - window.__tvLastBackAt < 1000) {
                window.__tvLastBackAt = 0;
                if (allowExit) {
                    const app = getCapacitorAppPlugin();
                    try { if (app && typeof app.exitApp === 'function') app.exitApp(); } catch { }
                }
                return true;
            }
            window.__tvLastBackAt = now;
            return true;
        }

        // Native Android back button (Chromecast remote) is not always delivered as a JS keydown.
        // Register Capacitor listener with retry mechanism (Capacitor may not be ready immediately).
        (function registerCapacitorBackButton() {
            let attempts = 0;
            const maxAttempts = 50;
            const interval = setInterval(() => {
                attempts++;
                try {
                    const cap = window.Capacitor;
                    const app = cap && cap.Plugins && cap.Plugins.App ? cap.Plugins.App : null;
                    if (app && typeof app.addListener === 'function') {
                        app.addListener('backButton', () => {
                            console.log('[BACK] Capacitor backButton event fired');
                            handleBackAction({ allowExit: true });
                        });
                        console.log('[BACK SETUP] Listener registered successfully after ' + attempts + ' attempts');
                        clearInterval(interval);
                    } else if (attempts >= maxAttempts) {
                        console.warn('[BACK SETUP] Capacitor App plugin not available after ' + maxAttempts + ' attempts. Capacitor=' + !!cap + ', Plugins=' + !!(cap && cap.Plugins) + ', App=' + !!app);
                        clearInterval(interval);
                    }
                } catch (e) {
                    if (attempts >= maxAttempts) {
                        console.error('[BACK SETUP] Error after ' + maxAttempts + ' attempts: ' + e);
                        clearInterval(interval);
                    }
                }
            }, 100);
        })();

        // ---------- TV interface DPAD rules (3 columns) ----------
        // Treat TV as 3 vertical lists: Main folders (left), Subfolders (middle), Channels (right).
        // UP/DOWN navigates within the active column; LEFT/RIGHT switches columns.
        const __tv3ColLastFocus = { main: null, sub: null, channels: null };

        // TV -> Movies: Long-press OK shows a small favorites dropdown.
        function ensureTvHoldMenu() {
            try {
                if (window.__tvHoldMenuEl && window.__tvHoldMenuEl.isConnected) return window.__tvHoldMenuEl;

                const el = document.createElement('div');
                el.id = 'tvHoldMenu';
                el.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    z-index: 60;
                    display: none;
                    min-width: 180px;
                    background: rgba(15, 23, 42, 0.95);
                    border: 1px solid rgba(59, 130, 246, 0.45);
                    border-radius: 8px;
                    padding: 8px;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.45);
                `;

                // Keep clicks inside from closing the menu.
                el.addEventListener('pointerdown', (e) => {
                    try { e.stopPropagation(); } catch { }
                });

                // Close when clicking outside.
                document.addEventListener('pointerdown', (e) => {
                    try {
                        const m = window.__tvHoldMenuEl;
                        if (!m || m.style.display === 'none') return;
                        if (e && e.target && m.contains(e.target)) return;
                        m.style.display = 'none';
                    } catch { }
                }, true);

                document.body.appendChild(el);
                window.__tvHoldMenuEl = el;
                return el;
            } catch { }
            return null;
        }

        function openTvHoldFavoriteMenu({ item, favType, anchorEl }) {
            try {
                const menu = ensureTvHoldMenu();
                if (!menu) return false;

                const isFav = isFavorite(item, favType);
                menu.innerHTML = '';

                const btn = document.createElement('button');
                btn.tabIndex = 0;
                btn.style.cssText = `
                    width: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 10px;
                    padding: 10px 12px;
                    border-radius: 6px;
                    border: 1px solid rgba(59, 130, 246, 0.35);
                    background: rgba(59, 130, 246, 0.10);
                    color: #e2e8f0;
                    font-weight: 700;
                    cursor: pointer;
                `;

                const label = document.createElement('span');
                label.textContent = isFav ? 'Remove from Favorites' : 'Add to Favorites';
                const icon = document.createElement('span');
                icon.textContent = isFav ? 'â˜…' : 'â˜†';
                icon.style.cssText = 'font-size:14px; color:#fbbf24;';

                btn.appendChild(label);
                btn.appendChild(icon);

                const doToggle = () => {
                    try { toggleFavorite(item, favType); } catch { }
                    try { menu.style.display = 'none'; } catch { }
                };

                btn.addEventListener('click', (e) => {
                    try { e.preventDefault(); e.stopPropagation(); } catch { }
                    doToggle();
                });
                btn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        try { e.preventDefault(); e.stopPropagation(); } catch { }
                        doToggle();
                    }
                });

                menu.appendChild(btn);

                // Position near the anchor.
                let x = 24;
                let y = 88;
                try {
                    const r = anchorEl && anchorEl.getBoundingClientRect ? anchorEl.getBoundingClientRect() : null;
                    if (r) {
                        x = Math.min(window.innerWidth - 220, Math.max(12, r.right - 180));
                        y = Math.min(window.innerHeight - 120, Math.max(12, r.top));
                    }
                } catch { }
                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;
                menu.style.display = 'block';

                // Auto-select the first (and only) action so user can press OK once.
                try {
                    requestAnimationFrame(() => {
                        try { btn.focus({ preventScroll: true }); } catch { try { btn.focus(); } catch { } }
                    });
                } catch {
                    try { btn.focus({ preventScroll: true }); } catch { try { btn.focus(); } catch { } }
                }
                return true;
            } catch { }
            return false;
        }

        function isTvWrapVisible() {
            try {
                const w = document.getElementById('tvWrap');
                return !!(w && w.style.display !== 'none');
            } catch { }
            return false;
        }

        function getTvColumnFromElement(el) {
            try {
                if (!el || !el.closest) return null;
                if (el.closest('#tvMainCategories')) return 'main';
                if (el.closest('#tvSubfolders')) return 'sub';
                if (el.closest('#tvChannelsContainer') || el.closest('#tvPlayerContainer')) return 'channels';
            } catch { }
            return null;
        }

        function tvFocus(el) {
            if (!el || !(el instanceof HTMLElement)) return false;
            try { el.focus({ preventScroll: true }); } catch { try { el.focus(); } catch { } }
            try { el.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch { }
            return true;
        }

        function getTvColumnItems(col) {
            try {
                if (col === 'main') {
                    const list = document.getElementById('tvMainCategoriesList');
                    if (!list) return [];
                    return Array.from(list.querySelectorAll('.tv-main-folder-btn'))
                        .filter((x) => x instanceof HTMLElement && isElementVisible(x));
                }
                if (col === 'sub') {
                    const list = document.getElementById('tvSubfoldersList');
                    if (!list) return [];
                    // Include native focusables too (TV Search input + Search button).
                    return Array.from(list.querySelectorAll('button, input, [tabindex]:not([tabindex="-1"])'))
                        .filter((x) => x instanceof HTMLElement && isElementVisible(x));
                }
                if (col === 'channels') {
                    const container = document.getElementById('tvChannelsContainer');
                    if (!container) return [];

                    // Only force the deterministic 3-column behavior for Live TV (vertical list).
                    // Movies/Series use a poster grid and should keep the spatial navigation.
                    if (tvSelectedMainFolder !== 'Live TV') return [];

                    const q = '[data-tv-dpad-kind="channel-name"],[data-tv-dpad-kind="channel-fav"]';
                    return Array.from(container.querySelectorAll(q))
                        .filter((x) => x instanceof HTMLElement && isElementVisible(x));
                }
            } catch { }
            return [];
        }

        function tvGetIndexInItems(activeEl, items) {
            try {
                if (!items || !items.length) return -1;
                return items.indexOf(activeEl);
            } catch { }
            return -1;
        }

        function tvFindByDpadIndex(items, dpadIndex, kind) {
            try {
                const idx = String(dpadIndex);
                const k = kind ? String(kind) : '';
                const found = items.find((el) => {
                    try {
                        if (!(el instanceof HTMLElement)) return false;
                        if (k && String(el.dataset?.tvDpadKind || '') !== k) return false;
                        return String(el.dataset?.tvDpadIndex || '') === idx;
                    } catch { }
                    return false;
                });
                return found || null;
            } catch { }
            return null;
        }

        function handleTv3ColumnNav(e, dir) {
            try {
                if (!isTvWrapVisible()) return false;
                if (currentTopTab !== 'tv') return false;

                const active = document.activeElement;
                const col = getTvColumnFromElement(active);
                if (!col) return false;

                // Always allow deterministic nav inside main/sub columns.
                // Only handle channels column deterministically when it's Live TV, Movies, or Series.
                if (col === 'channels' && tvSelectedMainFolder !== 'Live TV' && tvSelectedMainFolder !== 'Movies' && tvSelectedMainFolder !== 'Series') return false;

                if (col && active && active instanceof HTMLElement) {
                    __tv3ColLastFocus[col] = active;
                }

                // Intra-row behavior for Live TV: RIGHT from name -> star, LEFT from star -> name.
                if (col === 'channels' && tvSelectedMainFolder === 'Live TV') {
                    const kind = String(active?.dataset?.tvDpadKind || '');
                    const idx = String(active?.dataset?.tvDpadIndex || '');
                    if ((dir === 'right') && kind === 'channel-name') {
                        const items = getTvColumnItems('channels');
                        const star = tvFindByDpadIndex(items, idx, 'channel-fav');
                        if (star) {
                            e.preventDefault();
                            e.stopPropagation();
                            return tvFocus(star);
                        }
                    }
                    if ((dir === 'left') && kind === 'channel-fav') {
                        const items = getTvColumnItems('channels');
                        const name = tvFindByDpadIndex(items, idx, 'channel-name');
                        if (name) {
                            e.preventDefault();
                            e.stopPropagation();
                            return tvFocus(name);
                        }
                    }
                }

                // LEFT/RIGHT switches columns.
                if (dir === 'left' || dir === 'right') {
                    // TV -> Movies/Series: prefer simple grid movement inside poster tiles.
                    try {
                        if (col === 'channels' && (tvSelectedMainFolder === 'Movies' || tvSelectedMainFolder === 'Series')) {
                            const container = document.getElementById('tvChannelsContainer');
                            const activeCard = (active && active.classList && active.classList.contains('tv-card')) ? active
                                : (active && active.closest ? active.closest('.tv-card') : null);
                            if (container && activeCard && container.contains(activeCard)) {
                                const cards = Array.from(container.querySelectorAll('.tv-card'))
                                    .filter((x) => x instanceof HTMLElement && isElementVisible(x));
                                if (cards.length) {
                                    const rects = cards
                                        .map((c) => ({ el: c, r: c.getBoundingClientRect() }))
                                        .filter((x) => x.r && x.r.width > 0 && x.r.height > 0)
                                        .sort((a, b) => (a.r.top - b.r.top) || (a.r.left - b.r.left));

                                    const rows = [];
                                    const rowTol = 24;
                                    for (const it of rects) {
                                        const last = rows[rows.length - 1];
                                        if (!last) { rows.push([it]); continue; }
                                        const lastTop = last[0].r.top;
                                        if (Math.abs(it.r.top - lastTop) <= rowTol) last.push(it);
                                        else rows.push([it]);
                                    }
                                    rows.forEach((row) => row.sort((a, b) => a.r.left - b.r.left));

                                    let rowIdx = -1;
                                    let colIdx = -1;
                                    for (let i = 0; i < rows.length; i++) {
                                        const j = rows[i].findIndex((x) => x.el === activeCard);
                                        if (j >= 0) { rowIdx = i; colIdx = j; break; }
                                    }

                                    if (rowIdx >= 0) {
                                        if (dir === 'left') {
                                            if (colIdx > 0) {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                return tvFocus(rows[rowIdx][colIdx - 1].el);
                                            }
                                            // At left edge: allow column switching to subfolders.
                                        }
                                        if (dir === 'right') {
                                            if (colIdx < rows[rowIdx].length - 1) {
                                                e.preventDefault();
                                                e.stopPropagation();
                                                return tvFocus(rows[rowIdx][colIdx + 1].el);
                                            }
                                            // At right edge: consume (no random jump).
                                            e.preventDefault();
                                            e.stopPropagation();
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    } catch { }

                    let targetCol = null;
                    if (col === 'main') {
                        if (dir === 'right') targetCol = 'sub';
                    } else if (col === 'sub') {
                        if (dir === 'left') targetCol = 'main';
                        if (dir === 'right') targetCol = 'channels';
                    } else if (col === 'channels') {
                        if (dir === 'left') targetCol = 'sub';
                    }

                    if (targetCol) {
                        const items = getTvColumnItems(targetCol);
                        const remembered = __tv3ColLastFocus[targetCol];
                        const target = (remembered && items.includes(remembered)) ? remembered : (items[0] || null);
                        if (target) {
                            e.preventDefault();
                            e.stopPropagation();
                            return tvFocus(target);
                        }
                    }
                    return false;
                }

                // UP/DOWN navigates within a column.
                if (dir === 'up' || dir === 'down') {
                    // TV -> Movies/Series: simple grid movement inside poster tiles.
                    try {
                        if (col === 'channels' && (tvSelectedMainFolder === 'Movies' || tvSelectedMainFolder === 'Series')) {
                            const container = document.getElementById('tvChannelsContainer');
                            const activeCard = (active && active.classList && active.classList.contains('tv-card')) ? active
                                : (active && active.closest ? active.closest('.tv-card') : null);
                            if (container && activeCard && container.contains(activeCard)) {
                                const cards = Array.from(container.querySelectorAll('.tv-card'))
                                    .filter((x) => x instanceof HTMLElement && isElementVisible(x));
                                if (cards.length) {
                                    const rects = cards
                                        .map((c) => ({ el: c, r: c.getBoundingClientRect() }))
                                        .filter((x) => x.r && x.r.width > 0 && x.r.height > 0)
                                        .sort((a, b) => (a.r.top - b.r.top) || (a.r.left - b.r.left));

                                    const rows = [];
                                    const rowTol = 24;
                                    for (const it of rects) {
                                        const last = rows[rows.length - 1];
                                        if (!last) { rows.push([it]); continue; }
                                        const lastTop = last[0].r.top;
                                        if (Math.abs(it.r.top - lastTop) <= rowTol) last.push(it);
                                        else rows.push([it]);
                                    }
                                    rows.forEach((row) => row.sort((a, b) => a.r.left - b.r.left));

                                    let rowIdx = -1;
                                    let colIdx = -1;
                                    for (let i = 0; i < rows.length; i++) {
                                        const j = rows[i].findIndex((x) => x.el === activeCard);
                                        if (j >= 0) { rowIdx = i; colIdx = j; break; }
                                    }

                                    if (rowIdx >= 0) {
                                        const targetRowIdx = dir === 'up' ? rowIdx - 1 : rowIdx + 1;
                                        if (targetRowIdx < 0 || targetRowIdx >= rows.length) {
                                            // At top/bottom: consume (no jump).
                                            e.preventDefault();
                                            e.stopPropagation();
                                            return true;
                                        }
                                        const targetRow = rows[targetRowIdx];
                                        const targetColIdx = Math.max(0, Math.min(targetRow.length - 1, colIdx));
                                        const target = targetRow[targetColIdx]?.el;
                                        if (target) {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            return tvFocus(target);
                                        }
                                    }
                                }
                            }
                        }
                    } catch { }

                    let items = getTvColumnItems(col);
                    if (!items.length) return false;

                    // Live TV channels: treat channel names and stars as separate vertical lists.
                    // - If a channel name is focused (default), UP/DOWN moves between channel names ONLY.
                    // - If a star is focused, UP/DOWN moves between stars ONLY.
                    try {
                        if (col === 'channels' && tvSelectedMainFolder === 'Live TV') {
                            const kind = String(active?.dataset?.tvDpadKind || 'channel-name');
                            if (kind === 'channel-fav') {
                                items = items.filter((x) => String(x?.dataset?.tvDpadKind || '') === 'channel-fav');
                            } else {
                                items = items.filter((x) => String(x?.dataset?.tvDpadKind || '') === 'channel-name');
                            }
                        }
                    } catch { }
                    if (!items.length) return false;

                    // If focus is on the mini player region, DOWN goes into the channel list.
                    try {
                        if (col === 'channels' && active && active.closest && active.closest('#tvPlayerContainer')) {
                            const first = items.find((x) => String(x?.dataset?.tvDpadKind || '') === 'channel-name') || items[0];
                            if (first) {
                                e.preventDefault();
                                e.stopPropagation();
                                return tvFocus(first);
                            }
                        }
                    } catch { }

                    const activeIdx = tvGetIndexInItems(active, items);
                    let nextIdx = activeIdx;
                    if (activeIdx < 0) nextIdx = 0;
                    else nextIdx = dir === 'up' ? activeIdx - 1 : activeIdx + 1;

                    nextIdx = Math.max(0, Math.min(items.length - 1, nextIdx));
                    const target = items[nextIdx];
                    if (target) {
                        e.preventDefault();
                        e.stopPropagation();
                        return tvFocus(target);
                    }
                }
            } catch { }
            return false;
        }

        document.addEventListener('keydown', (e) => {
            // Android TV back key sometimes comes as keyCode 461.
            // Some devices use keyCode=4 (Android BACK) when it is delivered to JS.
            const isBack = e.key === 'Escape' || e.key === 'Backspace' || e.key === 'GoBack' || e.key === 'Back' || e.keyCode === 461 || e.keyCode === 4;

            // If native playback is active, do not consume DPAD keys in the WebView.
            // Let the native player fragment handle remote controls. We only keep BACK
            // as a fallback exit path when the event is delivered to JS.
            if ((window.__nativePlayerActive || window.__nativePlayerStarting) && !isBack) {
                return;
            }

            if (isBack) {
                // If we handle it, prevent default browser history/system behavior.
                const handled = handleBackAction({ allowExit: false });
                if (handled) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                return;
            }

            if (isTypingTarget(e.target)) return;

            // Some Android TV remotes emit keyCodes (19-22) with e.key='Unidentified'.
            const dirKeyMap = {
                ArrowLeft: 'left',
                ArrowRight: 'right',
                ArrowUp: 'up',
                ArrowDown: 'down',
                Left: 'left',
                Right: 'right',
                Up: 'up',
                Down: 'down'
            };
            const dirKeyCodeMap = {
                21: 'left',
                22: 'right',
                19: 'up',
                20: 'down'
            };
            const dir = dirKeyMap[e.key] || dirKeyCodeMap[e.keyCode];
            if (!dir) return;

            // Deterministic TV navigation (3 columns). If it handles the key, stop here.
            if (handleTv3ColumnNav(e, dir)) {
                return;
            }

            const root = getNavRoot();
            let candidates = getFocusableCandidates(root);
            if (!candidates.length) return;

            const active = document.activeElement;
            if (!active || active === document.body || active === document.documentElement) {
                const first = candidates
                    .slice()
                    .sort((a, b) => {
                        const ra = a.getBoundingClientRect();
                        const rb = b.getBoundingClientRect();
                        if (ra.top !== rb.top) return ra.top - rb.top;
                        return ra.left - rb.left;
                    })[0];
                if (first) {
                    e.preventDefault();
                    try { first.focus({ preventScroll: true }); } catch { try { first.focus(); } catch { } }
                    try { first.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch { }
                }
                return;
            }

            e.preventDefault();

            // Brand menu dropdown navigation (Refresh/Settings)
            // While the dropdown is open, DPAD should stay within its items.
            try {
                const dd = document.getElementById('brandMenuDropdown');
                const isInBrandDropdown = (el) => {
                    try {
                        if (!dd || !el || !el.closest) return false;
                        return el.closest('#brandMenuDropdown') === dd;
                    } catch { }
                    return false;
                };
                if (window.__brandMenuIsOpen && dd) {
                    // If focus is on the menu button, DOWN moves into the dropdown.
                    if ((dir === 'down') && document.activeElement && document.activeElement.id === 'brandMenuBtn') {
                        const items = Array.from(dd.querySelectorAll('button, [tabindex], a, input, select, textarea'))
                            .filter((x) => x && x instanceof HTMLElement && isElementVisible(x));
                        if (items.length) {
                            try { items[0].focus({ preventScroll: true }); } catch { try { items[0].focus(); } catch { } }
                            return;
                        }
                    }

                    // If focus is inside the dropdown, keep navigation within the dropdown.
                    if (isInBrandDropdown(active)) {
                        const ddCandidates = candidates.filter((c) => isInBrandDropdown(c));
                        focusBestCandidate(active, dir, ddCandidates);
                        return;
                    }
                }
            } catch { }

            // Topbar navigation rules:
            // - LEFT/RIGHT stays within the topbar (prevents "tab -> catalog" jumps)
            // - DOWN goes into content (prefer saved tile)
            // - UP does nothing
            if (isInTopbar(active)) {
                if (dir === 'left' || dir === 'right') {
                    candidates = candidates.filter((c) => isInTopbar(c));
                    focusBestCandidate(active, dir, candidates);
                    return;
                }
                if (dir === 'down') {
                    if (focusBestContentForCurrentTab()) return;
                    candidates = candidates.filter((c) => !isInTopbar(c));
                    focusBestCandidate(active, dir, candidates);
                    return;
                }
                if (dir === 'up') {
                    return;
                }
            }

            // Content -> Topbar transition: if we're effectively at the first visible row, UP should return to the menu.
            if (dir === 'up' && !isInTopbar(active) && shouldAllowUpIntoTopbar(active)) {
                const btn = getActiveTopTabButton();
                if (btn && isElementVisible(btn)) {
                    try { btn.focus({ preventScroll: true }); } catch { try { btn.focus(); } catch { } }
                    try { btn.scrollIntoView({ block: 'nearest', inline: 'nearest' }); } catch { }
                    return;
                }
            }

            // Settings: keep LEFT/RIGHT movement within the same logical row/card.
            // This prevents "Reset -> Save goes UP" and other inconsistent jumps.
            if ((dir === 'left' || dir === 'right') && isInSettings(active)) {
                try {
                    const row = active.closest && active.closest('.dpadRow');
                    if (row) {
                        candidates = candidates.filter((c) => c.closest && c.closest('.dpadRow') === row);
                    } else {
                        const card = active.closest && active.closest('.settingsCard');
                        if (card) candidates = candidates.filter((c) => c.closest && c.closest('.settingsCard') === card);
                    }
                } catch { }
            }

            // Keep DPAD Up within content unless we're near the top.
            if (dir === 'up' && !isInTopbar(active) && !shouldAllowUpIntoTopbar(active)) {
                candidates = candidates.filter((c) => !isInTopbar(c));
            }

            // Keep DPAD Left/Right within content rows.
            // This prevents jumping from tiles to topbar buttons (tabs/settings) when navigating horizontally.
            if ((dir === 'left' || dir === 'right') && !isInTopbar(active) && isContentBelowTopbar(active)) {
                candidates = candidates.filter((c) => !isInTopbar(c));
            }

            focusBestCandidate(active, dir, candidates);
        }, true);

        async function searchYouTubeTrailer(title, year) {
            try {
                // Use working Invidious instances
                const invidiousInstances = [
                    'https://invidious.io.lol',
                    'https://invidious.fdn.fr',
                    'https://inv.nadeko.net',
                    'https://invidious.private.coffee'
                ];
                
                const query = year ? `${title} ${year} official trailer` : `${title} official trailer`;
                
                for (const instance of invidiousInstances) {
                    try {
                        const url = `${instance}/api/v1/search?q=${encodeURIComponent(query)}&type=video`;
                        console.log('[Trailer] Trying instance:', instance);
                        const response = await fetch(url, { signal: AbortSignal.timeout(5000) });
                        if (!response.ok) {
                            console.warn('[Trailer] Instance returned status:', response.status);
                            continue;
                        }
                        
                        const results = await response.json();
                        if (results && Array.isArray(results) && results.length > 0) {
                            console.log('[Trailer] Found results:', results.length);
                            // Find first video that looks like a trailer
                            for (const video of results.slice(0, 5)) {
                                const videoTitle = (video.title || '').toLowerCase();
                                if (videoTitle.includes('trailer')) {
                                    console.log('[Trailer] Found trailer:', video.title);
                                    return video.videoId;
                                }
                            }
                            // If no trailer found, return first result
                            console.log('[Trailer] Using first result:', results[0].title);
                            return results[0].videoId;
                        }
                    } catch (e) {
                        console.warn(`[Trailer] Instance ${instance} failed:`, e.message);
                        continue;
                    }
                }
                
                console.warn('[Trailer] All instances failed, no results found');
                return null;
            } catch (e) {
                console.error('[Trailer] Search error:', e);
                return null;
            }
        }

        function sanitizeTrailerTitle(raw) {
            try {
                let t = String(raw || '').trim();
                if (!t) return '';
                // Remove file extensions
                t = t.replace(/\.(mkv|mp4|avi|mov|m4v|webm|ts|m3u8|wmv)\b/ig, '');
                // Replace separators with spaces
                t = t.replace(/[._]+/g, ' ');
                // Drop bracketed tags like [1080p] (WEBRip) etc
                t = t.replace(/\[[^\]]*\]/g, ' ');
                t = t.replace(/\([^\)]*\)/g, ' ');
                // Common release/quality tokens
                t = t.replace(/\b(2160p|1440p|1080p|720p|480p|4k|uhd|hdr10\+?|hdr|dv|dolby\s*vision|webrip|web\-?dl|bluray|brrip|dvdrip|hdtv|x264|x265|hevc|aac|dts|truehd|atmos|remux|proper|repack|extended|uncut)\b/ig, ' ');
                // Collapse whitespace
                t = t.replace(/\s{2,}/g, ' ').trim();
                return t;
            } catch {
                return String(raw || '').trim();
            }
        }

        function extractYouTubeIdFromUrlLike(u) {
            try {
                const s = String(u || '');
                const m1 = s.match(/[?&]v=([a-zA-Z0-9_-]{6,})/);
                if (m1) return m1[1];
                const m2 = s.match(/youtu\.be\/([a-zA-Z0-9_-]{6,})/);
                if (m2) return m2[1];
                const m3 = s.match(/\/embed\/([a-zA-Z0-9_-]{6,})/);
                if (m3) return m3[1];
            } catch { }
            return null;
        }

        async function searchPipedTrailer(title, year) {
            try {
                const instances = [
                    'https://piped.video',
                    'https://piped.video.privacy.com.de',
                    'https://piped.adminforge.de'
                ];
                const query = year ? `${title} ${year} official trailer` : `${title} official trailer`;
                for (const base of instances) {
                    try {
                        const url = `${base}/api/v1/search?q=${encodeURIComponent(query)}&filter=videos`;
                        const res = await fetch(url, { signal: AbortSignal.timeout(5000) });
                        if (!res.ok) continue;
                        const data = await res.json();
                        const items = Array.isArray(data) ? data : (Array.isArray(data?.items) ? data.items : []);
                        if (!items.length) continue;
                        for (const it of items.slice(0, 6)) {
                            const vid = it?.videoId || it?.id || extractYouTubeIdFromUrlLike(it?.url) || extractYouTubeIdFromUrlLike(it?.link);
                            if (vid) return vid;
                        }
                    } catch {
                        continue;
                    }
                }
            } catch { }
            return null;
        }

        async function searchYouTubeTrailerSimple(title, year) {
            // Last resort: construct search query for a YouTube search page
            const query = year ? `${title} ${year} official trailer` : `${title} official trailer`;
            return encodeURIComponent(query);
        }

        async function playTrailer(videoId) {
            if (!videoId) return;
            
            try {
                // Check if videoId looks like a search query (encoded) or actual video ID
                if (videoId.includes('%20') || videoId.includes('+')) {
                    // It's a search query - open YouTube search in new window
                    const url = `https://www.youtube.com/results?search_query=${videoId}`;
                    
                    // Try to use Electron shell API if available, otherwise use window.open
                    if (window.electronAPI?.openExternal) {
                        await window.electronAPI.openExternal(url);
                    } else if (window.mediaAPI?.openExternal) {
                        await window.mediaAPI.openExternal(url);
                    } else {
                        window.open(url, '_blank', 'noopener,noreferrer');
                    }
                    
                    setStatus('Opening YouTube trailer search in browser...', false);
                } else {
                    // It's a video ID - prefer opening a direct watch URL (more reliable on TV)
                    const watchUrl = `https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}`;

                    if (window.electronAPI?.openExternal) {
                        await window.electronAPI.openExternal(watchUrl);
                        return;
                    }
                    if (window.mediaAPI?.openExternal) {
                        await window.mediaAPI.openExternal(watchUrl);
                        return;
                    }

                    // Fallback: embed inside an overlay
                    // Note: keep this overlay inside the modal DPAD navigation scope.
                    const overlay = document.createElement('div');
                    overlay.id = 'trailerOverlay';
                    overlay.setAttribute('role', 'dialog');
                    overlay.setAttribute('aria-modal', 'true');
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.95);
                        z-index: 100000;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = 'âœ• Close';
                    closeBtn.type = 'button';
                    closeBtn.tabIndex = 0;
                    closeBtn.style.cssText = `
                        position: absolute;
                        top: 20px;
                        left: 20px;
                        background: rgba(220, 38, 38, 0.9);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 16px;
                        font-weight: 600;
                        z-index: 100001;
                        transition: background 0.2s;
                    `;
                    closeBtn.onmouseenter = () => closeBtn.style.background = 'rgba(220, 38, 38, 1)';
                    closeBtn.onmouseleave = () => closeBtn.style.background = 'rgba(220, 38, 38, 0.9)';

                    const prevFocusEl = document.activeElement;
                    function closeTrailerOverlay() {
                        try {
                            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
                        } catch { }
                        try {
                            if (window.__trailerOverlayEl === overlay) window.__trailerOverlayEl = null;
                            if (window.__trailerPrevFocusEl === prevFocusEl) window.__trailerPrevFocusEl = null;
                            if (window.__closeTrailerOverlay) window.__closeTrailerOverlay = null;
                        } catch { }
                        try {
                            if (prevFocusEl && prevFocusEl instanceof HTMLElement) prevFocusEl.focus({ preventScroll: true });
                        } catch { }
                    }

                    closeBtn.onclick = () => closeTrailerOverlay();
                    
                    const iframe = document.createElement('iframe');
                    iframe.style.cssText = `
                        width: 90%;
                        max-width: 1280px;
                        height: 80vh;
                        max-height: 720px;
                        border: none;
                        border-radius: 8px;
                        background: #000;
                    `;
                    // Play with device/app volume (do not force mute).
                    iframe.src = `https://www.youtube-nocookie.com/embed/${videoId}?autoplay=1&mute=0&rel=0&playsinline=1`;
                    iframe.allow = 'autoplay; encrypted-media; fullscreen; picture-in-picture';
                    iframe.allowFullscreen = true;
                    
                    overlay.appendChild(closeBtn);
                    overlay.appendChild(iframe);

                    // Store globals so DPAD + BACK handling can find and close the overlay.
                    try {
                        window.__trailerOverlayEl = overlay;
                        window.__trailerPrevFocusEl = prevFocusEl;
                        window.__closeTrailerOverlay = closeTrailerOverlay;
                    } catch { }

                    // Attach to modalBackdrop when present so it becomes the navigation root.
                    const mount = (modalBackdrop && modalBackdrop.style.display === 'flex') ? modalBackdrop : document.body;
                    mount.appendChild(overlay);

                    // Focus Close immediately so DPAD can reach it.
                    try { closeBtn.focus({ preventScroll: true }); } catch { try { closeBtn.focus(); } catch { } }
                    
                    // Close on escape key
                    const escapeHandler = (e) => {
                        if (e.key === 'Escape') {
                            closeTrailerOverlay();
                            document.removeEventListener('keydown', escapeHandler);
                        }
                    };
                    document.addEventListener('keydown', escapeHandler);
                }
            } catch (e) {
                console.error('[Trailer] Play error:', e);
                setStatus('Failed to play trailer: ' + (e?.message || e), true);
            }
        }

        async function runTrailerFromButton(btnEl, opts = {}) {
            const idleText = String(opts.idleText || 'â–¶ Watch Trailer');
            const loadingText = String(opts.loadingText || 'Loading trailer...');

            if (!btnEl) return;
            const prevText = btnEl.textContent;
            btnEl.disabled = true;
            btnEl.textContent = loadingText;

            try {
                const rawTitle = currentDetailsCtx?.title || 'Unknown';
                const title = sanitizeTrailerTitle(rawTitle) || String(rawTitle || 'Unknown');
                const year = modalMetaEl.textContent.match(/\d{4}/);
                const yearStr = year ? year[0] : null;

                // Prefer backend TMDB trailer resolution (returns a real YouTube videoId)
                // This avoids opening YouTube search pages which often don't autoplay/play on TV.
                try {
                    const ctxType = String(currentDetailsCtx?.type || '').toLowerCase();
                    const ctxId = String(currentDetailsCtx?.id || '').trim();
                    const mediaType = (ctxType === 'movie') ? 'movie' : (ctxType === 'series' || ctxType === 'anime') ? 'tv' : '';
                    if (API_BASE && mediaType && ctxId) {
                        const url = `${API_BASE}/trailer/${encodeURIComponent(mediaType)}/${encodeURIComponent(ctxId)}`;
                        const res = await fetch(url, { signal: AbortSignal.timeout(6000) });
                        if (res.ok) {
                            const data = await res.json();
                            if (data?.videoId) {
                                await playTrailer(String(data.videoId));
                                return;
                            }
                        }
                    }
                } catch (e) {
                    console.log('[Trailer] Backend resolve failed, falling back:', e?.message || e);
                }

                let videoId = await searchYouTubeTrailer(title, yearStr);
                if (!videoId) {
                    videoId = await searchPipedTrailer(title, yearStr);
                }
                if (!videoId) {
                    console.log('[Trailer] Falling back to YouTube search results page');
                    videoId = await searchYouTubeTrailerSimple(title, yearStr);
                }

                if (videoId) {
                    await playTrailer(videoId);
                } else {
                    setStatus('Unable to search for trailer', true);
                }
            } catch (e) {
                console.error('[Trailer] Error:', e);
                setStatus('Failed to load trailer', true);
            } finally {
                btnEl.disabled = false;
                btnEl.textContent = idleText || prevText;
            }
        }

        const footerTrailerBtn = document.getElementById('footerTrailerBtn');
        if (trailerBtn) {
            trailerBtn.addEventListener('click', async () => {
                await runTrailerFromButton(trailerBtn, { idleText: 'â–¶ Watch Trailer', loadingText: 'Loading trailer...' });
            });
        }
        if (footerTrailerBtn) {
            footerTrailerBtn.addEventListener('click', async () => {
                await runTrailerFromButton(footerTrailerBtn, { idleText: 'Trailer', loadingText: 'Loadingâ€¦' });
            });
        }

        let __openDetailsReqId = 0;
        async function openDetails(item) {
            try {
            const reqId = ++__openDetailsReqId;
            const isStale = () => reqId !== __openDetailsReqId;

                // close search dropdown when opening details
                try { closeSearchContainer(); } catch {};
                lastFocusedEl = document.activeElement;

                const isTvCompact = (() => {
                    try { return document.documentElement.classList.contains('tv-compact'); } catch { }
                    return false;
                })();

                if (modalEl) modalEl.classList.remove("hasSide");
                if (modalSideEl) modalSideEl.innerHTML = "";
                if (modalEpisodesWrapEl) {
                    modalEpisodesWrapEl.innerHTML = '';
                    modalEpisodesWrapEl.style.display = 'none';
                }
                if (modalDescEl) {
                    modalDescEl.textContent = "";
                }

                try { modalEl?.classList.remove('movieTvMode'); } catch { }
                try { modalEl?.classList.remove('seriesTvMode'); } catch { }

                const movieHeroEl = document.getElementById('movieHero');
                const movieOverviewEl = document.getElementById('movieOverview');
                const movieArtEl = document.getElementById('movieArt');
                const movieActionsEl = document.getElementById('movieActions');
                if (movieHeroEl) {
                    movieHeroEl.style.display = 'none';
                    movieHeroEl.setAttribute('aria-hidden', 'true');
                }
                if (movieOverviewEl) movieOverviewEl.textContent = '';
                if (movieArtEl) movieArtEl.style.backgroundImage = '';
                if (movieActionsEl) movieActionsEl.innerHTML = '';

                if (trailerBtn) trailerBtn.style.display = 'none';

                const streamHeaderEl = document.getElementById('streamHeader');
                if (streamHeaderEl) streamHeaderEl.style.display = '';
                if (streamListEl) streamListEl.style.display = '';

                // Determine source/id (anime can be numeric -> treat as AniList)
                const rawId = String(item.id || '');
                const rawType = String(item.type || '').toLowerCase();

                let source = item.source ? String(item.source) : null;
                if (!source) {
                    if (rawId.startsWith('tmdb:')) source = 'tmdb';
                    else if (rawId.startsWith('anilist:')) source = 'anilist';
                    // For anime, prefer TMDB when the id looks like TMDB/IMDb (so we can show seasons/episodes)
                    else if (rawType === 'anime' && (rawId.startsWith('tt') || rawId.startsWith('tmdb:'))) source = 'tmdb';
                    else if (rawId.startsWith('tt') || /^\d+$/.test(rawId)) source = 'tmdb';
                    else if (rawType === 'anime') source = 'anilist';
                }

                let effectiveId = rawId;
                if (source === 'anilist' && effectiveId && !effectiveId.startsWith('anilist:')) effectiveId = `anilist:${effectiveId}`;
                if (source === 'tmdb' && effectiveId && effectiveId.startsWith('tmdb:')) {
                    // keep
                }

                // Try to fetch richer metadata from backend /meta if available
                let meta = null;
                try {
                    if (source === 'tmdb' || source === 'anilist') {
                        const res = await apiFetch(`${API_BASE}/meta/${encodeURIComponent(source)}/${encodeURIComponent(effectiveId)}`);
                        if (res.ok) meta = await res.json();
                    }
                } catch (e) { }

                if (isStale()) return;

                const poster = (meta && meta.poster) || item.poster || "";
                modalPosterEl.src = poster;
                modalPosterEl.onerror = () => { modalPosterEl.style.opacity = 0.2; };
                modalTitleEl.textContent = (meta && meta.title) || item.title || item.id || "Untitled";
                const getYear = (m) => {
                    const y = m?.year ?? m?.release_date ?? m?.first_air_date ?? null;
                    if (typeof y === 'number' && Number.isFinite(y)) return String(y);
                    if (typeof y === 'string' && y.length >= 4) return y.slice(0, 4);
                    return null;
                };
                const year = getYear(meta);
                const genres = Array.isArray(meta?.genres) ? meta.genres.filter(Boolean) : [];
                const metaParts = [];
                if (year) metaParts.push(year);
                if (rawType === 'anime' && meta?.episodes) metaParts.push(`${meta.episodes} episodes`);
                if (meta?.seasonsCount) metaParts.push(`${meta.seasonsCount} seasons`);
                if (genres.length) metaParts.push(genres.join(', '));
                
                // Display regular metadata
                metaTextEl.textContent = metaParts.join(' â€¢ ');
                
                // Add IMDb score badge if addon is enabled
                const imdbCfg = getImdbScoresConfig();
                imdbBadgeContainerEl.innerHTML = '';
                if (imdbCfg.enabled && rawId.startsWith('tt')) {
                    console.log('[IMDb Scores] Fetching score for', rawId);
                    const imdbScore = await fetchImdbScore(rawId);
                    if (isStale()) return;
                    if (imdbScore) {
                        const badge = document.createElement('div');
                        badge.className = 'imdbBadge';
                        badge.textContent = `${imdbScore}/10`;
                        imdbBadgeContainerEl.appendChild(badge);
                    }
                }

                currentDetailsCtx = {
                    id: effectiveId,
                    type: rawType || item.type,
                    title: (meta && meta.title) || item.title || item.id || 'Untitled',
                    poster,
                    source,
                    season: undefined,
                    episode: undefined
                };

                const itemTypeLower = (item.type || '').toLowerCase();
                const isMovie = itemTypeLower === 'movie';
                const wantsTvMovieLayout = isTvCompact && isMovie;
                let moviePlayRequested = false;
                let movieStreams = null;
                let movieStreamsError = null;
                let movieStreamsListBoxEl = null;
                let movieSourcesMode = false;

                const setStreamsVisible = (visible) => {
                    try {
                        if (streamHeaderEl) streamHeaderEl.style.display = visible ? '' : 'none';
                        if (streamListEl) streamListEl.style.display = visible ? '' : 'none';
                    } catch { }
                };

                if (wantsTvMovieLayout) {
                    try { modalEl?.classList.add('movieTvMode'); } catch { }
                    if (movieHeroEl) {
                        movieHeroEl.style.display = '';
                        movieHeroEl.setAttribute('aria-hidden', 'false');
                    }

                    // Put overview in the TV hero block, keep the big description hidden.
                    if (movieOverviewEl) movieOverviewEl.textContent = meta?.overview ? String(meta.overview) : '';
                    if (modalDescEl) modalDescEl.style.display = 'none';

                    // Use backdrop/background when available, else fall back to poster.
                    const bg = (meta && (meta.background || meta.backdrop || meta.poster)) || item.background || item.backdrop || poster;
                    if (movieArtEl && bg) movieArtEl.style.backgroundImage = `url(${JSON.stringify(String(bg))})`;

                    // Streams are available, but only shown after selecting Play.
                    setStreamsVisible(false);

                    if (movieActionsEl) {
                        const mkBtn = (label, sub, onActivate) => {
                            const b = document.createElement('button');
                            b.className = 'actionBtn';
                            b.type = 'button';
                            b.tabIndex = 0;
                            b.innerHTML = `
                                <div>${label}</div>
                                ${sub ? `<div class="actionBtnSub">${sub}</div>` : ''}
                            `;
                            const act = () => { try { onActivate && onActivate(); } catch { } };
                            b.addEventListener('click', act);
                            b.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') { e.preventDefault(); act(); }
                            });
                            return b;
                        };

                        const renderInfoMode = () => {
                            movieSourcesMode = false;
                            movieStreamsListBoxEl = null;
                            movieActionsEl.innerHTML = '';
                            const spacer = document.createElement('div');
                            spacer.style.flex = '1';

                            const playBtn = mkBtn('Play', 'Choose a stream', () => {
                                moviePlayRequested = true;
                                renderSourcesMode();
                            });
                            try { playBtn.setAttribute('data-modal-autofocus', 'true'); } catch { }
                            movieActionsEl.appendChild(spacer);
                            movieActionsEl.appendChild(playBtn);
                            try { playBtn.focus({ preventScroll: true }); } catch { }
                        };

                        const renderSourcesMode = () => {
                            movieSourcesMode = true;
                            movieActionsEl.innerHTML = '';

                            const header = document.createElement('div');
                            header.className = 'seriesMainHeader';
                            const title = document.createElement('div');
                            title.className = 'seriesMainTitle';
                            title.textContent = 'Choose a stream';
                            const backBtn = document.createElement('button');
                            backBtn.className = 'miniBackBtn';
                            backBtn.textContent = 'Back';
                            backBtn.addEventListener('click', () => renderInfoMode());
                            backBtn.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') { e.preventDefault(); backBtn.click(); }
                            });
                            header.appendChild(title);
                            header.appendChild(backBtn);

                            const listBox = document.createElement('div');
                            listBox.className = 'seriesListBox';
                            // Fixed-size scroll area inside the left column
                            listBox.style.maxHeight = '52vh';
                            listBox.style.overflow = 'auto';
                            listBox.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">Loading streamsâ€¦</div>';
                            movieStreamsListBoxEl = listBox;

                            movieActionsEl.appendChild(header);
                            movieActionsEl.appendChild(listBox);
                            try { backBtn.focus({ preventScroll: true }); } catch { }

                            // Render already-loaded streams immediately.
                            if (Array.isArray(movieStreams)) {
                                listBox.innerHTML = '';
                                if (!movieStreams.length) {
                                    listBox.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">No streams found.</div>';
                                } else {
                                    renderStreams(movieStreams, listBox);
                                    try {
                                        const first = listBox.querySelector('.streamItem');
                                        if (first) first.focus({ preventScroll: true });
                                    } catch { }
                                }
                            } else if (movieStreamsError) {
                                listBox.innerHTML = '<div style="color:#ff7a7a; padding: 14px;">Failed to load streams.</div>';
                            }
                        };

                        renderInfoMode();
                    }
                } else {
                    if (meta?.overview && modalDescEl) {
                        modalDescEl.textContent = meta.overview;
                        modalDescEl.style.display = "block";
                    }
                }

                // Show trailer button for series/anime and for non-TV movie layout.
                if (trailerBtn && (rawType === 'movie' || rawType === 'series' || rawType === 'anime')) {
                    if (!(wantsTvMovieLayout && rawType === 'movie')) {
                        trailerBtn.style.display = 'inline-block';
                    }
                }

                // On TV: prefer footer trailer button.
                try {
                    const footerTrailerBtn = document.getElementById('footerTrailerBtn');
                    if (footerTrailerBtn) {
                        footerTrailerBtn.style.display = isTvCompact && (rawType === 'movie' || rawType === 'series' || rawType === 'anime') ? '' : 'none';
                    }
                    // Hide the in-body trailer button on TV to avoid clutter.
                    if (isTvCompact && trailerBtn) trailerBtn.style.display = 'none';
                } catch { }

                function renderStreams(streams, container) {
                    const parseSizeBytesFromText = (txt) => {
                        const raw = String(txt || '').trim();
                        if (!raw) return null;
                        const s = raw.replace(/[\[\],]/g, '').trim();
                        if (!s) return null;
                        // Prefer explicit units
                        const m = s.match(/([0-9]+(?:\.[0-9]+)?)\s*(B|KB|MB|GB|TB|KiB|MiB|GiB|TiB)\b/i);
                        if (!m) return null;
                        const val = Number(m[1]);
                        if (!Number.isFinite(val) || val <= 0) return null;
                        const unit = String(m[2]).toUpperCase();
                        const mult = {
                            B: 1,
                            KB: 1024,
                            MB: 1024 * 1024,
                            GB: 1024 * 1024 * 1024,
                            TB: 1024 * 1024 * 1024 * 1024,
                            KIB: 1024,
                            MIB: 1024 * 1024,
                            GIB: 1024 * 1024 * 1024,
                            TIB: 1024 * 1024 * 1024 * 1024
                        };
                        return Math.round(val * (mult[unit] || 1));
                    };

                    const getSizeBytes = (s) => {
                        try {
                            if (s?.sizeBytes != null) {
                                const n = Number(s.sizeBytes);
                                if (Number.isFinite(n) && n > 0) return n;
                            }
                            // If provider gave a human-readable size string
                            if (s?.size != null) {
                                const asText = String(s.size).trim();
                                const parsed = parseSizeBytesFromText(asText);
                                if (parsed) return parsed;
                                // Avoid guessing for unit-less numeric strings
                            }
                            // Some providers embed it in the name like "[1.23 GB]"
                            const fromName = parseSizeBytesFromText(String(s?.name || ''));
                            if (fromName) return fromName;
                        } catch { }
                        return null;
                    };

                    const formatSize = (bytes) => {
                        if (!bytes || !Number.isFinite(bytes) || bytes <= 0) return 'Unknown';
                        const gb = bytes / (1024 * 1024 * 1024);
                        if (gb >= 1) return gb.toFixed(2) + ' GB';
                        const mb = bytes / (1024 * 1024);
                        if (mb >= 1) return mb.toFixed(0) + ' MB';
                        const kb = bytes / 1024;
                        return kb >= 1 ? kb.toFixed(0) + ' KB' : bytes + ' B';
                    };

                    const getQualityScore = (s) => {
                        const text = (String(s?.name || '') + ' ' + String(s?.url || '')).toLowerCase();
                        if (/\b(2160p|4k|uhd)\b/.test(text)) return 2160;
                        if (/\b(1440p|2k)\b/.test(text)) return 1440;
                        if (/\b1080p\b/.test(text)) return 1080;
                        if (/\b720p\b/.test(text)) return 720;
                        if (/\b480p\b/.test(text)) return 480;
                        if (/\b360p\b/.test(text)) return 360;
                        if (/\b240p\b/.test(text)) return 240;
                        return 0;
                    };

                    const qualityLabelFromScore = (q) => {
                        if (!q) return 'Unknown';
                        if (q === 2160) return '4K';
                        return q + 'p';
                    };

                    const sorted = (Array.isArray(streams) ? streams.slice() : []).map((s, idx) => ({ s, idx }))
                        .sort((a, b) => {
                            const qa = getQualityScore(a.s);
                            const qb = getQualityScore(b.s);
                            if (qb !== qa) return qb - qa;

                            const sa = getSizeBytes(a.s) || 0;
                            const sb = getSizeBytes(b.s) || 0;
                            if (sb !== sa) return sb - sa;

                            return a.idx - b.idx; // stable
                        });

                    sorted.forEach(({ s }, idx) => {
                        if (s.name && s.name.includes("Stream (")) return;

                        let fileType = "Unknown";
                        try {
                            const u = String(s.url || "");
                            const m = u.match(/\.([a-z0-9]{2,6})(?:[?#]|$)/i);
                            if (m) fileType = m[1].toUpperCase();
                            else {
                                const n = String(s.name || "").match(/\b(hls|mp4|mkv|webm|m3u8|ts|avi)\b/i);
                                if (n) fileType = n[1].toUpperCase();
                            }
                        } catch { }

                        const sizeBytes = getSizeBytes(s);
                        const sizeDisplay = formatSize(sizeBytes);

                        const qScore = getQualityScore(s);
                        const qualityLabel = qualityLabelFromScore(qScore);

                        const el = document.createElement("div");
                        el.className = "streamItem";
                        el.tabIndex = 0;
                        el.innerHTML = `
                            <div class="streamName">${s.name || `Stream ${idx + 1}`}</div>
                            <div class="streamMeta" style="color:rgba(255,255,255,0.6);font-size:12px;margin-top:6px;">
                                <span style="opacity:0.95">Quality: ${qualityLabel}</span>
                                <span style="margin-left:12px;">Size: ${sizeDisplay}</span>
                                <span class="streamType" style="margin-left:12px;">Type: ${fileType}</span>
                                ${s.provider ? `<span style="margin-left:12px;opacity:0.7">Source: ${s.provider}</span>` : ''}
                            </div>
                        `;

                        let playRequested = false;
                        const requestPlay = (evt) => {
                            if (playRequested) return;
                            playRequested = true;
                            playStreamAndClose(s);
                        };

                        el.addEventListener("click", (e) => requestPlay(e));
                        el.addEventListener("keydown", (e) => {
                            if (e.key === "Enter") {
                                try { e.preventDefault(); e.stopPropagation(); } catch { }
                                requestPlay(e);
                            }
                        });
                        container.appendChild(el);
                    });
                }

                streamListEl.innerHTML = "";
                
                console.log('[openDetails] Item:', item);

                // Use derived `source` from above

                // Series + Anime: fetch seasons/episodes from TMDB (anime can be discovered via AniList)
                const seasonLookupSource = (itemTypeLower === 'series' || itemTypeLower === 'anime') ? 'tmdb' : source;
                const seasonLookupId = effectiveId;

                // --- Local TV-series episodes (from IPTV grouping) ---
                if ((itemTypeLower === 'series' || itemTypeLower === 'anime') && Array.isArray(item.tvEpisodesLocal) && item.tvEpisodesLocal.length) {
                    console.log('[openDetails] Rendering local TV episodes (IPTV)');
                    if (modalEl) modalEl.classList.toggle('hasSide', !isTvCompact);
                    if (modalSideEl) modalSideEl.innerHTML = '';
                    if (modalDescEl) {
                        modalDescEl.textContent = '';
                        modalDescEl.style.display = 'none';
                    }

                    // Build seasons/episodes from titles
                    const parseSeasonEpisode = (title) => {
                        let season = 1, episode = 1;
                        let clean = title || 'Episode';
                        const patterns = [
                            /S(\d{1,2})\s*E(\d{1,3})/i,
                            /(\d{1,2})x(\d{1,3})/i,
                            /Season\s*(\d+)\D{0,3}Episode\s*(\d+)/i
                        ];
                        for (const re of patterns) {
                            const m = clean.match(re);
                            if (m) {
                                season = Number(m[1]) || 1;
                                episode = Number(m[2]) || 1;
                                clean = clean.replace(re, '').trim();
                                break;
                            }
                        }
                        clean = clean.replace(/\bS\d{1,2}\b/ig, '').replace(/\bE\d{1,3}\b/ig, '').trim();
                        if (!clean) clean = `Episode ${episode}`;
                        return { season, episode, clean };
                    };

                    const seasonsMap = {};
                    item.tvEpisodesLocal.forEach(ep => {
                        const title = ep.displayTitle || ep.channel?.name || ep.channel?.title || 'Episode';
                        const parsed = parseSeasonEpisode(title);
                        if (!seasonsMap[parsed.season]) seasonsMap[parsed.season] = [];
                        seasonsMap[parsed.season].push({
                            title: parsed.clean,
                            season: parsed.season,
                            episode: parsed.episode,
                            channel: ep.channel,
                            fullTitle: title
                        });
                    });

                    Object.values(seasonsMap).forEach(list => list.sort((a, b) => a.episode - b.episode));

                    openModal();

                    // In TV -> Series (IPTV), stream selection is not applicable.
                    try {
                        if (streamHeaderEl) streamHeaderEl.style.display = 'none';
                        if (streamListEl) streamListEl.style.display = 'none';
                        if (streamListEl) streamListEl.innerHTML = '';
                    } catch { }

                    const seasonNumbers = Object.keys(seasonsMap).map(n => Number(n)).sort((a, b) => a - b);

                    if (isTvCompact && modalEpisodesWrapEl) {
                        try { modalEl?.classList.add('seriesTvMode'); } catch { }
                        modalEpisodesWrapEl.style.display = 'block';
                        modalEpisodesWrapEl.innerHTML = '';

                        const shell = document.createElement('div');
                        shell.className = 'tvSeriesShell';

                        const infoPanel = document.createElement('div');
                        infoPanel.className = 'tvSeriesInfoPanel';
                        const infoTitle = document.createElement('div');
                        infoTitle.className = 'tvSeriesInfoTitle';
                        infoTitle.textContent = 'About';
                        const infoText = document.createElement('div');
                        infoText.className = 'tvSeriesInfoText';
                        infoText.textContent = 'Select a season, then an episode to play.';
                        infoPanel.appendChild(infoTitle);
                        infoPanel.appendChild(infoText);

                        const mainPanel = document.createElement('div');
                        mainPanel.className = 'tvSeriesMainPanel';

                        const browser = document.createElement('div');
                        browser.className = 'seriesBrowser';

                        const seasonsCol = document.createElement('div');
                        seasonsCol.className = 'seriesSeasons';
                        const seasonsTitle = document.createElement('div');
                        seasonsTitle.className = 'seriesSeasonsTitle';
                        seasonsTitle.textContent = 'Seasons';
                        seasonsCol.appendChild(seasonsTitle);

                        const mainCol = document.createElement('div');
                        mainCol.className = 'seriesMain';
                        const header = document.createElement('div');
                        header.className = 'seriesMainHeader';
                        const title = document.createElement('div');
                        title.className = 'seriesMainTitle';
                        title.textContent = 'Episodes';
                        header.appendChild(title);
                        mainCol.appendChild(header);

                        const listBox = document.createElement('div');
                        listBox.className = 'seriesListBox';
                        mainCol.appendChild(listBox);

                        browser.appendChild(seasonsCol);
                        browser.appendChild(mainCol);
                        mainPanel.appendChild(browser);

                        shell.appendChild(infoPanel);
                        shell.appendChild(mainPanel);
                        modalEpisodesWrapEl.appendChild(shell);

                        let activeSeason = seasonNumbers.length ? Number(seasonNumbers[0]) : null;

                        const markActiveSeasonBtn = (sn) => {
                            const btns = Array.from(seasonsCol.querySelectorAll('.seasonBtn'));
                            btns.forEach((b) => b.classList.toggle('active', Number(b.dataset.season) === Number(sn)));
                        };

                        const renderEpisodes = (sn) => {
                            listBox.innerHTML = '';
                            const list = seasonsMap[sn] || [];
                            if (!list.length) {
                                listBox.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">No episodes found.</div>';
                                return;
                            }

                            list.forEach((ep) => {
                                const row = document.createElement('div');
                                row.className = 'episode-card';
                                row.tabIndex = 0;
                                row.setAttribute('role', 'button');

                                const ph = document.createElement('div');
                                ph.className = 'episode-thumbPlaceholder';
                                ph.textContent = `S${String(ep.season).padStart(2,'0')}E${String(ep.episode).padStart(2,'0')}`;

                                const info = document.createElement('div');
                                info.className = 'episode-info';
                                const titleEl = document.createElement('div');
                                titleEl.className = 'episode-title';
                                titleEl.textContent = ep.title || ep.fullTitle || 'Episode';
                                const metaEl = document.createElement('div');
                                metaEl.className = 'episode-meta';
                                metaEl.textContent = `S${String(ep.season).padStart(2,'0')}E${String(ep.episode).padStart(2,'0')}`;
                                info.appendChild(titleEl);
                                info.appendChild(metaEl);

                                row.appendChild(ph);
                                row.appendChild(info);
                                row.title = ep.fullTitle;

                                const act = () => {
                                    playTVChannel(ep.channel);
                                    closeModal();
                                };
                                row.addEventListener('click', act);
                                row.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter') {
                                        e.preventDefault();
                                        act();
                                    }
                                });

                                listBox.appendChild(row);
                            });

                            try {
                                const first = listBox.querySelector('.episode-card');
                                if (first) first.focus({ preventScroll: true });
                            } catch { }
                        };

                        // Build season buttons
                        seasonNumbers.forEach((sn) => {
                            const btn = document.createElement('button');
                            btn.className = 'seasonBtn';
                            btn.dataset.season = String(sn);
                            const cnt = seasonsMap[sn]?.length || 0;
                            btn.textContent = `Season ${sn}${cnt ? ` â€¢ ${cnt} ep` : ''}`;
                            btn.addEventListener('click', () => {
                                activeSeason = Number(sn);
                                markActiveSeasonBtn(activeSeason);
                                title.textContent = `Season ${activeSeason} â€¢ Episodes`;
                                renderEpisodes(activeSeason);
                            });
                            btn.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    e.preventDefault();
                                    btn.click();
                                }
                            });
                            seasonsCol.appendChild(btn);
                        });

                        if (activeSeason != null) {
                            markActiveSeasonBtn(activeSeason);
                            title.textContent = `Season ${activeSeason} â€¢ Episodes`;
                            renderEpisodes(activeSeason);
                            try {
                                const firstSeasonBtn = seasonsCol.querySelector('.seasonBtn');
                                if (firstSeasonBtn) firstSeasonBtn.focus({ preventScroll: true });
                            } catch { }
                        }
                    } else {
                        // Non-TV fallback: keep the original dropdown-based UI (desktop-friendly).
                        const controls = document.createElement('div');
                        controls.className = 'season-selector';
                        const prevBtn = document.createElement('button'); prevBtn.className = 'season-nav-btn'; prevBtn.textContent = 'Prev';
                        const seasonSelect = document.createElement('select'); seasonSelect.className = 'season-select';
                        const selectWrapper = document.createElement('div'); selectWrapper.className = 'season-selectWrap';
                        const arrow = document.createElement('span'); arrow.textContent = 'â–¼'; arrow.className = 'seasonSelectArrow';
                        selectWrapper.appendChild(seasonSelect); selectWrapper.appendChild(arrow);
                        const nextBtn = document.createElement('button'); nextBtn.className = 'season-nav-btn'; nextBtn.textContent = 'Next';
                        controls.appendChild(prevBtn); controls.appendChild(selectWrapper); controls.appendChild(nextBtn);

                        if (modalSideEl) {
                            modalSideEl.innerHTML = '';
                            modalSideEl.appendChild(controls);
                            const episodesContainer = document.createElement('div');
                            episodesContainer.className = 'episodesList';
                            modalSideEl.appendChild(episodesContainer);

                            seasonNumbers.forEach((s) => {
                                const opt = document.createElement('option');
                                opt.value = s;
                                const count = seasonsMap[s].length;
                                opt.textContent = `Season ${s} (${count} Episode${count === 1 ? '' : 's'})`;
                                seasonSelect.appendChild(opt);
                            });

                            const renderSeason = (sNum) => {
                                episodesContainer.innerHTML = '';
                                const list = seasonsMap[sNum] || [];
                                list.forEach((ep) => {
                                    const row = document.createElement('div');
                                    row.className = 'episode-card';
                                    row.tabIndex = 0;
                                    row.setAttribute('role', 'button');
                                    const ph = document.createElement('div');
                                    ph.className = 'episode-thumbPlaceholder';
                                    ph.textContent = `S${String(ep.season).padStart(2,'0')}E${String(ep.episode).padStart(2,'0')}`;
                                    const info = document.createElement('div');
                                    info.className = 'episode-info';
                                    const titleEl = document.createElement('div');
                                    titleEl.className = 'episode-title';
                                    titleEl.textContent = ep.title || ep.fullTitle || 'Episode';
                                    const metaEl = document.createElement('div');
                                    metaEl.className = 'episode-meta';
                                    metaEl.textContent = `S${String(ep.season).padStart(2,'0')}E${String(ep.episode).padStart(2,'0')}`;
                                    info.appendChild(titleEl);
                                    info.appendChild(metaEl);
                                    row.appendChild(ph);
                                    row.appendChild(info);
                                    row.addEventListener('click', () => { playTVChannel(ep.channel); closeModal(); });
                                    episodesContainer.appendChild(row);
                                });
                            };

                            prevBtn.addEventListener('click', () => {
                                if (seasonSelect.selectedIndex > 0) seasonSelect.selectedIndex -= 1;
                                seasonSelect.dispatchEvent(new Event('change'));
                            });
                            nextBtn.addEventListener('click', () => {
                                if (seasonSelect.selectedIndex < seasonSelect.options.length - 1) seasonSelect.selectedIndex += 1;
                                seasonSelect.dispatchEvent(new Event('change'));
                            });
                            seasonSelect.addEventListener('change', (e) => {
                                const sVal = Number(e.target.value);
                                renderSeason(sVal);
                            });

                            if (seasonSelect.options.length) {
                                seasonSelect.selectedIndex = 0;
                                seasonSelect.dispatchEvent(new Event('change'));
                            }
                        }
                    }

                    // Set meta placeholders
                    metaTextEl.textContent = `${seasonNumbers.length} season${seasonNumbers.length === 1 ? '' : 's'}`;
                    imdbBadgeContainerEl.innerHTML = '';
                    return;
                }

                if ((itemTypeLower === 'series' || itemTypeLower === 'anime') && seasonLookupSource === 'tmdb') {
                    console.log('[openDetails] Detected episodic title, fetching seasons...');

                    if (modalEl) modalEl.classList.toggle('hasSide', !isTvCompact);
                    if (!isTvCompact && modalSideEl) {
                        modalSideEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">Loadingâ€¦</div>';
                    }
                    if (isTvCompact && modalEpisodesWrapEl) {
                        modalEpisodesWrapEl.style.display = 'block';
                        modalEpisodesWrapEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">Loadingâ€¦</div>';
                    }

                    const loading = document.createElement("div");
                    loading.style.color = "rgba(255,255,255,0.65)";
                    loading.textContent = "Select an episode to list streams.";
                    streamListEl.appendChild(loading);
                    
                    openModal(); 
                    try { updateLibraryButton(); } catch { }

                    try {
                        const res = await apiFetch(`${API_BASE}/seasons/${seasonLookupSource}/${encodeURIComponent(seasonLookupId)}`);
                        const data = await res.json();
                        if (isStale()) return;
                        console.log('[openDetails] Seasons data:', data);
                        streamListEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">Select an episode to list streams.</div>';

                        const streamLookupId = (data?.show && data.show.streamId) ? String(data.show.streamId) : String(item.id);
                        const streamTitleBase = (data?.show && data.show.title) ? String(data.show.title) : String((meta && meta.title) || item.title || item.name || 'Untitled');

                        // Prefer show details from /seasons response for header info
                        if (data?.show) {
                            const show = data.show;
                            if (show.poster) modalPosterEl.src = show.poster;
                            if (show.title) modalTitleEl.textContent = show.title;

                            if (currentDetailsCtx) {
                                if (show.title) currentDetailsCtx.title = String(show.title);
                                if (show.poster) currentDetailsCtx.poster = String(show.poster);
                            }

                            const parts = [];
                            if (show.year) parts.push(String(show.year));
                            if (show.seasonsCount) parts.push(`${show.seasonsCount} seasons`);
                            if (Array.isArray(show.genres) && show.genres.length) parts.push(show.genres.join(', '));
                            metaTextEl.textContent = parts.join(' â€¢ ');
                            
                            // Add IMDb badge for series
                            imdbBadgeContainerEl.innerHTML = '';
                            const imdbCfg = getImdbScoresConfig();
                            if (imdbCfg.enabled && rawId.startsWith('tt')) {
                                const imdbScore = await fetchImdbScore(rawId);
                                if (isStale()) return;
                                if (imdbScore) {
                                    const badge = document.createElement('div');
                                    badge.className = 'imdbBadge';
                                    badge.textContent = `${imdbScore}/10`;
                                    imdbBadgeContainerEl.appendChild(badge);
                                }
                            }

                            if (show.overview && modalDescEl) {
                                modalDescEl.textContent = show.overview;
                                modalDescEl.style.display = 'block';
                            }
                        }

                        if (data.seasons && data.seasons.length) {
                            console.log('[openDetails] Rendering seasons UI');

                            // TV-style UI: seasons list + episodes list that turns into a sources listbox.
                            // Use this cleaner browser on TV compact layouts.
                            if (isTvCompact && modalEpisodesWrapEl) {
                                try { modalEl?.classList.add('seriesTvMode'); } catch { }
                                try {
                                    if (streamHeaderEl) streamHeaderEl.style.display = 'none';
                                    if (streamListEl) streamListEl.style.display = 'none';
                                } catch { }

                                modalEpisodesWrapEl.style.display = 'block';
                                modalEpisodesWrapEl.innerHTML = '';

                                // Build a TV-friendly shell: left info panel, right seasons/episodes browser.
                                const shell = document.createElement('div');
                                shell.className = 'tvSeriesShell';

                                const infoPanel = document.createElement('div');
                                infoPanel.className = 'tvSeriesInfoPanel';
                                const infoTitle = document.createElement('div');
                                infoTitle.className = 'tvSeriesInfoTitle';
                                infoTitle.textContent = 'About';
                                const infoText = document.createElement('div');
                                infoText.className = 'tvSeriesInfoText';
                                // Prefer show overview when available, otherwise meta overview.
                                infoText.textContent = String((data?.show && data.show.overview) || meta?.overview || '') || 'Select a season to browse episodes.';
                                infoPanel.appendChild(infoTitle);
                                infoPanel.appendChild(infoText);

                                const mainPanel = document.createElement('div');
                                mainPanel.className = 'tvSeriesMainPanel';

                                const browser = document.createElement('div');
                                browser.className = 'seriesBrowser';

                                const seasonsCol = document.createElement('div');
                                seasonsCol.className = 'seriesSeasons';

                                const seasonsTitle = document.createElement('div');
                                seasonsTitle.className = 'seriesSeasonsTitle';
                                seasonsTitle.textContent = 'Seasons';
                                seasonsCol.appendChild(seasonsTitle);

                                const mainCol = document.createElement('div');
                                mainCol.className = 'seriesMain';

                                const mainHeader = document.createElement('div');
                                mainHeader.className = 'seriesMainHeader';
                                const mainTitle = document.createElement('div');
                                mainTitle.className = 'seriesMainTitle';
                                mainTitle.textContent = 'Episodes';
                                const backBtn = document.createElement('button');
                                backBtn.className = 'miniBackBtn';
                                backBtn.textContent = 'Back';
                                backBtn.style.display = 'none';
                                mainHeader.appendChild(mainTitle);
                                mainHeader.appendChild(backBtn);

                                const listBox = document.createElement('div');
                                listBox.className = 'seriesListBox';

                                mainCol.appendChild(mainHeader);
                                mainCol.appendChild(listBox);

                                browser.appendChild(seasonsCol);
                                browser.appendChild(mainCol);
                                mainPanel.appendChild(browser);

                                shell.appendChild(infoPanel);
                                shell.appendChild(mainPanel);
                                modalEpisodesWrapEl.appendChild(shell);

                                const usableSeasons = (data.seasons || []).filter(s => s && Number(s.season_number) > 0);

                                let activeSeason = null;
                                let lastActiveEpisodeEl = null;
                                let lastEpisodeCtx = null;

                                const setModeEpisodes = () => {
                                    mainTitle.textContent = activeSeason ? `Season ${activeSeason}` : 'Episodes';
                                    backBtn.style.display = 'none';
                                    lastActiveEpisodeEl = null;
                                    lastEpisodeCtx = null;
                                };

                                const setModeSources = (titleText) => {
                                    mainTitle.textContent = titleText || 'Sources';
                                    backBtn.style.display = '';
                                };

                                const showLoading = (txt) => {
                                    listBox.innerHTML = `<div style="color:rgba(255,255,255,0.6); padding: 14px;">${txt}</div>`;
                                };

                                const renderSeasons = () => {
                                    // buttons after title
                                    Array.from(seasonsCol.querySelectorAll('.seasonBtn')).forEach((n) => n.remove());
                                    usableSeasons.forEach((s) => {
                                        const btn = document.createElement('button');
                                        btn.className = 'seasonBtn';
                                        const sn = Number(s.season_number);
                                        btn.dataset.season = String(sn);
                                        const cnt = Number(s.episode_count);
                                        const cTxt = Number.isFinite(cnt) && cnt > 0 ? ` â€¢ ${cnt} ep` : '';
                                        btn.textContent = `Season ${sn}${cTxt}`;

                                        btn.addEventListener('click', () => {
                                            loadSeason(sn);
                                        });
                                        btn.addEventListener('keydown', (e) => {
                                            if (e.key === 'Enter') {
                                                e.preventDefault();
                                                btn.click();
                                            }
                                        });

                                        seasonsCol.appendChild(btn);
                                    });
                                };

                                const markActiveSeasonBtn = (sn) => {
                                    const btns = Array.from(seasonsCol.querySelectorAll('.seasonBtn'));
                                    btns.forEach((b) => b.classList.toggle('active', Number(b.dataset.season) === Number(sn)));
                                };

                                async function loadStreamsForEpisodeInPlace(seasonNum, episodeNum, epData) {
                                    const sNum = Number(seasonNum);
                                    const eNum = Number(episodeNum);
                                    const epTitle = (() => {
                                        const name = String(epData?.name || '').trim();
                                        if (name) return `${eNum}. ${name}`;
                                        return `Episode ${eNum}`;
                                    })();

                                    setModeSources(`S${String(sNum).padStart(2,'0')}E${String(eNum).padStart(2,'0')} â€¢ Sources`);
                                    showLoading(`Searching streams for S${sNum}E${eNum}â€¦`);

                                    try {
                                        if (currentDetailsCtx) {
                                            currentDetailsCtx.season = sNum;
                                            currentDetailsCtx.episode = eNum;
                                        }

                                        const title = streamTitleBase;
                                        const effectiveStreamType = (itemTypeLower === 'anime') ? 'series' : (itemTypeLower || 'movie');
                                        const url = `${API_BASE}/streams/${encodeURIComponent(streamLookupId)}?season=${sNum}&episode=${eNum}&title=${encodeURIComponent(title)}&type=${encodeURIComponent(effectiveStreamType)}`;
                                        const res = await apiFetch(url);
                                        const streams = await res.json();

                                        listBox.innerHTML = '';
                                        if (!streams || !streams.length) {
                                            listBox.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">No streams found.</div>';
                                            return;
                                        }
                                        renderStreams(streams, listBox);
                                    } catch (e) {
                                        listBox.innerHTML = '<div style="color:#ff7a7a; padding: 14px;">Error loading streams.</div>';
                                    }
                                }

                                async function loadSeason(sn) {
                                    activeSeason = Number(sn);
                                    markActiveSeasonBtn(activeSeason);
                                    setModeEpisodes();
                                    showLoading('Loading episodesâ€¦');
                                    try {
                                        const r = await apiFetch(`${API_BASE}/episodes/${seasonLookupSource}/${encodeURIComponent(seasonLookupId)}/${activeSeason}`);
                                        const d = await r.json();
                                        if (isStale()) return;
                                        listBox.innerHTML = '';

                                        const eps = Array.isArray(d?.episodes) ? d.episodes : [];
                                        if (!eps.length) {
                                            listBox.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">No episodes found.</div>';
                                            return;
                                        }

                                        eps.forEach((ep) => {
                                            const el = document.createElement('div');
                                            el.className = 'episode-card';
                                            el.tabIndex = 0;

                                            const isUnaired = (() => {
                                                try {
                                                    if (!ep.air_date) return true;
                                                    const d = new Date(ep.air_date);
                                                    if (Number.isNaN(d.getTime())) return true;
                                                    return d.getTime() > Date.now();
                                                } catch {
                                                    return true;
                                                }
                                            })();

                                            const makePlaceholder = (label) => {
                                                const ph = document.createElement('div');
                                                ph.className = 'episode-thumbPlaceholder';
                                                ph.textContent = label;
                                                return ph;
                                            };

                                            let thumbEl;
                                            if (ep.still) {
                                                const thumb = document.createElement('img');
                                                thumb.className = 'episode-thumb';
                                                try { thumb.decoding = 'async'; } catch { }
                                                thumb.src = ep.still;
                                                thumb.onerror = () => {
                                                    thumb.replaceWith(makePlaceholder(isUnaired ? 'Unaired' : 'No image'));
                                                };
                                                thumbEl = thumb;
                                            } else {
                                                thumbEl = makePlaceholder(isUnaired ? 'Unaired' : 'Not aired');
                                            }

                                            const info = document.createElement('div');
                                            info.className = 'episode-info';

                                            const titleEl = document.createElement('div');
                                            titleEl.className = 'episode-title';
                                            titleEl.textContent = `${ep.episode_number}. ${ep.name || ('Episode ' + ep.episode_number)}`;

                                            const metaEl = document.createElement('div');
                                            metaEl.className = 'episode-meta';
                                            metaEl.textContent = ep.air_date ? new Date(ep.air_date).toLocaleDateString() : '';

                                            info.appendChild(titleEl);
                                            info.appendChild(metaEl);

                                            el.appendChild(thumbEl);
                                            el.appendChild(info);

                                            const activateEpisode = () => {
                                                Array.from(listBox.children).forEach(c => c.classList && c.classList.remove('active'));
                                                el.classList.add('active');
                                                lastActiveEpisodeEl = el;
                                                lastEpisodeCtx = { season: activeSeason, episode: Number(ep.episode_number), ep };
                                                loadStreamsForEpisodeInPlace(activeSeason, ep.episode_number, ep);
                                            };

                                            el.addEventListener('click', activateEpisode);
                                            el.addEventListener('keydown', (e) => {
                                                if (e.key === 'Enter') {
                                                    e.preventDefault();
                                                    activateEpisode();
                                                }
                                            });

                                            listBox.appendChild(el);
                                        });

                                        // Focus first episode for TV comfort
                                        try {
                                            const first = listBox.querySelector('.episode-card');
                                            if (first) first.focus({ preventScroll: true });
                                        } catch { }
                                    } catch {
                                        listBox.innerHTML = '<div style="color:#ff7a7a; padding: 14px;">Error loading episodes.</div>';
                                    }
                                }

                                backBtn.addEventListener('click', () => {
                                    if (activeSeason != null) {
                                        loadSeason(activeSeason);
                                    }
                                });
                                backBtn.addEventListener('keydown', (e) => {
                                    if (e.key === 'Enter') {
                                        e.preventDefault();
                                        backBtn.click();
                                    }
                                });

                                renderSeasons();

                                // Auto-load the first season.
                                if (usableSeasons.length) {
                                    const firstSeason = Number(usableSeasons[0].season_number);
                                    markActiveSeasonBtn(firstSeason);
                                    loadSeason(firstSeason);
                                    try {
                                        const btn = seasonsCol.querySelector(`.seasonBtn[data-season="${firstSeason}"]`);
                                        if (btn) btn.focus({ preventScroll: true });
                                    } catch { }
                                } else {
                                    showLoading('No seasons found.');
                                }

                                return;
                            }
                            
                            // --- Season Selector UI ---
                            const controls = document.createElement('div');
                            controls.className = 'season-selector';
                            
                            const prevBtn = document.createElement('button');
                            prevBtn.className = 'season-nav-btn';
                            prevBtn.textContent = 'Prev';
                            
                            const seasonSelect = document.createElement('select');
                            seasonSelect.className = 'season-select';
                            
                            // Add a wrapper to center the select and maybe add a custom arrow if needed
                            const selectWrapper = document.createElement('div');
                            selectWrapper.className = 'season-selectWrap';
                            
                            // Custom arrow
                            const arrow = document.createElement('span');
                            arrow.textContent = 'â–¼';
                            arrow.className = 'seasonSelectArrow';
                            
                            data.seasons.forEach(s => {
                                if (s.season_number === 0) return; 
                                const opt = document.createElement('option');
                                opt.value = s.season_number;
                                const count = Number(s.episode_count);
                                const epCountText = Number.isFinite(count) && count > 0 ? ` (${count} Episode${count === 1 ? '' : 's'})` : '';
                                opt.textContent = `Season ${s.season_number}${epCountText}`;
                                opt.style.background = '#222'; // Dropdown options background
                                seasonSelect.appendChild(opt);
                            });
                            
                            selectWrapper.appendChild(seasonSelect);
                            selectWrapper.appendChild(arrow);

                            const nextBtn = document.createElement('button');
                            nextBtn.className = 'season-nav-btn';
                            nextBtn.textContent = 'Next';
                            
                            controls.appendChild(prevBtn);
                            controls.appendChild(selectWrapper);
                            controls.appendChild(nextBtn);

                            if (isTvCompact && modalEpisodesWrapEl) {
                                modalEpisodesWrapEl.style.display = 'block';
                                modalEpisodesWrapEl.innerHTML = '';
                                modalEpisodesWrapEl.appendChild(controls);
                            } else {
                                if (modalSideEl) modalSideEl.innerHTML = "";
                                if (modalSideEl) modalSideEl.appendChild(controls);
                            }
                            
                            const episodesContainer = document.createElement('div');
                            episodesContainer.className = 'episodesList';
                            if (isTvCompact && modalEpisodesWrapEl) modalEpisodesWrapEl.appendChild(episodesContainer);
                            else if (modalSideEl) modalSideEl.appendChild(episodesContainer);

                            // Navigation Logic
                            prevBtn.addEventListener('click', () => {
                                if (seasonSelect.selectedIndex > 0) {
                                    seasonSelect.selectedIndex--;
                                    seasonSelect.dispatchEvent(new Event('change'));
                                }
                            });
                            nextBtn.addEventListener('click', () => {
                                if (seasonSelect.selectedIndex < seasonSelect.options.length - 1) {
                                    seasonSelect.selectedIndex++;
                                    seasonSelect.dispatchEvent(new Event('change'));
                                }
                            });

                            function updateNavButtons() {
                                prevBtn.disabled = seasonSelect.selectedIndex <= 0;
                                nextBtn.disabled = seasonSelect.selectedIndex >= seasonSelect.options.length - 1;
                            }

                            async function loadEpisodes(seasonNum) {
                                updateNavButtons();
                                episodesContainer.innerHTML = '<div style="color:rgba(255,255,255,0.5); padding:20px; text-align:center;">Loading episodes...</div>';
                                streamListEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">Select an episode to list streams.</div>';
                                try {
                                    const r = await apiFetch(`${API_BASE}/episodes/${seasonLookupSource}/${encodeURIComponent(seasonLookupId)}/${seasonNum}`);
                                    const d = await r.json();
                                    episodesContainer.innerHTML = '';
                                    
                                    if (d.episodes && d.episodes.length) {
                                        d.episodes.forEach(ep => {
                                            const el = document.createElement('div');
                                            el.className = 'episode-card';
                                            
                                            // Thumbnail / placeholder (avoid broken-image icon for unaired episodes)
                                            const isUnaired = (() => {
                                                try {
                                                    if (!ep.air_date) return true;
                                                    const d = new Date(ep.air_date);
                                                    if (Number.isNaN(d.getTime())) return true;
                                                    return d.getTime() > Date.now();
                                                } catch {
                                                    return true;
                                                }
                                            })();

                                            const makePlaceholder = (label) => {
                                                const ph = document.createElement('div');
                                                ph.className = 'episode-thumbPlaceholder';
                                                ph.textContent = label;
                                                return ph;
                                            };

                                            let thumbEl;
                                            if (ep.still) {
                                                const thumb = document.createElement('img');
                                                thumb.className = 'episode-thumb';
                                                thumb.src = ep.still;
                                                thumb.onerror = () => {
                                                    thumb.replaceWith(makePlaceholder(isUnaired ? 'Unaired' : 'No image'));
                                                };
                                                thumbEl = thumb;
                                            } else {
                                                thumbEl = makePlaceholder(isUnaired ? 'Unaired' : 'Not aired yet');
                                            }
                                            
                                            // Info
                                            const info = document.createElement('div');
                                            info.className = 'episode-info';
                                            
                                            const title = document.createElement('div');
                                            title.className = 'episode-title';
                                            title.textContent = `${ep.episode_number}. ${ep.name || 'Episode ' + ep.episode_number}`;
                                            
                                            const meta = document.createElement('div');
                                            meta.className = 'episode-meta';
                                            meta.textContent = ep.air_date ? new Date(ep.air_date).toLocaleDateString() : '';
                                            
                                            info.appendChild(title);
                                            info.appendChild(meta);
                                            
                                            el.appendChild(thumbEl);
                                            el.appendChild(info);
                                            
                                            el.addEventListener('click', () => {
                                                Array.from(episodesContainer.children).forEach(c => c.classList.remove('active'));
                                                el.classList.add('active');
                                                if (currentDetailsCtx) {
                                                    currentDetailsCtx.season = Number(seasonNum);
                                                    currentDetailsCtx.episode = Number(ep.episode_number);
                                                }
                                                loadStreamsForEpisode(seasonNum, ep.episode_number, ep);
                                            });
                                            episodesContainer.appendChild(el);
                                        });
                                    } else {
                                        episodesContainer.innerHTML = '<div style="padding:20px; text-align:center; color:rgba(255,255,255,0.5)">No episodes found.</div>';
                                    }
                                } catch (e) {
                                    episodesContainer.innerHTML = '<div style="padding:20px; text-align:center; color:#ff7a7a">Error loading episodes.</div>';
                                }
                            }

                            async function loadStreamsForEpisode(season, episode, epData) {
                                streamListEl.innerHTML = '<div style="color:rgba(255,255,255,0.5); padding: 10px;">Searching streams for S' + season + 'E' + episode + '...</div>';
                                try {
                                    const title = streamTitleBase;
                                    const effectiveStreamType = (itemTypeLower === 'anime') ? 'series' : (itemTypeLower || 'movie');
                                    const url = `${API_BASE}/streams/${encodeURIComponent(streamLookupId)}?season=${season}&episode=${episode}&title=${encodeURIComponent(title)}&type=${encodeURIComponent(effectiveStreamType)}`;
                                    const res = await apiFetch(url);
                                    const streams = await res.json();

                                    streamListEl.innerHTML = '';
                                    if (!streams.length) {
                                        streamListEl.innerHTML = '<div style="padding:10px; color:rgba(255,255,255,0.6)">No streams found.</div>';
                                        return;
                                    }

                                    renderStreams(streams, streamListEl);
                                } catch (e) {
                                    streamListEl.innerHTML = 'Error loading streams.';
                                }
                            }

                            seasonSelect.addEventListener('change', () => loadEpisodes(seasonSelect.value));
                            if (seasonSelect.value) loadEpisodes(seasonSelect.value);
                            
                            return; 
                        } else {
                            if (modalEl) modalEl.classList.remove('hasSide');
                            if (modalSideEl) modalSideEl.innerHTML = '';
                            // If this was an anime item but TMDB seasons are unavailable, fall through to AniList episode UX (if applicable)
                            if (itemTypeLower !== 'anime') {
                                streamListEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">No seasons found for this series.</div>';
                                return;
                            }
                        }
                    } catch (e) {
                        console.error(e);
                        if (modalEl) modalEl.classList.remove('hasSide');
                        if (modalSideEl) modalSideEl.innerHTML = '';
                        if (itemTypeLower !== 'anime') return;
                    }
                }

                // Anime: seasons/episodes must come from TMDB. If the TMDB lookup fails, show a clear message.
                if (itemTypeLower === 'anime') {
                    if (modalEl) modalEl.classList.remove('hasSide');
                    if (modalSideEl) modalSideEl.innerHTML = '';
                    streamListEl.innerHTML = '<div style="color:rgba(255,255,255,0.65)">No seasons/episodes found on TMDB for this anime (or it could not be matched). Try a different title or search result.</div>';
                    openModal();
                    try { updateLibraryButton(); } catch { }
                    return;
                }

                // TV movie mode: load streams, but render them into the LEFT panel when Play is selected.
                if (wantsTvMovieLayout) {
                    openModal();
                    try { updateLibraryButton(); } catch { }

                    try {
                        const streams = await fetchStreams(item.id, item);
                        if (isStale()) return;
                        movieStreams = Array.isArray(streams) ? streams : [];
                    } catch (e) {
                        movieStreamsError = e;
                        movieStreams = null;
                    }

                    if (movieSourcesMode && movieStreamsListBoxEl) {
                        movieStreamsListBoxEl.innerHTML = '';
                        if (movieStreamsError) {
                            movieStreamsListBoxEl.innerHTML = '<div style="color:#ff7a7a; padding: 14px;">Failed to load streams.</div>';
                            return;
                        }
                        if (!Array.isArray(movieStreams) || !movieStreams.length) {
                            movieStreamsListBoxEl.innerHTML = '<div style="color:rgba(255,255,255,0.6); padding: 14px;">No streams found.</div>';
                            return;
                        }
                        renderStreams(movieStreams, movieStreamsListBoxEl);
                        try {
                            const first = movieStreamsListBoxEl.querySelector('.streamItem');
                            if (first) first.focus({ preventScroll: true });
                        } catch { }
                    }
                    return;
                }

                const loading = document.createElement("div");
                loading.style.color = "rgba(255,255,255,0.65)";
                loading.textContent = "Loading streamsâ€¦";
                streamListEl.appendChild(loading);

                openModal();
                try { updateLibraryButton(); } catch { }

                const streams = await fetchStreams(item.id, item);
                if (isStale()) return;
                streamListEl.innerHTML = "";

                if (!streams.length) {
                    const none = document.createElement("div");
                    none.style.color = "rgba(255,255,255,0.65)";
                    none.textContent = "No streams found for this title.";
                    streamListEl.appendChild(none);
                    return;
                }
                
                renderStreams(streams, streamListEl);

                // If user already selected Play, jump focus into the first source.
                if (wantsTvMovieLayout && moviePlayRequested) {
                    try {
                        const first = streamListEl?.querySelector('.streamItem');
                        if (first) first.focus();
                    } catch { }
                }

            } catch (e) {
                streamListEl.innerHTML = "";
                const err = document.createElement("div");
                err.style.color = "#ff7a7a";
                err.textContent = "Failed to load streams: " + (e?.message || e);
                streamListEl.appendChild(err);
            }
        }

        async function playStreamAndClose(stream) {
            try {
                const url = stream?.url || "";
                const name = stream?.name || "Stream";

                // If native playback is already active/starting, ignore duplicate requests.
                if (window.__nativePlayerActive || window.__nativePlayerStarting) {
                    try { closeModal(); } catch { }
                    return;
                }

                if (!url) {
                    setStatus("This stream has no URL.", true);
                    return;
                }

                // Magnets need resolving (Debrid) â€” MPV cannot play a magnet directly.
                if (stream.behaviorHints?.notWebReady || isMagnetLike(url)) {
                    setStatus("This source needs a resolver (Debrid). It is not a direct playable URL.", true);
                    return;
                }

                // Prefer native ExoPlayer fullscreen playback on Android/Chromecast.
                let usedNative = false;
                try {
                    const isTvCompact = (() => {
                        try { return document.documentElement.classList.contains('tv-compact'); } catch { }
                        return false;
                    })();

                    // VLC fallback exists for unsupported audio codecs, so keep the native URL.
                    // (The backend transcode proxy can still be used manually if needed.)
                    let playUrl = url;

                    // Some Android/Chromecast devices play video but cannot decode AC3/EAC3/DTS/TrueHD audio in Exo.
                    // In that case, use the backend proxy to transcode audio -> AAC (video is copied).
                    try {
                        const isHttp = /^https?:\/\//i.test(String(url || ''));
                        const alreadyCompat = String(url || '').includes('/transcode/audio?url=');
                        const looksLikeProblemAudio =
                            /(?:\bDTS\b|\bTRUE\s?HD\b|\bEAC3\b|\bAC3\b|\bDDP\b|\bDD\b)/i.test(String(name || '')) ||
                            /(?:dts|true(?:%20|\s)?hd|truehd|e-?ac-?3|eac3|ac3|ddp|dolby)/i.test(String(url || ''));
                        if (isTvCompact && API_BASE && isHttp && !alreadyCompat && looksLikeProblemAudio) {
                            playUrl = `${API_BASE}/transcode/audio?url=${encodeURIComponent(url)}`;
                        }
                    } catch { }

                    if (isTvCompact && typeof window.playNativeVideo === 'function') {
                        // Remember where we were so we can restore focus after BACK.
                        try { window.__preNativeFocusEl = document.activeElement; } catch { }
                        const res = await window.playNativeVideo(playUrl, {
                            title: currentDetailsCtx?.title || name,
                            poster: currentDetailsCtx?.poster || ''
                        });
                        if (res && res.ok) usedNative = true;
                    }
                } catch { }

                // Fall back to the existing player (MPV in Electron; HTML5 overlay in web).
                if (!usedNative) {
                    await playInEmbeddedMpv(name, url);
                }

                // Fetch subtitles in background (non-blocking)
                if (currentDetailsCtx?.id) {
                    fetchSubtitlesInBackground(currentDetailsCtx);
                }

                try {
                    if (currentUser && currentDetailsCtx?.id) {
                        await apiJson('/user/progress', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                id: currentDetailsCtx.id,
                                type: currentDetailsCtx.type,
                                title: currentDetailsCtx.title,
                                poster: currentDetailsCtx.poster,
                                source: currentDetailsCtx.source,
                                season: currentDetailsCtx.season,
                                episode: currentDetailsCtx.episode
                            })
                        });
                        if (currentTopTab !== 'settings') {
                            await refreshHome({ forceReload: false, clearItemsCache: false });
                        }
                    }
                } catch { }
                closeModal();
            } catch (e) {
                setStatus("Failed to play: " + (e?.message || e), true);
            }
        }

        // Fetch subtitles in background without blocking playback
        async function fetchSubtitlesInBackground(contentCtx) {
            try {
                const contentId = contentCtx.id;
                const contentType = contentCtx.type || 'movie';
                const season = contentCtx.season;
                const episode = contentCtx.episode;
                
                let subUrl = `${API_BASE}/subtitles/${encodeURIComponent(contentId)}?type=${encodeURIComponent(contentType)}`;
                if (season && episode) {
                    subUrl += `&season=${season}&episode=${episode}`;
                }
                
                const subRes = await apiFetch(subUrl);
                const subData = await subRes.json();
                const subtitles = subData?.subtitles || [];
                console.log(`[Subtitles] Found ${subtitles.length} subtitles for ${contentId}`);
                
                if (subtitles.length > 0) {
                    // Initialize subtitles in player (non-blocking)
                    // The player window will receive them via IPC event
                    try {
                        await window.mediaAPI.player.initSubtitles(subtitles);
                    } catch (e) {
                        console.log(`[Subtitles] Error initializing in background:`, String(e?.message || e));
                    }
                }
            } catch (e) {
                console.log(`[Subtitles] Background fetch error:`, String(e?.message || e));
                // Silently fail - doesn't block playback
            }
        }

        // ---------- Settings Rendering ----------
        const STREAM_LIMIT_LS_KEY = 'streamLimitConfig';

        function getStreamLimitConfig() {
            try {
                const uCfg = currentUserSettings?.streamLimitConfig;
                if (uCfg && typeof uCfg === 'object') {
                    const enabled = uCfg?.enabled !== false; // default ON
                    const limitNum = Number(uCfg?.limit ?? 60);
                    const limit = Number.isFinite(limitNum) ? Math.max(1, Math.min(200, Math.floor(limitNum))) : 60;
                    return { enabled, limit };
                }

                const raw = localStorage.getItem(STREAM_LIMIT_LS_KEY);
                const parsed = raw ? JSON.parse(raw) : null;
                const enabled = parsed?.enabled !== false; // default ON
                const limitNum = Number(parsed?.limit ?? 60);
                const limit = Number.isFinite(limitNum) ? Math.max(1, Math.min(200, Math.floor(limitNum))) : 60;
                return { enabled, limit };
            } catch {
                return { enabled: true, limit: 60 };
            }
        }

        function applyStreamLimitConfigToUI() {
            const cfg = getStreamLimitConfig();
            const toggle = document.getElementById('limitStreamsToggle');
            const input = document.getElementById('limitStreamsValue');
            if (toggle) toggle.checked = !!cfg.enabled;
            if (input) input.value = String(cfg.limit);
        }

        function getImdbScoresConfig() {
            try {
                const raw = localStorage.getItem('imdbScoresConfig');
                const parsed = raw ? JSON.parse(raw) : null;
                return { enabled: parsed?.enabled ?? false };
            } catch {
                return { enabled: false };
            }
        }

        function saveImdbScoresConfig() {
            const enabled = imdbScoresToggle ? !!imdbScoresToggle.checked : false;
            try {
                localStorage.setItem('imdbScoresConfig', JSON.stringify({ enabled }));
            } catch (err) {
                console.warn('[IMDb Scores] Save error:', err);
            }
            applyImdbScoresConfigToUI();
            setStatus(enabled ? 'IMDb scores enabled' : 'IMDb scores disabled');
        }

        function applyImdbScoresConfigToUI() {
            const cfg = getImdbScoresConfig();
            if (imdbScoresToggle) imdbScoresToggle.checked = !!cfg.enabled;
            if (imdbScoresStatus) imdbScoresStatus.textContent = cfg.enabled ? 'Enabled' : 'Disabled';
            // Load saved OMDB API key
            if (omdbApiKeyInput) {
                omdbApiKeyInput.value = omdbApiKey || '';
            }
        }

        // Store OMDB API key (user needs to set this in settings or update here)
        let omdbApiKey = localStorage.getItem('omdbApiKey') || '';

        async function fetchImdbScore(imdbId) {
            if (!imdbId || !imdbId.startsWith('tt')) return null;
            
            // If no API key is set, show a helpful message once
            if (!omdbApiKey) {
                console.warn('[IMDb Scores] No OMDB API key set. Visit http://omdbapi.com/apikey.aspx to get a free key.');
                return null;
            }
            
            try {
                const response = await fetch(`https://www.omdbapi.com/?apikey=${omdbApiKey}&i=${imdbId}&type=movie`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('[IMDb Scores] OMDB response:', data);
                    
                    if (data.Response === 'True' && data.imdbRating && data.imdbRating !== 'N/A') {
                        console.log('[IMDb Scores] Found rating:', data.imdbRating);
                        return data.imdbRating;
                    } else {
                        console.warn('[IMDb Scores] No rating in OMDB response:', data.Response, data.imdbRating);
                    }
                } else {
                    console.warn('[IMDb Scores] OMDB response not OK:', response.status);
                }
            } catch (err) {
                console.warn('[IMDb Scores] Fetch error:', err);
            }
            return null;
        }

        if (imdbScoresToggle) {
            imdbScoresToggle.addEventListener('change', () => saveImdbScoresConfig());
        }

        if (saveOmdbKeyBtn) {
            saveOmdbKeyBtn.addEventListener('click', async () => {
                const key = omdbApiKeyInput?.value?.trim();
                const keyStatus = document.getElementById('omdbKeyStatus');
                
                if (!key) {
                    setStatus('Please enter an API key', true);
                    if (keyStatus) keyStatus.textContent = 'âŒ No key entered';
                    return;
                }
                
                // Show loading state
                saveOmdbKeyBtn.disabled = true;
                const originalText = saveOmdbKeyBtn.textContent;
                saveOmdbKeyBtn.textContent = 'â³ Testing...';
                saveOmdbKeyBtn.style.opacity = '0.6';
                if (keyStatus) keyStatus.textContent = 'â³ Validating key...';
                
                try {
                    // Test the API key with a sample IMDb ID (Shawshank Redemption)
                    const testResponse = await fetch(`https://www.omdbapi.com/?apikey=${key}&i=tt0111161&type=movie`);
                    if (!testResponse.ok) throw new Error('API request failed');
                    
                    const testData = await testResponse.json();
                    
                    if (testData.Response === 'False') {
                        setStatus('Invalid OMDB API key. Please check your key.', true);
                        if (keyStatus) keyStatus.textContent = 'âŒ Invalid key';
                        saveOmdbKeyBtn.style.opacity = '1';
                    } else {
                        // Key is valid, save it
                        omdbApiKey = key;
                        localStorage.setItem('omdbApiKey', key);
                        setStatus('âœ“ OMDB API key saved! Ratings will appear when viewing titles.');
                        if (keyStatus) keyStatus.textContent = 'âœ“ Key valid';
                        saveOmdbKeyBtn.textContent = 'âœ“ Saved';
                        saveOmdbKeyBtn.style.background = 'rgba(34, 197, 94, 0.3)';
                        saveOmdbKeyBtn.style.color = '#86efac';
                        
                        // Reset button after 2 seconds
                        setTimeout(() => {
                            saveOmdbKeyBtn.textContent = originalText;
                            saveOmdbKeyBtn.style.background = '';
                            saveOmdbKeyBtn.style.color = '';
                            saveOmdbKeyBtn.style.opacity = '1';
                        }, 2000);
                    }
                } catch (err) {
                    console.warn('[IMDb Scores] Validation error:', err);
                    setStatus('Could not validate key. Check your internet connection.', true);
                    if (keyStatus) keyStatus.textContent = 'âš  Check connection';
                    saveOmdbKeyBtn.style.opacity = '1';
                } finally {
                    saveOmdbKeyBtn.disabled = false;
                }
            });
        }

        async function saveStreamLimitConfigFromUI() {
            const toggle = document.getElementById('limitStreamsToggle');
            const input = document.getElementById('limitStreamsValue');

            const enabled = toggle ? !!toggle.checked : true;
            const limitNum = Number(input ? input.value : 60);
            const limit = Number.isFinite(limitNum) ? Math.max(1, Math.min(200, Math.floor(limitNum))) : 60;

            localStorage.setItem(STREAM_LIMIT_LS_KEY, JSON.stringify({ enabled, limit }));
            try {
                if (currentUser) {
                    await saveUserSettings({ streamLimitConfig: { enabled, limit } });
                }
            } catch { }
            applyStreamLimitConfigToUI();
            setStatus(enabled ? `Stream limit enabled (max ${limit}).` : 'Stream limit disabled (using up to 200).');
        }

        async function loadSettings() {
            applyStreamLimitConfigToUI();
            applyImdbScoresConfigToUI();
            const addons = await fetchAddons();
            addonsList.innerHTML = "";

            addons.forEach((a) => {
                const row = document.createElement("div");
                row.className = "addonRow";

                const left = document.createElement("div");
                left.innerHTML = `
                        <div class="addonName">${a.name}</div>
                        <div class="addonMeta">
Source: ${a.source}${a.baseUrl ? "\nURL: " + a.baseUrl : ""}
Manifest ID: ${a.manifestId}${a.version ? "\nVersion: " + a.version : ""}${a.description ? "\n" + a.description : ""}
Status: ${a.status}
                        </div>
                    `;

                const right = document.createElement("div");
                right.className = "addonRight";

                const toggle = document.createElement("label");
                toggle.className = "toggle";

                const input = document.createElement("input");
                input.type = "checkbox";
                input.checked = !!a.enabled;

                const txt = document.createElement("span");
                txt.textContent = a.enabled ? "Enabled" : "Disabled";

                input.addEventListener("change", async () => {
                    try {
                        input.disabled = true;
                        setStatus(`Updating addon: ${a.name} â†’ ${input.checked ? "enabled" : "disabled"}â€¦`);
                        await setAddonEnabled(a.uid, input.checked);
                        txt.textContent = input.checked ? "Enabled" : "Disabled";
                        clearHomeCaches();
                        await refreshHome({ forceReload: true, clearItemsCache: true });
                        setStatus(`Updated: ${a.name}`);
                    } catch (e) {
                        setStatus("Failed to update addon: " + (e?.message || e), true);
                        input.checked = !input.checked;
                        txt.textContent = input.checked ? "Enabled" : "Disabled";
                    } finally {
                        input.disabled = false;
                    }
                });

                toggle.appendChild(input);
                toggle.appendChild(txt);
                right.appendChild(toggle);

                if (a.source === "remote") {
                    const rm = document.createElement("button");
                    rm.className = "btn btnDanger";
                    rm.textContent = "Remove";
                    rm.addEventListener("click", async () => {
                        try {
                            rm.disabled = true;
                            setStatus(`Removing addon: ${a.name}â€¦`);
                            await removeAddon(a.uid);
                            await loadSettings();
                            clearHomeCaches();
                            await refreshHome({ forceReload: true, clearItemsCache: true });
                            setStatus(`Removed: ${a.name}`);
                        } catch (e) {
                            setStatus("Failed to remove addon: " + (e?.message || e), true);
                        } finally {
                            rm.disabled = false;
                        }
                    });
                    right.appendChild(rm);
                }

                row.appendChild(left);
                row.appendChild(right);
                addonsList.appendChild(row);
            });
            // render Catalogs order UI (enabled catalog-providing addons)
            await renderCatalogOrder();

            // apply saved stream limit setting
            applyStreamLimitConfigToUI();
        }

        document.getElementById('saveStreamLimitBtn')?.addEventListener('click', () => saveStreamLimitConfigFromUI());

        async function handleLogin(isRegister = false) {
            const username = String(authUsernameEl?.value || '').trim();
            const password = String(authPasswordEl?.value || '');
            if (!username || !password) {
                setStatus('Enter username and password.', true);
                return;
            }

            try {
                if (loginBtn) loginBtn.disabled = true;
                if (registerBtn) registerBtn.disabled = true;
                setStatus(isRegister ? 'Registeringâ€¦' : 'Logging inâ€¦');

                if (isRegister) await authRegister(username, password);
                await authLogin(username, password);

                if (authPasswordEl) authPasswordEl.value = '';
                setStatus('Logged in.');
                clearHomeCaches();
                await refreshHome({ forceReload: false, clearItemsCache: false });
                applyStreamLimitConfigToUI();
            } catch (e) {
                setStatus((isRegister ? 'Register failed: ' : 'Login failed: ') + (e?.message || e), true);
            } finally {
                if (loginBtn) loginBtn.disabled = false;
                if (registerBtn) registerBtn.disabled = false;
            }
        }

        loginBtn?.addEventListener('click', () => handleLogin(false));
        registerBtn?.addEventListener('click', () => handleLogin(true));
        logoutBtn?.addEventListener('click', async () => {
            try {
                if (logoutBtn) logoutBtn.disabled = true;
                setStatus('Logging outâ€¦');
                await authLogout();
                setStatus('Logged out.');
                clearHomeCaches();
                await refreshHome({ forceReload: false, clearItemsCache: false });
                applyStreamLimitConfigToUI();
            } catch (e) {
                setStatus('Logout failed: ' + (e?.message || e), true);
            } finally {
                if (logoutBtn) logoutBtn.disabled = false;
            }
        });

        // Settings subtabs
        const settingsTabGeneral = document.getElementById('settingsTabGeneral');
        const settingsTabAddons = document.getElementById('settingsTabAddons');
        const settingsPanelGeneral = document.getElementById('settingsPanelGeneral');
        const settingsPanelAddons = document.getElementById('settingsPanelAddons');

        function showSettingsTab(tab) {
            if (tab === 'general') {
                settingsTabGeneral.classList.add('active');
                settingsTabAddons.classList.remove('active');
                settingsPanelGeneral.classList.add('active');
                settingsPanelAddons.classList.remove('active');
            } else if (tab === 'addons') {
                settingsTabGeneral.classList.remove('active');
                settingsTabAddons.classList.add('active');
                settingsPanelGeneral.classList.remove('active');
                settingsPanelAddons.classList.add('active');
            }
        }

        settingsTabGeneral?.addEventListener('click', () => showSettingsTab('general'));
        settingsTabAddons?.addEventListener('click', () => showSettingsTab('addons'));

        installBtn.addEventListener("click", async () => {
            const url = (installUrl.value || "").trim();
            if (!url) return;
            try {
                installBtn.disabled = true;
                setStatus("Installing addonâ€¦");
                await installAddon(url);
                installUrl.value = "";
                await loadSettings();
                clearHomeCaches();
                await refreshHome({ forceReload: true, clearItemsCache: true });
                setStatus("Addon installed.");
            } catch (e) {
                setStatus("Install failed: " + (e?.message || e), true);
            } finally {
                installBtn.disabled = false;
            }
        });

        // ---------- Home Load / Refresh ----------
        async function refreshHome(opts = {}) {
            const forceReload = !!opts.forceReload;
            const clearItemsCache = !!opts.clearItemsCache;
            if (clearItemsCache) catalogItemsCache = new Map();

            if (forceReload || !Array.isArray(catalogs) || !catalogs.length) {
                catalogs = await fetchCatalogsCached({ force: forceReload });
            }

            const view = currentTopTab === 'settings' ? 'home' : currentTopTab;

            // My List tab: show only the user's saved list (not regular catalogs)
            if (view === 'mylist') {
                rowsContainer.innerHTML = '';
                const src = document.getElementById('searchResultsContainer');
                if (src) { src.style.display = 'none'; src.innerHTML = ''; }

                if (!currentUser) {
                    renderHeroFromItem(null);
                    setStatus('Login to view My List.', true);
                    return;
                }

                try {
                    const listRaw = await fetchLibrarySafe({ force: true });
                    const listItems = (listRaw || []).map(x => ({ id: x.id, title: x.title, poster: x.poster, type: x.type, source: x.source }));
                    if (!listItems.length) {
                        renderHeroFromItem(null);
                        setStatus('My List is empty. Use â€œAdd to Listâ€ in a title.', false);
                        return;
                    }
                    appendStaticRowSection('My List', '', listItems);
                    setStatus(`Ready â€¢ My List: ${listItems.length}`);
                    return;
                } catch (e) {
                    renderHeroFromItem(null);
                    setStatus('Failed to load My List: ' + (e?.message || e), true);
                    return;
                }
            }

            const displayCatalogs = (catalogs || []).filter(c => catalogMatchesTab(c, view));

            // Render per-user rows first (if logged in)
            rowsContainer.innerHTML = '';
            if (currentUser) {
                try {
                    const [cwRaw] = await Promise.all([
                        fetchContinueWatchingSafe(),
                    ]);

                    const cwItems = (cwRaw || [])
                        .map(x => ({ id: x.id, title: x.title, poster: x.poster, type: x.type, source: x.source }))
                        .filter(it => itemMatchesTab(it, view));

                    if (cwItems.length) appendStaticRowSection('Continue Watching', '', cwItems, { compact: true });
                } catch { }
            }

            if (!catalogs.length) {
                renderHeroFromItem(null);
                setStatus("No catalogs found. Enable an addon that provides catalogs.", true);
                return;
            }

            if (!displayCatalogs.length) {
                renderHeroFromItem(null);
                setStatus(`No catalogs found for view: ${view}.`, true);
                // also hide search results container
                const src = document.getElementById('searchResultsContainer');
                if (src) { src.style.display = 'none'; src.innerHTML = ''; }
                return;
            }

            await renderRowsPlaceholder(displayCatalogs, { append: true });
            const q = (searchInput.value || "").trim();

            // If there is a search query, insert a top "Search results" row (Netflix style)
                const contributingAddons = new Set();
                if (q) {
                // Create header + row and insert into the search results container (under the search bar)
                const src = document.getElementById('searchResultsContainer');
                src.style.display = 'block';
                src.innerHTML = "";

                const header = document.createElement("div");
                header.className = "sectionHeader";
                const hTitle = document.createElement("div");
                hTitle.className = "sectionTitle";
                hTitle.textContent = `Search: ${q}`;
                const hint = document.createElement("div");
                hint.className = "sectionHint";
                hint.textContent = `Results`;
                header.appendChild(hTitle);
                header.appendChild(hint);

                const searchRow = document.createElement("div");
                searchRow.className = "row searchResultsRow";
                searchRow.dataset.search = "1";

                src.appendChild(header);
                src.appendChild(searchRow);

                // Aggregate results across catalogs (limit total tiles)
                const MAX_RESULT_TILES = 24;
                const MAX_PER_CATALOG = 6; // avoid filling with a single catalog
                let added = 0;
                const seenIds = new Set();
                let lastYield = __nowMs();
                for (const c of displayCatalogs) {
                    if (added >= MAX_RESULT_TILES) break;
                    try {
                        const items = await fetchCatalogItems(c.addonUid, c.type, c.id, q);
                        console.log(`[search-agg] catalog=${c.addonId} addonUid=${c.addonUid} returned ${items.length} items for query='${q}'`);

                        // CLIENT-SIDE filter: some addons may not respect search param â€” filter by title locally
                        const qlc = q.toLowerCase();
                        const filtered = (items || [])
                            .filter(it => (String(it.title || "") || "").toLowerCase().includes(qlc))
                            .filter(it => itemMatchesTab(it, view));
                        if (filtered.length) contributingAddons.add(`${c.addonUid}::${c.id}`); // mark this specific catalog as contributing

                        let perCat = 0;
                        for (const it of filtered) {
                            if (added >= MAX_RESULT_TILES) break;
                            if (perCat >= MAX_PER_CATALOG) break;
                            const idKey = `${it.type || 'm'}:${it.id}`;
                            if (seenIds.has(idKey)) continue;
                            seenIds.add(idKey);
                            searchRow.appendChild(createTile(it));
                            added++;
                            perCat++;
                            if ((added % 8) === 0) lastYield = await __yieldIfOverBudget(lastYield, 10);
                        }
                    } catch (e) { console.log(`[search-agg] catalog=${c.addonId} addonUid=${c.addonUid} failed: ${e?.message || e}`); }
                    lastYield = await __yieldIfOverBudget(lastYield, 10);
                }
                console.log(`[search] created search row for '${q}' with ${added} tiles`);
                if (added === 0) {
                    const none = document.createElement("div");
                    none.style.color = "rgba(255,255,255,0.65)";
                    none.style.padding = "12px 18px";
                    none.textContent = `No search results for '${q}'.`;
                    searchRow.appendChild(none);
                }
            } else {
                // hide search results container when no query
                const src = document.getElementById('searchResultsContainer');
                if (src) { src.style.display = 'none'; src.innerHTML = ''; }
            }

            // Populate the usual rows, hiding catalogs that contributed to the search
            await fillRows("", contributingAddons, view);
            setStatus(`Ready â€¢ Rows: ${displayCatalogs.length} â€¢ View: ${view} â€¢ Search: ${q || "off"}`);
        }

        async function init() {
            const initialTab = getPersistedTopTab();
            try {
                showBootSplash('Startingâ€¦');
                setStatus("Startingâ€¦");
                setTab(initialTab);

                // On app shells (Capacitor), API_BASE default often becomes localhost, which won't reach your PC backend.
                // Prompt the user to set the backend URL early.
                if (isLocalAppShell() && (!API_BASE || /^(https?:\/\/)?localhost(?::\d+)?$/i.test(API_BASE))) {
                    setStatus('Backend URL not set. Open Settings to configure, or enter it here.', true);
                    hideBootSplash();
                    showBackendSetup(null);
                    return;
                }

                await refreshMe();

                clearHomeCaches();
                catalogs = await fetchCatalogsCached({ force: true });
                await preloadAllCatalogItems(catalogs);
                await refreshHome({ forceReload: false, clearItemsCache: false });
                await loadSettings();

                // If last session was TV, ensure TV data is loaded during boot (no extra OK press).
                if (initialTab === 'tv') {
                    try { await loadTVChannels(); } catch { }
                }

                hideBootSplash();

                // TV: start with focus on the active tab (don't auto-select the first tile).
                try {
                    if (document.documentElement.classList.contains('tv-compact')) {
                        const activeTabBtn = document.querySelector('.tabs .tabBtn.active');
                        if (activeTabBtn) activeTabBtn.focus({ preventScroll: true });
                    }
                } catch { }
            } catch (e) {
                setStatus(
                    "Backend not reachable.\n\n" +
                    "Tip: set backend URL (example: http://<your-pc-ip>:3000).\n\n" +
                    "Error: " + (e?.message || e),
                    true
                );
                hideBootSplash();
                showBackendSetup(e);
            }
        }

        // Search behavior: suggestions on input, submit on Enter/Search
        const searchBtn = document.getElementById("searchBtn");

        let isSearchUiOpen = false;
        function openSearchUi() {
            try {
                if (!searchWrap) return;
                searchWrap.classList.remove('collapsed');
                searchWrap.style.display = 'flex';
                searchWrap.setAttribute('aria-hidden', 'false');
                isSearchUiOpen = true;
                try { searchInput?.focus(); } catch { }

                const q = (searchInput?.value || '').trim();
                if (q) {
                    // Open suggestions immediately for existing query
                    performSearchSuggestions(q);
                } else {
                    // Ensure dropdown is closed if query empty
                    const src = document.getElementById('searchResultsContainer');
                    if (src) { src.style.display = 'none'; src.innerHTML = ''; src.classList.remove('open'); }
                }
            } catch { }
        }

        function closeSearchUi(opts = {}) {
            try {
                const clear = !!opts.clear;
                const src = document.getElementById('searchResultsContainer');
                if (src) {
                    src.classList.remove('open');
                    src.style.display = 'none';
                    src.innerHTML = '';
                }
                if (clear && searchInput) searchInput.value = '';
                if (searchWrap) {
                    searchWrap.classList.add('collapsed');
                    searchWrap.style.display = 'none';
                    searchWrap.setAttribute('aria-hidden', 'true');
                }
                isSearchUiOpen = false;
            } catch { }
        }
        async function performSearchSuggestions(q) {
            const src = document.getElementById('searchResultsContainer');
            if (!src) return;
            q = (q || "").trim();
            if (!q) { src.style.display = 'none'; src.innerHTML = ''; return; }
            src.style.display = 'block';
            src.innerHTML = '';
            const header = document.createElement('div');
            header.className = 'sectionHeader';
            const hTitle = document.createElement('div');
            hTitle.className = 'sectionTitle';
            hTitle.textContent = `Search: ${q}`;
            header.appendChild(hTitle);
            src.appendChild(header);
            const searchRow = document.createElement('div');
            searchRow.className = 'row searchResultsRow';
            searchRow.dataset.search = '1';
            src.appendChild(searchRow);
            // Call global search API (backend) for suggestions
            try {
                const res = await apiFetch(`${API_BASE}/search?q=${encodeURIComponent(q)}&page=1`);
                if (res.ok) {
                    const raw = await res.json();
                    const payload = Array.isArray(raw) ? { items: raw, page: 1, total_pages: 1 } : raw || { items: [], page: 1, total_pages: 1 };
                    const MAX_SUGGEST = 12; let added = 0; const seen = new Set();
                    for (const it of (payload.items || [])) {
                        if (added >= MAX_SUGGEST) break;
                        const key = `${it.type||'m'}:${it.id}`;
                        if (seen.has(key)) continue;
                        seen.add(key);
                        const tile = createTile({ id: it.id, title: it.title, poster: it.poster, type: it.type });
                        tile.addEventListener('click', () => { openDetails({ id: it.id, title: it.title, poster: it.poster, type: it.type }); });
                        searchRow.appendChild(tile);
                        added++;
                    }
                }
            } catch (e) { }
            openSearchContainer();
        }

        // Submit search (press Enter or click Search): show aggregated results and hide contributing catalogs
        async function performSearchSubmit(q) {
            q = (q || '').trim();
            if (!q) {
                // clear search container and show normal rows
                const src = document.getElementById('searchResultsContainer'); if (src) { src.style.display='none'; src.innerHTML=''; }
                await fillRows('', new Set());
                return;
            }

            // initialize search state and render first page
            searchState.q = q;
            searchState.page = 1;

            const src = document.getElementById('searchResultsContainer');
            if (!src) return;
            src.style.display = 'block'; src.innerHTML = '';

            // header
            const header = document.createElement('div'); header.className='sectionHeader';
            const hTitle = document.createElement('div'); hTitle.className='sectionTitle'; hTitle.textContent = `Search: ${q}`;
            header.appendChild(hTitle); src.appendChild(header);

            // create row placeholder
            const searchRow = document.createElement('div'); searchRow.className = 'row searchResultsRow'; searchRow.dataset.search='1'; src.appendChild(searchRow);

            await loadSearchPage(1, searchRow, src);
            openSearchContainer();
            // Keep catalog rows as-is â€” catalogs are curated lists only
        }

        async function loadSearchPage(page = 1, searchRowEl = null, containerEl = null) {
            const q = (searchState.q || '').trim();
            if (!q) return;
            const src = containerEl || document.getElementById('searchResultsContainer');
            if (!src) return;

            try {
                const res = await apiFetch(`${API_BASE}/search?q=${encodeURIComponent(q)}&page=${Number(page||1)}`);
                if (!res.ok) return;
                const raw = await res.json();
                const payload = Array.isArray(raw) ? { items: raw, page: 1, total_pages: 1 } : raw || { items: [], page: 1, total_pages: 1 };
                searchState.page = Number(payload.page || page || 1);
                searchState.total_pages = Number(payload.total_pages || 1);

                // render tiles into provided row element or find/create one
                const searchRow = searchRowEl || src.querySelector('.searchResultsRow') || (() => {
                    const nr = document.createElement('div'); nr.className = 'row searchResultsRow'; nr.dataset.search = '1'; src.appendChild(nr); return nr;
                })();

                searchRow.innerHTML = '';
                const MAX_RESULT_TILES = 96; const seenIds = new Set();
                let added = 0;
                for (const it of (payload.items || [])) {
                    if (added >= MAX_RESULT_TILES) break;
                    const idKey = `${it.type||'m'}:${it.id}`;
                    if (seenIds.has(idKey)) continue;
                    seenIds.add(idKey);
                    const obj = { id: it.id, title: it.title, poster: it.poster, type: it.type };
                    const tile = createTile(obj);
                    tile.addEventListener('click', () => { openDetails(obj); });
                    searchRow.appendChild(tile);
                    added++;
                }

                // pagination controls
                const pager = document.createElement('div');
                pager.style.display = 'flex';
                pager.style.justifyContent = 'center';
                pager.style.alignItems = 'center';
                pager.style.gap = '8px';
                pager.style.marginTop = '8px';

                const prev = document.createElement('button'); prev.className = 'btn'; prev.textContent = 'Prev';
                const next = document.createElement('button'); next.className = 'btn'; next.textContent = 'Next';
                const info = document.createElement('div'); info.style.color = 'rgba(255,255,255,0.7)'; info.textContent = `Page ${searchState.page} / ${searchState.total_pages}`;

                prev.disabled = searchState.page <= 1;
                next.disabled = searchState.page >= searchState.total_pages;

                prev.addEventListener('click', async () => { if (searchState.page > 1) await loadSearchPage(searchState.page - 1, searchRowEl, src); });
                next.addEventListener('click', async () => { if (searchState.page < searchState.total_pages) await loadSearchPage(searchState.page + 1, searchRowEl, src); });

                pager.appendChild(prev); pager.appendChild(info); pager.appendChild(next);

                // remove existing pager if any
                const existingPager = src.querySelector('.searchPager');
                if (existingPager) existingPager.remove();
                const pagerWrap = document.createElement('div'); pagerWrap.className = 'searchPager'; pagerWrap.appendChild(pager);
                src.appendChild(pagerWrap);

            } catch (e) { console.log('[search] page load failed', e); }
        }

        // debounce suggestions
        let __suggestT = null;
        searchInput.addEventListener('input', () => {
            const q = (searchInput.value || '').trim();
            if (__suggestT) clearTimeout(__suggestT);
            __suggestT = setTimeout(() => performSearchSuggestions(q), 220);
        });

        searchInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                performSearchSubmit(searchInput.value || '');
            }
        });
        if (searchBtn) searchBtn.addEventListener("click", () => performSearchSubmit(searchInput.value || ''));

        async function doFullRefresh() {
            try {
                saveTabState(currentTopTab);
                showBootSplash('Refreshingâ€¦');
                setStatus('Refreshingâ€¦');
                clearHomeCaches();
                catalogs = await fetchCatalogsCached({ force: true });
                await preloadAllCatalogItems(catalogs);
                await refreshHome({ forceReload: false, clearItemsCache: false });
                restoreTabState(currentTopTab);
                setStatus('Ready');
            } catch (e) {
                setStatus('Refresh failed: ' + (e?.message || e), true);
            } finally {
                hideBootSplash();
            }
        }

        refreshBtn?.addEventListener("click", async () => {
            await doFullRefresh();
        });

        function openBrandMenu() {
            try {
                if (!brandMenuDropdown || !brandMenuBtn) return;
                brandMenuDropdown.classList.add('open');
                brandMenuDropdown.setAttribute('aria-hidden', 'false');
                brandMenuBtn.setAttribute('aria-expanded', 'true');
                window.__brandMenuIsOpen = true;
                window.__closeBrandMenu = closeBrandMenu;
                // Move focus into the menu for DPAD
                try { brandMenuRefreshBtn?.focus({ preventScroll: true }); } catch { try { brandMenuRefreshBtn?.focus(); } catch { } }
            } catch { }
        }

        function closeBrandMenu() {
            try {
                if (!brandMenuDropdown || !brandMenuBtn) return;
                brandMenuDropdown.classList.remove('open');
                brandMenuDropdown.setAttribute('aria-hidden', 'true');
                brandMenuBtn.setAttribute('aria-expanded', 'false');
            } catch { }
            try {
                window.__brandMenuIsOpen = false;
            } catch { }
        }

        function toggleBrandMenu() {
            try {
                const open = !!(brandMenuDropdown && brandMenuDropdown.classList.contains('open'));
                if (open) closeBrandMenu();
                else openBrandMenu();
            } catch { }
        }

        brandMenuBtn?.addEventListener('click', () => {
            toggleBrandMenu();
        });
        brandMenuBtn?.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                toggleBrandMenu();
            }
        });

        brandMenuRefreshBtn?.addEventListener('click', async () => {
            closeBrandMenu();
            await doFullRefresh();
        });

        brandMenuSettingsBtn?.addEventListener('click', async () => {
            closeBrandMenu();
            try { await switchTopTab('settings'); } catch { }
        });

        // Search icon toggle: open/close only on click (or Enter), not on focus.
        if (searchToggleBtn) {
            searchToggleBtn.addEventListener('click', () => {
                if (isSearchUiOpen) closeSearchUi({ clear: false });
                else openSearchUi();
            });
            searchToggleBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    searchToggleBtn.click();
                }
            });
        }

        // Open/close helpers for the search dropdown
        function openSearchContainer() {
            const src = document.getElementById('searchResultsContainer');
            if (!src) return;
            src.classList.add('open');
        }
        function closeSearchContainer() {
            const src = document.getElementById('searchResultsContainer');
            if (!src) return;
            src.classList.remove('open');
            // also clear content when closing
            //src.innerHTML = '';
        }

        // Do NOT open search UI or dropdown on focus; only open via the icon click.

        // close dropdown when clicking outside search area
        document.addEventListener('click', (e) => {
            const wrap = document.getElementById('searchWrap');
            const src = document.getElementById('searchResultsContainer');
            if (!wrap || !src) return;
            if (wrap.contains(e.target) || src.contains(e.target)) return;
            if (isSearchUiOpen) closeSearchUi({ clear: false });
            else closeSearchContainer();
        });

        // close brand menu when clicking outside it
        document.addEventListener('click', (e) => {
            try {
                if (!window.__brandMenuIsOpen) return;
                const btn = brandMenuBtn;
                const dd = brandMenuDropdown;
                if (!btn || !dd) return;
                if (btn.contains(e.target) || dd.contains(e.target)) return;
                closeBrandMenu();
            } catch { }
        });

        // Hero buttons (guarded â€” hero banner may be removed)
        if (heroOpenBtn) heroOpenBtn.addEventListener("click", () => { if (heroItem) openDetails(heroItem); });
        if (heroPlayBtn) heroPlayBtn.addEventListener("click", async () => {
            if (!heroItem) return;
            const streams = await fetchStreams(heroItem.id);
            if (!streams.length) { setStatus("No streams available for selected title.", true); return; }

            const s = streams[0];
            if (s.behaviorHints?.notWebReady || isMagnetLike(s.url)) {
                setStatus("This source needs a resolver (Debrid). It is not a direct playable URL.", true);
                return;
            }

            await playInEmbeddedMpv(s.name || "Stream", s.url);
        });

        // When entering settings, refresh list
        tabSettingsBtn?.addEventListener("click", async () => {
            try { await loadSettings(); } catch { }
        });

        // ========== IPTV Configuration ==========
        const iptvM3uInput = document.getElementById('iptvM3uInput');
        const iptvLoadBtn = document.getElementById('iptvLoadBtn');
        const iptvToggle = document.getElementById('iptvToggle');
        const iptvStatus = document.getElementById('iptvStatus');
        const iptvChannelCount = document.getElementById('iptvChannelCount');

        // IPTV config is proxied through backend so clients don't need direct access to the addon port.
        const IPTV_ADDON_URL = API_BASE;

        async function loadIPTVConfig() {
            try {
                console.log('[IPTV] Loading config from', IPTV_ADDON_URL);
                const res = await apiFetch(`${IPTV_ADDON_URL}/iptv/config`);
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                const config = await res.json();
                console.log('[IPTV] Config loaded:', config);
                
                iptvToggle.checked = config.enabled;
                iptvM3uInput.value = config.m3uUrl || '';
                iptvEpgInput.value = config.epgUrl || '';

                // Set TV cache scope based on current playlist URL.
                // This ensures the TV menu stays instant across restarts.
                try {
                    const m3u = String(config.m3uUrl || '').trim();
                    tvCacheScope = m3u ? hashStringFNV1a(m3u) : 'default';
                } catch { tvCacheScope = 'default'; }

                iptvStatus.textContent = config.enabled ? 'Enabled' : 'Disabled';
                const count = Number.isFinite(config.channelCount) ? config.channelCount : (config.channels?.length || 0);
                iptvChannelCount.textContent = count > 0 ? `Loaded: ${count} channels` : '';
                
                // Show/hide TV tab based on IPTV enabled status
                tabTVBtn.style.display = config.enabled ? 'block' : 'none';
                
                return config;
            } catch (e) {
                console.error('[IPTV] Failed to load config:', e);
                iptvStatus.textContent = 'Error connecting to addon';
                return null;
            }
        }

        iptvLoadBtn?.addEventListener('click', async () => {
            const m3uUrl = iptvM3uInput.value.trim();
            if (!m3uUrl) {
                setStatus('Please enter an m3u URL', true);
                return;
            }

            try {
                iptvLoadBtn.disabled = true;
                setStatus('Loading m3u playlist...');
                console.log('[IPTV] Fetching m3u from:', m3uUrl);
                
                const res = await apiFetch(`${IPTV_ADDON_URL}/iptv/config/m3u`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ m3uUrl, enabled: true })
                });
                
                const result = await res.json();
                console.log('[IPTV] Load result:', result);
                
                if (result.ok) {
                    iptvToggle.checked = true;
                    iptvStatus.textContent = 'Enabled';
                    iptvChannelCount.textContent = `Loaded: ${result.channelCount} channels`;
                    tabTVBtn.style.display = 'block';

                    // New playlist -> invalidate cached TV channels.
                    try {
                        const nextScope = m3uUrl ? hashStringFNV1a(m3uUrl) : 'default';
                        tvCacheScope = nextScope;
                        const key = getEffectiveTvCacheKey();
                        await idbDel(key);
                        try { localStorage.removeItem(key); } catch { }
                        try { localStorage.removeItem(TV_CACHE_KEY_BASE); } catch { }
                        tvChannelsCache = null;
                    } catch { }

                    setStatus(`âœ“ Loaded ${result.channelCount} channels from m3u`);
                    setTimeout(() => {
                        clearHomeCaches();
                        refreshHome({ forceReload: true, clearItemsCache: true });
                    }, 500);
                } else {
                    console.error('[IPTV] Load error:', result.error);
                    setStatus('Failed to load m3u: ' + result.error, true);
                }
            } catch (e) {
                console.error('[IPTV] Error:', e);
                setStatus('Error loading m3u: ' + (e?.message || e), true);
            } finally {
                iptvLoadBtn.disabled = false;
            }
        });

        iptvToggle?.addEventListener('change', async () => {
            try {
                const enabled = iptvToggle.checked;
                console.log('[IPTV] Toggle to:', enabled);
                setStatus(`${enabled ? 'Enabling' : 'Disabling'} IPTV...`);
                
                const res = await apiFetch(`${IPTV_ADDON_URL}/iptv/config/toggle`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });
                
                const result = await res.json();
                console.log('[IPTV] Toggle result:', result);
                
                if (result.ok) {
                    iptvStatus.textContent = enabled ? 'Enabled' : 'Disabled';
                    tabTVBtn.style.display = enabled ? 'block' : 'none';
                    if (!enabled && currentTopTab === 'tv') {
                        setTab('home');
                    }
                    setStatus(enabled ? 'âœ“ IPTV enabled' : 'âœ“ IPTV disabled');
                    setTimeout(() => {
                        clearHomeCaches();
                        refreshHome({ forceReload: true, clearItemsCache: true });
                    }, 500);
                }
            } catch (e) {
                console.error('[IPTV] Toggle error:', e);
                setStatus('Error toggling IPTV: ' + (e?.message || e), true);
                iptvToggle.checked = !iptvToggle.checked;
            }
        });

        // Clear TV cache button
        document.getElementById('iptvClearCacheBtn')?.addEventListener('click', async () => {
            try {
                const key = getEffectiveTvCacheKey();
                await idbDel(key);
                try { localStorage.removeItem(key); } catch { }
                try { localStorage.removeItem(TV_CACHE_KEY_BASE); } catch { }
            } catch { }
            tvChannelsCache = null;
            setStatus('âœ“ TV cache cleared');
            console.log('[TV Cache] Manually cleared');
        });

        // Load EPG URL when loading config
        const iptvEpgInput = document.getElementById('iptvEpgInput');
        const iptvSaveEpgBtn = document.getElementById('iptvSaveEpgBtn');
        
        iptvSaveEpgBtn?.addEventListener('click', async () => {
            const epgUrl = iptvEpgInput?.value?.trim();
            if (!epgUrl) {
                setStatus('Please enter an EPG URL', true);
                return;
            }

            try {
                iptvSaveEpgBtn.disabled = true;
                setStatus('Saving EPG URL...');
                console.log('[IPTV] Saving EPG URL:', epgUrl);
                
                const res = await apiFetch(`${IPTV_ADDON_URL}/iptv/config/epg`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ epgUrl })
                });
                
                const result = await res.json();
                console.log('[IPTV] EPG save result:', result);
                
                if (result.ok) {
                    setStatus('âœ“ EPG URL saved and loading...');
                    setTimeout(() => {
                        setStatus('âœ“ EPG URL saved');
                    }, 2000);
                } else {
                    console.error('[IPTV] EPG save error:', result.error);
                    setStatus('Failed to save EPG: ' + result.error, true);
                }
            } catch (e) {
                console.error('[IPTV] EPG save error:', e);
                setStatus('Error saving EPG: ' + (e?.message || e), true);
            } finally {
                iptvSaveEpgBtn.disabled = false;
            }
        });

        // Load IPTV config on startup and when settings are opened
        // Skip IPTV init until backend is configured (important on Capacitor where origin is localhost).
        if (API_BASE && !(isLocalAppShell() && /^(https?:\/\/)?localhost(?::\d+)?$/i.test(API_BASE))) {
            loadIPTVConfig();
        }
        const originalLoadSettings = loadSettings;
        loadSettings = async function(...args) {
            if (API_BASE && !(isLocalAppShell() && /^(https?:\/\/)?localhost(?::\d+)?$/i.test(API_BASE))) {
                await loadIPTVConfig();
            }
            return originalLoadSettings.apply(this, args);
        };

        init();
    </script>
</body>
</html>
